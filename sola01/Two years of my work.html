<html>
<meta charset="utf-8">
<style type="text/css">
/*基本效果*/
body{
	background-color:skyblue;
	margin:0 0 0 25%;
	padding:0;
}
#first_page{
	position:absolute;
	top:5%;
	width:40%;
	height:90%;
	border:1px solid white;
	border-radius:10px;
	z-index:10;
}
label{
	display:none;
}
b{
	color:red;
}
/*动画效果*/
#leafContainer 
{
    position: absolute;
    width: 100%;
    height: 100%;
	overflow:hidden;
}
#leafContainer > div 
{
    position: absolute;
	width:40%;
	height:90%;
    -webkit-animation-iteration-count: infinite, infinite;
    -webkit-animation-direction: normal, normal;
    -webkit-animation-timing-function: linear, ease-in;
}
#leafContainer > div > img {
     position: absolute;
     width: 100px;
     height: 100px;
     -webkit-animation-iteration-count: infinite;
     -webkit-animation-direction: alternate;
     -webkit-animation-timing-function: ease-in-out;
     -webkit-transform-origin: 100% -100%;
}
@-webkit-keyframes fade
{
    0%   { opacity: 1; }
    95%  { opacity: 1; }
    100% { opacity: 0; }
}
@-webkit-keyframes drop
{
    0%   { -webkit-transform: translate(0px, -50px); }
    100% { -webkit-transform: translate(0px, 650px); }
}
@-webkit-keyframes clockwiseSpin
{
    0%   { -webkit-transform: rotate(-50deg); }
    100% { -webkit-transform: rotate(50deg); }
}
@-webkit-keyframes counterclockwiseSpinAndFlip 
{
    0%   { -webkit-transform: scale(-1, 1) rotate(50deg); }
    100% { -webkit-transform: scale(-1, 1) rotate(-50deg); }
}
</style>
<body id="leafContainer">
	<canvas id="snow" width="200" height="200">A drawing of something.</canvas>
	<div id="first_page">
		<label>我的两年工作总结</label>
		<label>
			<label>前言</label>
			<label>
				<label>
<pre>
  <b>*</b>阅读时先看“关键字”，找到感兴趣的，再返回目录查看。</br></br>
  <b>*</b>提示：可Ctrl+F用浏览器的查找快速定位。</br></br>
  关键字是阅读笔记的总结。总结中重复类型书我尽量只选了一本来代表。</br></br>
  唯一的非阅读笔记是BIG里面的HBase集群搭建。</br></br>
  因为开始的比较晚，以下几本书今年是完不成了：</br></br>
    《Java核心技术 卷I 基础知识 原书第9版》《Java核心技术 卷II 高级特性 原书第9版》《鸟哥的Linux私房菜 基础学习篇(第3版)》《JavaScript高级程序设计（第3版）》《编程之美》《编程珠玑》</br></br>
    《鸟哥的Linux私房菜 服务器架设篇(第3版)》《深入理解Hadoop集群和网络》《Java虚拟机原理图解》《Java编程思想》《程序员面试笔试宝典》《Java 并发编程实战》《java消息服务（第二版）》《Lucene实战》《设计模式：Java语言中的应用》《研磨Struts2高清完整版》《研磨设计模式》《Java Web开发详解  XML+DTD+XML Schema+XSLT+Servlet 3.0+JSP 2.2深入剖析与实例应用》《JVM、GC详解及调优》《Tomcat与Java.Web开发技术详解》</br></br>
  全部内容，纯属手敲，如若使用，自行佐证。</br></br>
                                                    author by 徐东
</pre>
				</label>
			</label>
			<label>JAVA</label>
			<label>
				<label>常用笔记</label>
				<label>
					<label>记忆方法</label>
					<label>
						<label>
<pre><xmp>
联想记忆法
意义记忆法
比较记忆法
选择记忆法
重复记忆法
</xmp></pre>
						</label>
					</label>
					<label>正则表达式</label>
					<label>
						<label>
<pre><xmp>
.    IE下[^\n]，其它[^\n\r] 匹配除换行符之外的任何一个字符
\d    [0-9] 匹配数字
\D    [^0-9] 匹配非数字字符
\s    [ \n\r\t\f\x0B] 匹配一个空白字符
\S    [^ \n\r\t\f\x0B] 匹配一个非空白字符
\w    [a-zA-Z0-9_] 匹配字母数字和下划线
\W    [^a-zA-Z0-9_] 匹配除字母数字下划线之外的字符

* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。 * 等价于{0,}。
+ 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
? 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
</xmp></pre>
						</label>
					</label>
					<label>SQL常用笔记</label>
					<label>
						<label>
<pre><xmp>
>drop index on table
     #删除某个索引
>show index from table
     #显示表的索引
>show full processlist
     #正在运行的线程
>show open tables [from dabase][where In_use>0]
     #In_use表示正在使用这张表的线程数
     #Name_locked表示表名是否被锁
#MYSQL自带函数处理日期
	>SELECT date_format(time, '%Y%m') months FROM table GROUP BY months
	>select FROM_UNIXTIME(1428061353850/1000,'%Y-%m-%d %H:%i:%s') AS time #毫秒
	>SELECT UNIX_TIMESTAMP() #秒
#DATETIME()和 TIMESTAMP()
	存储空间不同：
		TIMESTAMP占用4个字节，DATETIME占用8个字节
	*日期和时间的组合。格式：YYYY-MM-DD HH:MM:SS
	注释：支持的范围是从 '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'
	*时间戳。TIMESTAMP 值使用 Unix 纪元('1970-01-01 00:00:00' UTC) 至今的描述来存储。格式：YYYY-MM-DD HH:MM:SS
	注释：支持的范围是从 '1970-01-01 00:00:01' UTC 到 '2038-01-09 03:14:07' UTC
#刷新授权表
	>flush privileges
#拼接字符串
	group_concat(col1,col2 order by id desc separator '.')
	concat(col1,col2)
#截取字符串
	substring(login,1,locate('m',login))
		#'233@163.com '->'233@163.com'
	left(login,locate('m',login))
#条件判断
	>select case col1 when 1 then 'yes' when 0 then 'no' else 'null' end from table
</xmp></pre>
						</label>
					</label>
					<label>JSON数据的数据格式</label>
					<label>
						<label>
<pre><xmp>
	JSON数据格式非常简单，简单来说，只有四点：
	1）并列数据之间用逗号（,）分隔；
	2）映射用冒号（:）表示；
	3）并列数据的集合用方括号（[]）表示；
	4）映射的集合用大括号（{}）表示。
	上面4条规则就是JSON的所有内容。
</xmp></pre>
						</label>
					</label>
					<label>log4j.properties配置详解与实例</label>
					<label>
						<label>
<pre><xmp>
################################################################################ 
#①配置根Logger，其语法为： 
# 
#log4j.rootLogger = [level],appenderName,appenderName2,... 
#level是日志记录的优先级，分为OFF,TRACE,DEBUG,INFO,WARN,ERROR,FATAL,ALL 
##Log4j建议只使用四个级别，优先级从低到高分别是DEBUG,INFO,WARN,ERROR 
#通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关 
#比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来 
#appenderName就是指定日志信息输出到哪个地方。可同时指定多个输出目的 
################################################################################ 
################################################################################ 
#②配置日志信息输出目的地Appender，其语法为： 
# 
#log4j.appender.appenderName = fully.qualified.name.of.appender.class 
#log4j.appender.appenderName.optionN = valueN 
# 
#Log4j提供的appender有以下几种： 
#1)org.apache.log4j.ConsoleAppender(输出到控制台) 
#2)org.apache.log4j.FileAppender(输出到文件) 
#3)org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件) 
#4)org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件) 
#5)org.apache.log4j.WriterAppender(将日志信息以流格式发送到任意指定的地方) 
# 
#1)ConsoleAppender选项属性 
# -Threshold = DEBUG:指定日志消息的输出最低层次 
# -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 
# -Target = System.err:默认值System.out,输出到控制台(err为红色,out为黑色) 
# 
#2)FileAppender选项属性 
# -Threshold = INFO:指定日志消息的输出最低层次 
# -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 
# -File = C:\log4j.log:指定消息输出到C:\log4j.log文件 
# -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 
# -Encoding = UTF-8:可以指定文件编码格式 
# 
#3)DailyRollingFileAppender选项属性 
# -Threshold = WARN:指定日志消息的输出最低层次 
# -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 
# -File = C:\log4j.log:指定消息输出到C:\log4j.log文件 
# -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 
# -DatePattern='.'yyyy-ww:每周滚动一次文件,即每周产生一个新的文件。还可以按用以下参数: 
#              '.'yyyy-MM:每月 
#              '.'yyyy-ww:每周 
#              '.'yyyy-MM-dd:每天 
#              '.'yyyy-MM-dd-a:每天两次 
#              '.'yyyy-MM-dd-HH:每小时 
#              '.'yyyy-MM-dd-HH-mm:每分钟 
# -Encoding = UTF-8:可以指定文件编码格式 
# 
#4)RollingFileAppender选项属性 
# -Threshold = ERROR:指定日志消息的输出最低层次 
# -ImmediateFlush = TRUE:默认值是true,所有的消息都会被立即输出 
# -File = C:/log4j.log:指定消息输出到C:/log4j.log文件 
# -Append = FALSE:默认值true,将消息追加到指定文件中，false指将消息覆盖指定的文件内容 
# -MaxFileSize = 100KB:后缀可以是KB,MB,GB.在日志文件到达该大小时,将会自动滚动.如:log4j.log.1 
# -MaxBackupIndex = 2:指定可以产生的滚动文件的最大数 
# -Encoding = UTF-8:可以指定文件编码格式 
################################################################################ 
################################################################################ 
#③配置日志信息的格式(布局)，其语法为： 
# 
#log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class 
#log4j.appender.appenderName.layout.optionN = valueN 
# 
#Log4j提供的layout有以下几种： 
#5)org.apache.log4j.HTMLLayout(以HTML表格形式布局) 
#6)org.apache.log4j.PatternLayout(可以灵活地指定布局模式) 
#7)org.apache.log4j.SimpleLayout(包含日志信息的级别和信息字符串) 
#8)org.apache.log4j.TTCCLayout(包含日志产生的时间、线程、类别等等信息) 
#9)org.apache.log4j.xml.XMLLayout(以XML形式布局) 
# 
#5)HTMLLayout选项属性 
# -LocationInfo = TRUE:默认值false,输出java文件名称和行号 
# -Title=Struts Log Message:默认值 Log4J Log Messages 
# 
#6)PatternLayout选项属性 
# -ConversionPattern = %m%n:格式化指定的消息(参数意思下面有) 
# 
#9)XMLLayout选项属性 
# -LocationInfo = TRUE:默认值false,输出java文件名称和行号 
# 
#Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： 
# %m 输出代码中指定的消息 
# %p 输出优先级，即DEBUG,INFO,WARN,ERROR,FATAL 
# %r 输出自应用启动到输出该log信息耗费的毫秒数 
# %c 输出所属的类目,通常就是所在类的全名 
# %t 输出产生该日志事件的线程名 
# %n 输出一个回车换行符，Windows平台为“\r\n”，Unix平台为“\n” 
# %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式 
#    如：%d{yyyy年MM月dd日 HH:mm:ss,SSS}，输出类似：2012年01月05日 22:10:28,921 
# %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数 
#    如：Testlog.main(TestLog.java:10) 
# %F 输出日志消息产生时所在的文件名称 
# %L 输出代码中的行号 
# %x 输出和当前线程相关联的NDC(嵌套诊断环境),像java servlets多客户多线程的应用中 
# %% 输出一个"%"字符 
# 
# 可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： 
#  %5c: 输出category名称，最小宽度是5，category<5，默认的情况下右对齐 
#  %-5c:输出category名称，最小宽度是5，category<5，"-"号指定左对齐,会有空格 
#  %.5c:输出category名称，最大宽度是5，category>5，就会将左边多出的字符截掉，<5不会有空格 
#  %20.30c:category名称<20补空格，并且右对齐，>30字符，就从左边交远销出的字符截掉 
################################################################################ 
################################################################################ 
#④指定特定包的输出特定的级别 
#log4j.logger.org.springframework=DEBUG 
################################################################################ 

#OFF,systemOut,logFile,logDailyFile,logRollingFile,logMail,logDB,ALL 
log4j.rootLogger =ALL,systemOut,logFile,logDailyFile,logRollingFile,logMail,logDB 

#输出到控制台 
log4j.appender.systemOut = org.apache.log4j.ConsoleAppender 
log4j.appender.systemOut.layout = org.apache.log4j.PatternLayout 
log4j.appender.systemOut.layout.ConversionPattern = [%-5p][%-22d{yyyy/MM/dd HH:mm:ssS}][%l]%n%m%n 
log4j.appender.systemOut.Threshold = DEBUG 
log4j.appender.systemOut.ImmediateFlush = TRUE 
log4j.appender.systemOut.Target = System.out 

#输出到文件 
log4j.appender.logFile = org.apache.log4j.FileAppender 
log4j.appender.logFile.layout = org.apache.log4j.PatternLayout 
log4j.appender.logFile.layout.ConversionPattern = [%-5p][%-22d{yyyy/MM/dd HH:mm:ssS}][%l]%n%m%n 
log4j.appender.logFile.Threshold = DEBUG 
log4j.appender.logFile.ImmediateFlush = TRUE 
log4j.appender.logFile.Append = TRUE 
log4j.appender.logFile.File = ../Struts2/WebRoot/log/File/log4j_Struts.log 
log4j.appender.logFile.Encoding = UTF-8 

#按DatePattern输出到文件 
log4j.appender.logDailyFile = org.apache.log4j.DailyRollingFileAppender 
log4j.appender.logDailyFile.layout = org.apache.log4j.PatternLayout 
log4j.appender.logDailyFile.layout.ConversionPattern = [%-5p][%-22d{yyyy/MM/dd HH:mm:ssS}][%l]%n%m%n 
log4j.appender.logDailyFile.Threshold = DEBUG 
log4j.appender.logDailyFile.ImmediateFlush = TRUE 
log4j.appender.logDailyFile.Append = TRUE 
log4j.appender.logDailyFile.File = ../Struts2/WebRoot/log/DailyFile/log4j_Struts 
log4j.appender.logDailyFile.DatePattern = '.'yyyy-MM-dd-HH-mm'.log' 
log4j.appender.logDailyFile.Encoding = UTF-8 

#设定文件大小输出到文件 
log4j.appender.logRollingFile = org.apache.log4j.RollingFileAppender 
log4j.appender.logRollingFile.layout = org.apache.log4j.PatternLayout 
log4j.appender.logRollingFile.layout.ConversionPattern = [%-5p][%-22d{yyyy/MM/dd HH:mm:ssS}][%l]%n%m%n 
log4j.appender.logRollingFile.Threshold = DEBUG 
log4j.appender.logRollingFile.ImmediateFlush = TRUE 
log4j.appender.logRollingFile.Append = TRUE 
log4j.appender.logRollingFile.File = ../Struts2/WebRoot/log/RollingFile/log4j_Struts.log 
log4j.appender.logRollingFile.MaxFileSize = 1MB 
log4j.appender.logRollingFile.MaxBackupIndex = 10 
log4j.appender.logRollingFile.Encoding = UTF-8 

#用Email发送日志 
log4j.appender.logMail = org.apache.log4j.net.SMTPAppender 
log4j.appender.logMail.layout = org.apache.log4j.HTMLLayout 
log4j.appender.logMail.layout.LocationInfo = TRUE 
log4j.appender.logMail.layout.Title = Struts2 Mail LogFile 
log4j.appender.logMail.Threshold = DEBUG 
log4j.appender.logMail.SMTPDebug = FALSE 
log4j.appender.logMail.SMTPHost = SMTP.163.com 
log4j.appender.logMail.From = xly3000@163.com 
log4j.appender.logMail.To = xly3000@gmail.com 
#log4j.appender.logMail.Cc = xly3000@gmail.com 
#log4j.appender.logMail.Bcc = xly3000@gmail.com 
log4j.appender.logMail.SMTPUsername = xly3000 
log4j.appender.logMail.SMTPPassword = 1234567 
log4j.appender.logMail.Subject = Log4j Log Messages 
#log4j.appender.logMail.BufferSize = 1024 
#log4j.appender.logMail.SMTPAuth = TRUE 

#将日志登录到MySQL数据库 
log4j.appender.logDB = org.apache.log4j.jdbc.JDBCAppender 
log4j.appender.logDB.layout = org.apache.log4j.PatternLayout 
log4j.appender.logDB.Driver = com.mysql.jdbc.Driver 
log4j.appender.logDB.URL = jdbc:mysql://127.0.0.1:3306/xly 
log4j.appender.logDB.User = root 
log4j.appender.logDB.Password = 123456 
log4j.appender.logDB.Sql = INSERT INTOT_log4j(project_name,create_date,level,category,file_name,thread_name,line,all_category,message)values('Struts2','%d{yyyy-MM-ddHH:mm:ss}','%p','%c','%F','%t','%L','%l','%m')
</xmp></pre>
						</label>
					</label>
					<label>雪崩</label>
					<label>
						<label>
<pre><xmp>
雪崩是指平时正常调用和被调用的A系统和B系统，突然A系统对B系统的访问超出B系统的承受能力，造成B系统崩溃。
造成雪崩的原因至少有下面三种：
	1、B系统的前置代理发生故障或者其他原因造成B系统暂时不可用，等B系统系统服务恢复时，A系统流量将铺天盖地打过来。
	2、Cache系统故障，A系统的访问将铺天盖地的打到B系统。
	3、Cache故障恢复，但这时Cache为空，Cache瞬间命中率为0，相当于Cache被击穿
</xmp></pre>
						</label>
					</label>
					<label>Spring注解形式的定时任务配置详解</label>
					<label>
						<label>
<pre><xmp>
一、SpringContext.xml中添加以下配置
	<!-- 添加扫描包 -->
	<context:component-scan base-package="com.task.springTask"></context:component-scan>
	<!-- 开启这个配置，spring才能识别@Scheduled注解 -->
	<task:annotation-driven />
二、定时任务Java代码
	import org.springframework.scheduling.annotation.Scheduled;
	import org.springframework.stereotype.Component;
	@Component("springTask")
		#类的上方注解，加在Service也可以
	@Scheduled(cron = "0/2 * * * * ?")
		#方法的上方注解(这个任务两秒执行一次)

cronExpression的配置说明，具体使用以及参数请百度google
	字段   允许值   允许的特殊字符
	秒    0-59    , - * /
	分    0-59    , - * /
	小时    0-23    , - * /
	日期    1-31    , - * ? / L W C
	月份    1-12 或者 JAN-DEC    , - * /
	星期    1-7 或者 SUN-SAT    , - * ? / L C #
	年（可选）    留空, 1970-2099    , - * / 
	- 区间  
	* 通配符  
	? 你不想设置那个字段
	下面只例出几个式子
 
CRON表达式    含义 
	"0/2 * * * * ?"     两秒执行一次
	"0 0 12 * * ?"    每天中午十二点触发 
	"0 15 10 ? * *"    每天早上10：15触发 
	"0 15 10 * * ?"    每天早上10：15触发 
	"0 15 10 * * ? *"    每天早上10：15触发 
	"0 15 10 * * ? 2005"    2005年的每天早上10：15触发 
	"0 * 14 * * ?"    每天从下午2点开始到2点59分每分钟一次触发 
	"0 0/5 14 * * ?"    每天从下午2点开始到2：55分结束每5分钟一次触发 
	"0 0/5 14,18 * * ?"    每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发 
	"0 0-5 14 * * ?"    每天14:00至14:05每分钟一次触发 
	"0 10,44 14 ? 3 WED"    三月的每周三的14：10和14：44触发 
	"0 15 10 ? * MON-FRI"    每个周一、周二、周三、周四、周五的10：15触发 
</xmp></pre>
						</label>
					</label>
					<label>分布式与集群的区别</label>
					<label>
						<label>
<pre><xmp>
简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。
一个任务被拆成多份;多个任务同时进行。
例子：
小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群
</xmp></pre>
						</label>
					</label>
					<label>.NET与JAVA</label>
					<label>
						<label>
<pre>
受限于平台的制约和商业的约束，C#的市场完全取决于windows服务器市场。BTW，SQL Server 也是同样的问题。
但是从开发层面上来说，导致.NET平台不够火的最直接的原因是：社区质量和规模远远不够
造成这种局面的最根本原因在于：不开放
微软想用不开放来把大家绑在他的战车上，可惜有才华的人总是桀骜不驯的，JAVA PHP Python却给了这些人自由。
java 的优势主要体现在虚拟机技术上，虚拟机技术使 java成为跨平台语言，而c#在出生伊始仅仅作为windows平台的开发语言，随着技术的推进，目前有很多办法可以让c#及.net框架下其他语言跨平台编译运行。
</pre>
						</label>
					</label>
					<label>文件删除</label>
					<label>
						<label>
<pre><xmp>
     public static boolean deleteF2(File dir) {
          if (dir.isDirectory()) {
               String[] children = dir.list();
               // 递归删除目录中的子目录下
               for (int i = 0; i < children.length; i++) {
                    boolean success = deleteF(new File(dir, children[i]));
                    if (!success) {
                         return false;
                    }
               }
          }
          // 目录此时为空，可以删除
          return dir.delete();
     }
</xmp></pre>
						</label>
					</label>
					<label>随机取一个四位长度的字母或数字</label>
					<label>
						<label>
<pre><xmp></xmp>
//随机取一个四位长度的字母或数字
String[] chararr=new String[62];
for(int i=48,j=0;i<=122;i++,j++){
     chararr[j]=String.valueOf((char)i);
     System.out.print(i==48?(char)i:","+(char)i);
     //0-9:48-57 A-Z:65-90 a-z:97-122
     if(i==57){i=i+7;}
     if(i==90){i=i+6;}
}
System.out.println("\n"+Arrays.toString(chararr));
String randomStr="";
for(int i=0;i<4;i++){
     int rn=new Random().nextInt(63);//0-60中随机数
     System.out.print(" "+chararr[rn]);
     randomStr+=chararr[rn];
}
System.out.println("\n"+randomStr);
</xmp></pre>
						</label>
					</label>
					<label>如何获得一个随机数</label>
					<label>
						<label>
<pre><xmp>
int a=(int )Math.round(Math. random()*10);//包括0、10
int a=new Random().nextInt(10);//包括0、不包括10
UUID.randomUUID().toString()
</xmp></pre>
						</label>
					</label>
					<label>URL 编码解码</label>
					<label>
						<label>
<pre><xmp>
String te="HTTP%E5%8D%8F%E8%AE%AE%E3%80%81" ;
System. out.println(URLEncoder. encode("HTTP协议、" ,"utf-8" ));
System. out.println(URLDecoder. decode(te,"utf-8"));
</xmp></pre>
						</label>
					</label>
					<label>MD5加密</label>
					<label>
						<label>
<pre><xmp>
概述：
Message-Digest Algorithm 5(消息摘要算法)，为计算机安全领域广泛使用的一种散列函数，用以提供消息的完整性保护。经MD2、MD3和MD4发展瑞来。
MD5的作用是让大容量信息在用数字签名软件签署私人密钥前被“压缩”成一种保密格式(就是把一个任意长度的字节串变成一定长的十六进制数字串)
加密到字节数组，再进行编码

package test;
import java.security.MessageDigest;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.xmlbeans.impl.util.Base64;
public class MD5 {
	public static void main(String[] args) throws Exception {
		//JDK 6 支持以下6种消息摘要算法，不区分大小写
		//MD5,SHA(SHA-1),MD2,SHA-256,SHA-384,SHA-512
		System.out.println("MD5加密："+md51("123456"));//MN7knhK6O6y8AvbcgX5V/A==
		System.out.println("MD5加密："+md52("123456"));//7a59b5eb8bbaa3c387529d2380753d55
		System.out.println(DigestUtils.md5Hex("123456"));
	}
	//MD5加密算法的Java实现
	public static String md52(String str) throws Exception{
		MessageDigest md=MessageDigest.getInstance("MD5");
		byte[] b=md.digest(str.getBytes("UTF-8"));
		//System.out.println(Arrays.toString(b));
		StringBuffer sb=new StringBuffer();
		for(int i=0;i<b.length;i++){
			//1)
			int val=(int)b[i] & 0xff;//不管何数与0xFF相与结果都是那个数的原值
			if(val<16)sb.append("0");
			sb.append(Integer.toHexString(val));
//			//2)
//			int val=(int)b[i];if(val<0){val+=256;}
//			if(val<16){sb.append("0");}
//			sb.append(Integer.toHexString(val));
//			//3)
//			char[] hex = {'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'}; 
//			byte byte0=b[i];
//			sb.append(hex[byte0 >>> 4 & 0xf]);
//			sb.append(hex[byte0 & 0xf]);
		}
		return sb.toString();
	}
	//TTSIS项目中的MD5加密
	public static String md51(String str) throws Exception{
		String password= str; 
		MessageDigest md = MessageDigest.getInstance("MD5");
		md.update(password.getBytes());
		Base64.encode(MessageDigest.getInstance("MD5").digest());
		byte[] bs = md.digest();
		byte[] base64MD5Password = Base64.encode(bs);
		return new String(base64MD5Password);
	}
}
</xmp></pre>
						</label>
					</label>
					<label>进制转换</label>
					<label>
						<label>
<pre><xmp>
int n=10;
Integer.toHexString(n);//十进制转十六进制
Integer.toOctalString(n);//十进制转八进制
Integer.toBinaryString(n);//十进制转二进制
Integer.toHexString(Integer.valueOf("23",8));//八进制转十六进制
</xmp></pre>
						</label>
					</label>
					<label>Java读取配置文件的其中一种方法</label>
					<label>
						<label>
<pre><xmp>
Properties p=new Properties();
p.load(
FileUtil.class.getClassLoader().getResourceAsStream("xx"));
String pptUrl=p.getProperty("");
</xmp></pre>
						</label>
					</label>
					<label>BaseDAO</label>
					<label>
						<label>
<pre><xmp>
package mysql;

//import java.net.ConnectException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class BaseDAO {
     public static PreparedStatement stmt=null;
     public static Connection con=null;
     public static ResultSet rs=null;
     public static void openCon(){
          try {
               Class.forName("oracle.jdbc.driver.OracleDriver");
               con=DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:orcl","scott","tiger");
          } catch (Exception e) {
               e.printStackTrace();
          }
     }
     public static void clossAll(){
          try {
               if(rs!=null)
               rs.close();
               if(stmt!=null)
                    stmt.close();
               if(con!=null)
                    con.close();
          } catch (Exception e) {
               e.printStackTrace();
          }
     }
     public static int updates(String sql,Object...objs){
          int count=0;
          openCon();
          try {
               stmt=con.prepareStatement(sql);
               for (int i = 0; i < objs.length; i++) {
                    stmt.setObject(i+1, objs[i]);
               }
               count=stmt.executeUpdate();
          } catch (Exception e) {
               e.printStackTrace();
          }
          return count;
     }
     public static void selects(String sql,Object...objs){
          openCon();
          try {
               stmt=con.prepareStatement(sql);
               for (int i = 0; i < objs.length; i++) {
                    stmt.setObject(i+1, objs[i]);
               }
               rs=stmt.executeQuery();
          } catch (Exception e) {
               e.printStackTrace();
          }
     }
}
</xmp></pre>
						</label>
					</label>
					<label>Date Canlendar</label>
					<label>
						<label>
<pre><xmp>
package test;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Properties;

public class getTime {
	
	public static void main(String[] args) throws ParseException {
		//TODO java.sql.date与java.util.date
//		System.out.println(new Date());
//		System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));
//		System.out.println(java.sql.Date.valueOf("2015-08-31"));
//		System.out.println(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse("2015-08-31 16:39:40"));
		//TODO Calendar方法
		SimpleDateFormat s=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		Date n=new Date();
		Date t=s.parse("2017-01-01 00:00:00");
		t=new Date();
		Calendar date=Calendar.getInstance();date.setTime(t);date.add(Calendar.DAY_OF_MONTH,-1);
		System.out.println("###n:"+s.format(n)+"###t:"+s.format(date.getTime()));
		System.out.println(n.getTime()<date.getTime().getTime());
		System.out.println("###n:"+s.format(t).substring(0,11)+"17:30:00"
				+"###t:"+s.format(date.getTime()).substring(0,11)+"17:30:00");
		
		//TODO 时间倒计时(一)		死循环，代码无效
//		SimpleDateFormat f1=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");//"2015-12-23 18:23:45"
//		Calendar calendar=Calendar.getInstance();calendar.setTime(new Date());calendar.add(Calendar.DATE, 1);
//		int start=0;
//		while(true){
//			if(start==1){try {Thread.sleep(1000);} catch (InterruptedException e) {e.printStackTrace();}}start=1;
//			long diff=f1.parse(f1.format(calendar.getTime().getTime()).substring(0,11)+"00:00:00").getTime()-new Date().getTime();
//			long days=diff/(24*60*60*1000);
//			long hours=(diff-days*24*60*60*1000)/(60*60*1000);
//			long minutes=(diff-days*24*60*60*1000-hours*60*60*1000)/(60*1000);
//			long seconds=(diff-days*24*60*60*1000-hours*60*60*1000-minutes*60*1000)/(1000);
//			System.out.println("今天结束还有："+hours+":"+minutes+":"+seconds);
//		}
		//TODO 去数组中同种元素
//		List<String> arr=new ArrayList<String>();
//		arr.add("1");arr.add("2");arr.add("3");arr.add("3");arr.add("4");
//		for(int i=0;i<arr.size();i++){
//			if(arr.get(i).equals("3")){arr.remove(arr.get(i));i--;}
//		}
//		for(String a:arr){System.out.println(a);}
		//TODO 求2的3次方
//		System.out.println(Math.pow(2,3));
//		System.out.println(2L<<3);
		//TODO 节省变量用while	感觉差不多
//		long start=System.currentTimeMillis();
//		int[]arr=new int[1000000];
//		for(int i=0;i<arr.length;i++){
//			arr[i]=i+1;
//		}
//		int len=arr.length;
//		while(len-->0){
//			System.out.println(arr[len]);
//		}
//		long end=System.currentTimeMillis();
//		System.out.println("共耗时"+(end-start)+"毫秒");
		System.out.println(getLastSundayAndMonday()[0]);
		System.out.println(getLastSundayAndMonday()[1]);
	}
	public static String[] getLastSundayAndMonday(){
		String[] arr=new String[2];
		SimpleDateFormat sf=new SimpleDateFormat("yyyy-MM-dd");
		Calendar c=Calendar.getInstance();
		c.setTime(new Date());
		c.add(Calendar.WEEK_OF_YEAR,-1);
		c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);
		arr[0]=sf.format(c.getTime());
		c=Calendar.getInstance();
		c.add(Calendar.WEEK_OF_YEAR,0);
		c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);
		arr[1]=sf.format(c.getTime());
		return arr;
	}
}
</xmp></pre>
						</label>
					</label>
					<label>HttpClient</label>
					<label>
						<label>
<pre><xmp>
package http;

import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLEncoder;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.params.HttpMethodParams;
import org.apache.commons.io.IOUtils;
import org.junit.Test;

public class HTTPPOST {
	
//	@Test
	public void testHttpClient() throws Exception{
		//TODO POST
		HttpClient client = new HttpClient(); 
		//设置代理服务器地址和端口       
	    //client.getHostConfiguration().setProxy("proxy_host_addr",proxy_port);  
        //使用GET方法，如果服务器需要通过HTTPS连接，那只需要将下面URL中的http换成https  
       	// HttpMethod method = new GetMethod("http://10.1.14.20:8088/workflowController/service/todo/addTask");   
        //使用POST方法  
        PostMethod method = new PostMethod("http://192.168.177.22/ttsis/inter/student");  
        String ms = "{\"publicKey\":\"RE1gWqdgXL\",\"time\":1470000000000,\"siphertext\":\"rEJv71qGak+xWzvlpvH2Tw==\"}";  
        ((PostMethod) method).addParameter("model", ms);  
		HttpMethodParams param = method.getParams();  
		param.setContentCharset("UTF-8");  
        client.executeMethod(method);  
        //打印服务器返回的状态  
        System.out.println(method.getStatusLine());  
        //打印返回的信息  
        InputStream stream = method.getResponseBodyAsStream();  
        //1.use IOUtils
        String resultStr = IOUtils.toString(stream,"UTF-8");
        System.out.println(resultStr);
        //2.use ByteArrayOutputStream
//        String resultStr = new String(readInputStream(stream),"UTF-8");
//        System.out.println(resultStr);
        //3.use BufferedReader
//        BufferedReader br = new BufferedReader(new InputStreamReader(stream, "UTF-8"));  
//        StringBuffer buf = new StringBuffer();  
//        String line;  
//        while (null != (line = br.readLine())) {  
//            buf.append(line).append("\n");  
//        }  
//        System.out.println(buf.toString());  
        //释放连接  
        method.releaseConnection();
	}
	@Test
	public void testHttpPost() throws Exception {
		/* classroom|seriesclass|course|center|city|region|student
		 * saveHBaseFromTTS2TMOOC saveRedisFromTTS2TMOOC2CLOSE saveRedisFromTTS2TMOOC2OPEN
		 * localhost:8080	192.168.177.22	ttsis8.tmooc.cn
		 * 2016-10-01 00:00:00 +30 student
		 * 1475251200000 1480435200000 cC5BNvqrW+V+TT7B6WaJOQ==
		 */
//		Calendar c=Calendar.getInstance(); 
//		String ttime="2016-10-01 00:00:00";
//		SimpleDateFormat si=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
//		c.setTime(si.parse(ttime));c.add(Calendar.DAY_OF_MONTH,60);
//		System.out.println(si.parse(ttime).getTime());
//		System.out.println(new Date().getTime()+"|"+c.getTime()+"|"+c.getTime().getTime());
        try {
        	String type="http://ttsis8.tmooc.cn/ttsis/inter/saveRedisFromTTS2TMOOC2OPEN";
        	String param="model="+URLEncoder.encode("{\"publicKey\":\"RE1gWqdgXL\",\"time\":\"1475251200000\",\"overtime\":\"1480435200000\",\"siphertext\":\"cC5BNvqrW+V+TT7B6WaJOQ==\"}","UTF-8");
        	String result=sendMessage1(type,param);
    		System.out.println("【URLConnection】size:"+result.length()+"\n"+result);
    		
//    		JSONObject rs=JSONObject.fromObject(result); 
//    		JSONArray rs2=JSONArray. fromObject(rs.get("mess"));
//    		List<TStudent> t=(List<TStudent>)JSONArray.toCollection(rs2,TStudent.class);
//    		System.out.println(t.get(0).toString());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	//TODO 方式一:
	public String sendMessage1(String type,String param) throws Exception{
		URL url = new URL(type);
        URLConnection urlConnection = url.openConnection();
        urlConnection.setDoOutput(true);// 设置是否向connection输出，因为这个是post请求，参数要放在http正文内，因此需要设为true
        urlConnection.setRequestProperty("content-type","application/x-www-form-urlencoded;charset=UTF-8");
        
        urlConnection.getOutputStream().write(param.getBytes("UTF-8"));
        String resultStr = IOUtils.toString(urlConnection.getInputStream(),"UTF-8");
		return resultStr;
	}
	//TODO 方式二:
	//通过HttpURLConnection模拟post表单提交
	//在HttpURLConnection post时，flush后建立连接，getInputstream时提交数据
	public String sendMessage2(String type,String param) throws Exception{
		URL url = new URL(type);
		HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的
        // 意思是正文是urlencoded编码过的form参数，下面我们可以看到我们对正文内容使用URLEncoder.encode
		//application/x-www-form-urlencoded 窗体数据被编码为名称/值对
        conn.addRequestProperty("Content-Type","application/x-www-form-urlencoded;charset=UTF-8");
        conn.setRequestMethod("POST");// 提交模式
        conn.setConnectTimeout(10000);//连接超时 单位毫秒
        conn.setDoOutput(true);//是否输入参数
//        conn.setUseCaches(false);// Post 请求不能使用缓存
//        conn.setReadTimeout(2000);//读取超时 单位毫秒
        
        byte[] bypes = param.getBytes();
        conn.getOutputStream().write(bypes);
        String resultStr = new String(readInputStream(conn.getInputStream()),"UTF-8");
		return resultStr;
	}
	//从输入流中读取数据
	public byte[] readInputStream(InputStream inStream) throws Exception{
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len = 0;
        while( (len = inStream.read(buffer)) !=-1 ){
            outStream.write(buffer, 0, len);
        }
        byte[] data = outStream.toByteArray();//网页的二进制数据
        outStream.close();
        inStream.close();
        return data;
    }

}
</xmp></pre>
						</label>
					</label>
					<label>...</label>
					<label>
						<label>
<pre><xmp>
...
</xmp></pre>
						</label>
					</label>
				</label>
				<label>《Java线程》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-26 03:33:45
备注：看本书目的，了解(Java)线程，怎么保证共享数据安全
进度：34/34

什么是线程
	进程就是在某种程度上相互隔离的、独立运行的程序
	线程也称作轻量级进程
	线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态
	每个Java程序都至少有一个线程——主线程
为什么使用线程
	使UI响应更快
	利用多处理系统：使用多个线程可以提高程序吞吐量和性能
	简化建模
	执行异步或后台处理
简单，但有时有风险
	当多个线程访问同一数据项(如静态字段、可全局访问对象的实例字段或共享集合)时，需确保它们协调了对数据的访问
	Java语言提供了两个关键字：synchronized和volatile
结束线程三种方式：
          线程到达其run()方法的末尾
          线程抛出一个未捕获到的Exception或Error
          另一个线程调用一个弃用的stop()方法。弃用是指这些方法仍然存在，但是不应该在新代码中使用它们，并且应该尽量从现有代码中除去它们
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第二章 线程基础】
1.什么是线程
     几乎每种操作系统都支持进程的概念——进程就是在某种程度上相互隔离的、独立运行的程序
     线程化是允许多个活动共存于一个进程中的工具
     Java是第一个在语言本身中显式地包含线程的主流编程语言
     线程也称作轻量级进程。线程在程序中是独立的、并发的执行路径，每个线程有它自己的堆栈、自己的程序计数器和自己的局部变量。但与分隔的进程相比，进程中的线程之间的隔离程度要小。它们共享内存、文件句柄和其它每个进程应有的状态
     一个进程中的多个线程共享相同的内存地址空间，这就意味着它们可以访问相同的变量和对象，而且它们从同一堆中分配对象。尽管这让线程之间共享信息变得更容易，但必须小心，确保它们不会妨碍同一进程里的其它线程
2.每个Java程序都使用线程
     每个Java程序都至少有一个线程——主线程。当一个Java程序启动时，JVM会创建主线程，并在该线程中调用程序的main()方法。JVM还创建了其它线程，例如垃圾收集、对象终止和其它JVM内务处理任务相关的线程
3.为什么使用线程
     使UI响应更快
     利用多处理系统：使用多个线程可以提高程序吞吐量和性能
     简化建模
     执行异步或后台处理
4.简单，但有时有风险
     当多个线程访问同一数据项(如静态字段、可全局访问对象的实例字段或共享集合)时，需确保它们协调了对数据的访问
     Java语言提供了两个关键字：synchronized和volatile
5.不要做过头
     过度使用线程可能会危及程序的性能及其可维护性
     线程消耗了资源。因此，在不降低性能的情况下，可以创建的线程数量是有限制的
【第三章 线程的生命】
1.创建线程
     每个Java程序至少包含一个线程：主线程。其它线程者是通过Thread构造器或实例化继承类Thread的类来创建的
2.结束线程
     三种方式：
          线程到达其run()方法的末尾
          线程抛出一个未捕获到的Exception或Error
          另一个线程调用一个弃用的stop()方法。弃用是指这些方法仍然存在，但是不应该在新代码中使用它们，并且应该尽量从现有代码中除去它们
3.休眠
     sleep()方法，使当前线程进入等等状态，直到过了一段指定时间，或者直到另一个线程对当前线程的Thread对象调用了Thread.interrupt()，从而中断了线程。当过了指定时间后，线程又将变成可运行的，并且回到调度程序的可运行线程队列中
     如果线程是由对Thread.interrupt()的调用而中断的，那么休眠的线程会抛出InterruptException，这样线程就知道它是由中断唤醒的
     Thread.yield()方法就象Thread.sleep()一样，但并不引起休眠，只是暂停当前线程片刻。当较高优先级的线程调用Thread.yield()时，较低优先级的线程就不会运行
4.守护程序线程
     隐藏的系统线程，如垃圾收集线程和由JVM创建的其它线程，这些系统线程称作守护程序线程
     Java程序实际上是在它的所有非守护程序线程完成后退出的
     任何线程都可以变成守护程序线程，通过调用Thread.setDaemon()方法来指明某个线程是守护程序线程
     只有当其它非守护程序线程正在运行时，这些线程才有用
【第四章 无处不在的线程】
1.AWT和Swing
     AWT事件线程并不是守护程序线程：这就是通常使用System.exit()结束AWT和Swing应用程序的原因
2.TimerTask，JDK1.3中被引入到Java语言的工具，可以稍后在某个时间执行任务或者定期执行任务
     TimerTask线程被标记成守护程序线程，这样它就不会阻止程序退出
3.Servlet和JavaServer Pagees技术
     Servlet容器创建多个线程，在这些线程中执行Servlet请求
     如果同时有多个对相同URL的请求入站，那么同一个Servlet可能会同时在多个线程中是活动的
4.小结：
     线程通过几种机制进入Java程序。除了用Thread构造器中显式创建线程之外，还可以用许多其它机制创建线程
     AWT和Swing
     RMI
     java.util.TimerTask工具
     servlet和JSP技术
【第五章 共享对数据的访问】
1.共享变量
     使用同步来确保值从一个线程正确传播到另一个线程，以及防止当一个线程正在更新一些相关数据项时，另一个线程看到不一致的中间结果
2.受控访问的同步
     为了确保可以在线程之间以受控方工共享数据，Java语言提供了两个关键字：synchronized和volatile
     Synchronized有两个重要含义：
          确保一次只有一个线程可以执行代码的受保护部分(互斥，mutaul exclusion或者说mutex)
          确保一个线程更改的数据对于其它线程是可见的(更改的可见性)
     同步的原子执行或互斥方面类似于其它操作环境中的临界段的概念
3.确保共享数据更改的可见性
     同步可以让我们确保线程看到一致的内存视图
     处理器可以使用高速缓存加速对内存的访问(或者编译器可以将值存储到寄存器中以便进行更快的访问)。在一些多处理器体系结构上，如果在一个处理器的高速缓存中修改了内存位置，没有必要让其它处理器看到这一修改，直到刷新了写入器的高速缓存并且使读取器的高速缓存无效
     Volatile比同步更简单，只适合于控制对基本变量(整数、布尔变量等)的单个实例的访问。当一个变量被声明成volatile，任何对该变量的写操作都会绕过高速缓存，直接写入主内存，而任何对该变量的读取也都绕过高速缓存，直接取自主内存。这表示所有线程在任何时候看到的volatile变量值都相同
     如果没有正确的同步，线程可能会看到旧的变量值，或者引起其它形式的数据损坏
     多个并发线程会互相干扰对方的更改，从而损坏数据，或者其它线程也许不能及时看到对共享数据的更改
4.用锁保护的原子代码块
     Volatile对于确保每个线程看到最新的变量值非常有用，但不适合大的代码片段
     同步使用监控器(monitor)或锁的概念，以协调对特定代码块的访问
     每个Java对象都有一个相关的锁。同一时间只能有一个线程持有Java锁
     这样，每次只有一个线程可以执行受给定监控器保护的代码块。从其它线程的角度看，该代码块可以看作是原子的，要么全部执行，要么根本不执行
5.同步的块
     每个Java对象都可以充当锁
     使用this引用作为锁很常见，但这并不是必需的。这表示该代码块将与这个类中的synchronized方法使用同一个锁
6.大多数类并没有同步
     因为同步会带来小小的性能损失，大多数通用类，如java.util中的Collection类，不在内部使用同步。这表示在没有附加同步的情况下，不能在多个线程中使用诸如HashMap这样的类
     如果类的文档没有说明它是线程安全的，那么必须假设它不是
【第六章 同步详细信息】
1.互斥
2.可见性
3.什么时候不需要同步
     在某些情况中，不必用同步来将数据从一个线程传递到另一个，因为JVM已经隐含地执行同步
     由静态初始化器(在静态字段上或static{}块中的初始化器)初始化数据时
     访问final字段时
     在创建线程之前创建对象时
     线程可以看见它将要处理的对象时
4.死锁
     只要拥有多个进程，而且它们要争用对多个锁的独占访问，那么就有可能发生死锁
     如果有一组进程或线程，其中每个都在等待一个只有其它进程或线程才可以执行的操作，那么就称它们被死锁了
     要避免死锁，应该确保在获取多个锁时，在所有的线程中都以相同的顺序获取锁
5.同步准则
     当编写synchronized块时，几个简的准则在避免死锁和性能危险的风险方面大有帮助
     使代码块保持简短
     不要阻塞：不要调用可能引起阻塞的方法，如InputStream.read()
     在持有锁的时候，不要对其他对象调用方法：消除死锁的源头
【第七章 其它线程API详细信息】
1.wait()、notify()和notifyAll()方法
     除了使用轮询，Object类还包括一些方法让线程相互通知事件的发生
     要执行这些方法，必须拥有相关对象的锁
     Wait()会让调用线程休眠，直到用Thread.interrupt()中断它、过了指定的时间、或者另一个线程用notify()或notifyAll()唤醒它
     当对某个对象调用notify()时，如果有任何线程正在通过wait()等待该对象，那么就会唤醒其中一个线程
     当对某个对象调用nofityAll()时，会唤醒所有正在等待该对象的线程
     与其使用wait()和notify()来编写您自己的调度程序、线程池、队列和锁，倒不如使用util.concurrent包，这是一个被广泛使用的开放源码工具箱，里面都是有用的并发性实用程序。JDK1.5将包括java.util.concurrent包；它的许多类都派生自util.concurrent
【第八章 结束语和参考资料】
1.结束语
     每个Java程序都使用线程，不论您知道与否。如果您正在使用Java UI工具箱(AWT或Swing)、Java Servlet、RMI、JavaServer Pages或Enterprise JavaBeans技术，您可能没有意识到您正在使用线程
</pre>
						</label>
					</label>
				</label>
				<label>《Java解惑》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-26 03:33:02
备注：看本书目的，了解Java底层一些原理
进度：1/162 （未看完）

所有的int数值中，有一半都是负数
double类型的值转换规则:表示成为最按近它的double值
Java不具有目标确定类型的特性，这是一种语言特性，其含义是指存储结果的变量的类型会影响到计算所使用的类型
符号扩展行为
	byte是一个有符号类型，char是一个无符号类型
	有符号的，那么就执行符号扩展；否则，都执行零扩展
Java的重载解析过程
	选取所有可用的方法或构造器
	选取最精确的一个
致命的Date/Calendar问题
	需要支持国际化时，它就暴露出了一个基本的设计缺陷：Date实例是易变的
	Calendar类引入后被用来矫正Date的缺点，遗憾的是，这么做只能使情况更糟
	BUG：
		Date将一月表示为0
		Date.getDay返回的是Date实例所表示的星期日期，而不是月份日期
	本谜题只是掀开了Calendar和Date缺陷的冰山一角。这些API简直就是雷区
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【Java谜题1——表达式谜题】
谜题1：奇数性
     i%2==1
     判断是否是一个奇数
     遗憾的是，它不能；它在四分之一的时间里返回的都是错误的答案
     因为在所有的int数值中，有一半都是负数
     解决：
          i%2!=0
     如在性能临界环境中使用，用位操作符AND(&)来替代取余操作会更好：
          (i&1)!=0
谜题2：找零时刻
     System.out.println(2.00-1.10);
     Double.toString文档中所设定的将double类型的值转换为字符串的规则，将double类型的值与最靠近它的临近值
     1.1这个数字不能被精确表示成为一个double ，因此它被表示成为最按近它的double值
     解决：
     使用执行精确小数运算的BigDecimal，一定要用BigDecimal(String)构造器
     System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10"));
     很有可能比那些使用原始类型的计算要慢一些
     总之，在需要精确答案的地方，要避免使用float和double；对于货币计算，要使用int、long或BigDecimal
谜题3：长整除
     final long a=24*60*60*1000*1000
     final long b=24*60*60*1000
     syso(a/b);
     long类型大到可以很容易保存这两个乘积而不产生溢出
     遗憾的是，打印的是5
     这个计算完全是以int运算来执行的，完成后结果被提升到long，但已溢出
     因为所有乘在一起的因子都是int数值
     Java不具有目标确定类型的特性，这是一种语言特性，其含义是指存储结果的变量的类型会影响到计算所使用的类型
     解决：
     使用long常量来替代int常量作为每一个乘积的第一个因子
     强制表达式中所有的后续计算都用long运作来完成
     final long a=24L*60*60*1000*1000
谜题4：初级问题
     syso(12345+5432l);
     事物往往有别于它的表象
     请注左操作数开头的数字1和右操作数结尾的小写字母l之间的细微差异
     数字1的水平笔划(称为"臂(arm)")和垂直笔划(称为"茎(stem)")之间是一个锐角，而与此相对照 的是，小写字母l的臂和茎之间是一个直角
     解决：
     避免使用单独的一个l字母作为变量名
     小写字母l和数字1在大多数打字机字体中都是几乎一样的
     Java从C编程语言中继承良多，包括long型字面常量的语法。也许当初允许用小写的l来编写long型字面常量本身就是一个错误
谜题6：多重转型
     syso((int)(char)(byte)-1);
     数值从32位窄化到8位，再拓宽到16位，再拓宽回32位，打印65535
     该程序的行为紧密依赖于转型的符号扩展行为。Java使用了基于2的补码的进制制运算
     int->byte：窄化原始类型转化，除低8位以外的所有位砍掉
     byte->char：byte是一个有符号类型，char是一个无符号类型，可以保持其数值但不可能将一个负的byte数值表示成一个char。因此从byte到char的转换被认为不是一个拓宽原始类型的转换，而是一个拓宽并窄化原始类型的转换；byte被转换成了int，又被转换成了char
     有一条很简单的规则能够描述从较窄的整型转换成较宽的整型时的符号扩展行为：如果最初的数值类型是有符号的，那么就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展
     byte->char：-1会发生符号扩展，作为结果的char数值的16个位就都被置位了
     char->int：执行零扩展
     解决：
     如果将一个char数值转型为一个宽度更宽的类型，不希望有符号扩展
          使用一个位掩码，即使不是必需的
          int i=c&0xffff;
     如果将一个char数值转型为一个宽度更宽的类型，希望有符号扩展
          先转short，宽度一样，但有符号
          int i=(short)c;//转型将引起符号扩展
     如果将一个byte数值转型为一个char不希望有符号扩展
          使用掩码来限制它，这是一种通用做法，不需要任何注释
          char c=(char)(b&0xff);
谜题7：互换内容
     int x=1984;//(0x7c0)
     int y=2001;//(0x7d1)
     x^=y^=x^=y;
     交换两个变量的最显而易见的方式是使用一个临时变量
     很久以前，当中央处理器只有少数寄存器时，可以用异或操作符来避免使用临时变量
     x=y^x;
     y=y^x;
     x=y^x;
     Java语言规范描述到：操作符的操作数是从左向右求值的。为求表达式的值，x的值是计算之前被提取的
     //Java中x^=y^=x^=y的实际行为
     int tmp1=x;//x在表达式中第一次出现
     int tmp2=y;//y的第一次出现
     int tmp3=x^y;//计算x^y
     x=tmp3;//最后一个赋值：存储x^y到x
     y=tmp2^tmp3;//第二个赋值：存储最初的x值到y中
     x=tmp1^y;//第一个赋值：存储0到x中
【Java谜题2——字符谜题】
【Java谜题3——循环谜题】
【Java谜题4——异常谜题】
【Java谜题5——类谜题】
谜题46：令人混淆的构造器案例
     public class Confusint{
          private Confusing(Object o){}
          private Confusing(double[] dArray){}
          main(){new Confusing(null);}
     }
     这个调用是模棱两可的，打印的是double array
     Java的重载解析过程是以两阶段运行的。第一阶段选取所有可获得并可应用的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一个。如果一个方法或构造器可以接受传递给另一个方法或构造器的任何参数，那么我们就说第一个方法比第二个方法缺乏精确性。
     Object可以接受double[]，因此相对缺乏精确性，因此，最精确的是double[]
     解决：
     如果用null参数来调用Object构造器：new Confusing((Object)null)，需要将实际的参数转型为形式参数所声明的类型
【Java谜题6——库谜题】
谜题61：日期游戏
     Calendar cal=Calendar.getInstance();
     cal.set(1999,12,31);//Year,Month,Day
     syso(cal.get(Calendar.YEAR)+"");
     Date d=cal.getTime();
     syso(d.getDay));
     上面的程序演练了Date和Calendar类的某些基本特性
     打印结果：2000和1
     这是致命的Date/Calendar问题。在Java平台首次发布时，它唯一支持日历计算类的就是Date类。这个类在能力方面是受限的，特别是当需要支持国际化时，它就暴露出了一个基本的设计缺陷：Date实例是易变的。在1.1版中，Calendar类被添加到了Java平台中，以矫正Date的缺点，由此大部分的Date方法就都被弃用了。遗憾的是，这么做只能使情况更糟
     第一个bug：当月份以数字来表示习惯上将第一个月赋值为1，遗憾的是，Date将一月表示为0，Calendar延续了这个错误。应该抛出一个IllegalArgumentException异常，但没有。Calendar类直接将其替换为下一年
     解决：
     将12改为11；使用Calendar专为此目的而定义的常量，即Calendar.DECEMBER
     第二个bug：为找出原因，必须先阅读一下文档，Date.getDay返回的是Date实例所表示的星期日期，而不是月份日期。这个返回值是基于0的，从星期天开始计算。请注意，相应的Calendar方法get(Calendar.DAY_OF_WEEK)不知为什么返回的是基于1的星期日期值，
     解决：
     调用Date.date，返回的是月份日期；调用Calendar的get(Calendar.DAY_OF_MONTH)方法
     本谜题只是掀开了Calendar和Date缺陷的冰山一角。这些API简直就是雷区。Calendar其他的严重问题包括弱类型(几乎每样事物都是一个int)、过于复杂的状态空间、拙劣的结构、不一致的命名以及不一致的雨衣等。在使用Calendar和Date的时候一定要当心，千万要记着查阅API文档
【Java谜题7——更多的类谜题】
【名字重用的术语表】
覆写(override)
隐藏(hide)
重载(overload)
遮蔽(shadow)
遮掩(obscure)
【Java谜题8——更多的库谜题】
【Java谜题9——高级谜题】
</pre>
						</label>
					</label>
				</label>
				<label>《JAVA开发利器MyEclipse全面详解》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-26 03:38:51
备注：看本书目的，了解使用技巧，提高开发效率，也正视一下使用了好几年的工具
进度：488/488

修改代码错误的快捷键是Ctrl+1
选择被包围的代码。快捷 为Alt+Shift+Z
Derby数据库是一款纯Java语言开发的开源免费数据库，也称为Java DB
在配置外部数据库时，MyEclipse中能够管理很多种数据库。同样可以管理很多应用服务器，例如常用的Tomcat、Jboss、WebLogic和WebSphere等
MyEclipse的保存机制
     在编辑区中，单击鼠标右键，在弹出的菜单中选择"Compare With"|"Local History"命令，将弹出文件历史视图界面
     在编辑区中，单击鼠标右键，在弹出的菜单中选择"Replace With"|"Local History"命令，将弹出替换界面，在其中双击要替换的历史记录
UML
     UML的中文名称叫统一建模语言，它是一种对软件密集系统进行可视化建模的编程语言
     如果仅仅是通过UML图来表示程序的结构或者程序之间的关系，那UML也不会这么重要
     UML强大之处在于它能够和Java程序进行相互转换，也就是绘制完UML类图后，能够自动生成Java程序
     从UML类图到Java程序被称为正向工程，从Java程序到UML类图被称为反向工程
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第一章 开发环境搭建】
【第二章 常用开发操作和技巧】
2.2.5 修正代码错误
     记忆：修改代码错误的快捷键是Ctrl+1，但是一定要首先将鼠标放在出现错误的一行才可以
2.3 包围方式
     记忆：在进行包围操作时，一定首先选择被包围的代码。快捷 为Alt+Shift+Z
【第三章 重构】
【第四章 管理数据库】
4.1 认识MyEclipse中自带的数据库
     Derby数据库是一款纯Java语言开发的开源免费数据库，也称为Java DB
【第五章 管理服务器并进行Web开发】
5.1 认识MyEclipse中的服务器
     这里所说的服务器是指用于Java Web项目部署的应用服务器
     在配置外部数据库时，MyEclipse中能够管理很多种数据库。同样可以管理很多应用服务器，例如常用的Tomcat、Jboss、WebLogic和WebSphere等
     注意：在MyEclipse中自带了一个Tomcat服务器
【第六章 进行Struts开发】
【第七章 进行Hibernate开发】
【第八章 进行Spring开发】
【第九章 SSH框架整合开发】
【第十章 进行Struts2开发】
【第十一章 SSH2框架整合开发】
【第十二章 调试和测试】
【第十三章 CVS和SVN版本控制】
     版本管理是一种功能，在MyEclipse中本身集成了标准的版本管理系统CVS
     SVN也是最近流行起来的版本管理工具，它包含CVS的所有功能，并且修复了CVS的一些缺陷
13.1 本地版本控制
13.1.1 比较
     MyEclipse的保存机制
     开发程序时，每保存一次都会在其中保存一个历史文件副本。本地的版本管理就是对这些历史副本进行操作
     在编辑区中，单击鼠标右键，在弹出的菜单中选择"Compare With"|"Local History"命令，将弹出文件历史视图界面
     在编辑区中，单击鼠标右键，在弹出的菜单中选择"Replace With"|"Local History"命令，将弹出替换界面，在其中双击要替换的历史记录
     技巧：在实际开发中，使用最多的就是替换成上一次的历史记录。在编辑区中，单击鼠标右键，在弹出的菜单中选择"Replace With"|Previous from Local History"命令，并不会弹出任何界面，而是直接替换成上一次保存时的历史记录。使用该操作，要比使用"Ctrl+Z"撤销更快捷
13.3 SVN版本控制
13.3.1 下载和安装SVN服务器
     SVN可以说是CVS的"接班人"，比XVS更强大的版本控制工具，需要安装相应的插件
     SVN的服务器端的官方网站为"http://subversion.tigris.org"，下载链接为"http://subversion.tigris.org/project_packages.html"
13.3.2 安装SVN插件
     菜单中，先择"Help"|"Software update"|"Add/Remove Software"命令，单击"Add Site"按钮，SVN插件的安装URL为"http://subclipse.tigris.org/update_1.6.x"，选择SVN下的三个选项
【第十四章 UML建模】
     UML的中文名称叫统一建模语言，它是一种对软件密集系统进行可视化建模的编程语言。开源的UML开发工具比较少，最有名的是ArgoUML，MyEclipse中集成的UML建模工具就是基于ArgoUML工具开发的
14.2 用例图
     开发完UML模型仓库后，也就是创建模型仓库文件后，就可以在该文件中创建UML模型图形
     UML中的模型图形有很多种，包括用例图、类图、状态图、时序图等
     用例图是在系统分析阶段经常要绘制的UML图
     在用例图中可以包含6个元素，分别是参与者、用例、关联关系、包含关系、扩展关系和泛化关系，不必须全部包含六种元素
14.3 类图
     类图是用来描述相关的信息，例如类中的变量和方法、类与类之间的关系，通过它可以显示类的静态结构
     类图中包含多种元素，分别是类、接口、协作、依赖关系、泛化关系和关联关系等
     注意：在不同的UML图中经常会出现相同的元素名称，需要注意的是它们表示的含义是完全不同的，一定要注意区分
     依赖关系是指类模型之间语义上的关系，包含四种依赖类型：使用依赖、抽象依赖、授权依赖和绑定依赖
14.4 UML和Java程序之间的转换
     如果仅仅是通过UML图来表示程序的结构或者程序之间的关系，那UML也不会这么重要
     UML强大之处在于它能够和Java程序进行相互转换，也就是绘制完UML类图后，能够自动生成Java程序
     从UML类图到Java程序被称为正向工程，从Java程序到UML类图被称为反向工程
     通过UML模型能够很清楚的看到程序之间的关系，这在大型项目中是非常重要的
     技巧：如果仅仅对数量有限的程序生成，可直接将程序拖动到UML模型仓库画布中，将执行弹出设置UML类图的界面
14.5 状态图
     状态图是一种系统分析时经常用到的UML图，通过它可以跟踪某一对象变化的动态行为。例如网上商店中的订单对象
14.6 活动图
     活动图是UML技术中的一个概念，它和开发中经常说的程图是非常类似的
     活动图是指活动间的控制流，是内部处理驱动的流程
     状态图是指某一对象不同状态间的控制流，主要是由于外部事件驱动的流程
14.7 时序图
     有些地方也称为序列图，是一种以时间为序来描述对象之间传递消息
     在开发中，通过时序图能够很好的描述程序的执行，在框架开发中尤其重要
     时序图包含4个元素，分别是对象、生命线、消息和激活
【第十五章 团队开发新闻发布系统】
</pre>
						</label>
					</label>
				</label>
				<label>《JVM、GC详解及调优》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-12-6 23:27:13
备注：看本书目的，了解JVM，有些好奇
进度：29/29

Java是一门技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)
Java的运行原理
平台无关性
JVM的体系结构
	类装载子系统
	执行引擎子系统，也叫做解释器
	本地接口组件，融合不同的编程语言为Java所用，初衷是融合C/C++程序
	运行数据域组件，是整个JVM的重点，Java生态系统如此繁荣，得益于该区域的优良自治
		Java Stack(栈)
			线程创建时创建，生命期跟随线程的生命期，线程结束栈内存释放，不存在垃圾回收问题
			主要保存3类数据：本地变量(Local Variables)、栈操作(Operand Stack)、栈帧数据(Frame Data)
		Java Heap(堆)
			一个JVM实例只存在一个堆内存
			类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中
		Method Area(方法区)
			所有线程共享，保存所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义
		PC Register(程序计数器)
			每个线程都有一个计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令
		Native Method Stack(本地方法栈)
			与VM栈作用类似，只为虚拟机使用到的Native方法服务
垃圾收集算法
	引用计数算法(Reference Counting)
	根追踪算法(GC Roots Tracing)
	标记-清除算法(Mark-Sweep)
	"复制"(Copying)收集算法
	"分代收集"(Generational Collecting)算法
分代垃圾回收详述
	JVM中划分为三个代：年轻代(Young Generation)、年老代(Old Generation)和持久代(Permanent Generation)
	年老代：在年轻代中经历了N次垃圾回收后仍存活的对象会放在这里
	持久代：存放静态文件，如Java类、方法等
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
JVM(Java Virtual Machine)——Java虚拟机
【2.Java技术】
2.1 Java定义
     一种简单、面向对象、分布式、跨平台、半编译半解释、健壮、安全、高性能、多线程的动态的语言——Sun定义
     Java是一门技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如图：
2.3 Java的运行原理
     编写Java代码(.java文件)
     编译成字节码(.class文件)
     字节码被装入内存，一旦字节码进入虚拟机中，它就会被解释器解释执行，或者是被即时编译器有选择的转换成机器码执行
2.4 半编译半解释
     系统先将用户输入的指令翻译成一种通用的，比较规则的中间形式的代码，保密性强 ，运行时则由所在机器的解释器进行解释
     Java语言的开发效率高，但执行效率低(相当于C++的55%)
2.5 平台无关性
     何谓平台：即一套特定的硬件再加上运行其上的操作系统，即硬件+软件
     实现过程：
          (1)不同平台的内存管理模式和CPU的指令集等都有很大的差别
          (2)为了平台无关，Sun公司在不同平台用软件模拟出虚拟目标机，虚拟出CPU指令集和内存
          (3)虚拟出来的JVM是完全一样的
          (4)Java的字节码仅仅运行在JVM上，不和平台底层直接打交道
          (5)JVM根据平台的不同，把字节码解释成不同的本地代码
          (6)JVM就像翻译，把通用的普通话翻译成不同地方特色的方言
     缺点：Java代码必须要经过JVM解释才能运行，使运行效率降低
     WORA：Write Once,Run Anywhere.(一次编写，到处运行)
【3.  JVM的体系结构】
          Class Loader(Class Files)
          Runtime Data Area(Stack、Heap、Method Area、PC Register、Native Method Stack)
          Execution Engine
          Native Interface(Native Libraies)
     JVM体系结构主要包括两个子系统和两个组件：
          类装载子系统
          执行引擎子系统
          运行数据域组件
          本地接口组件
3.1 类装载子系统
     根据给定的全限定名类名来装载.class文件的内容到Runtime data area中的method area(方法区域)。程序员可以extends java.lang.ClassLoader类来写自己的Class loader
3.2执行引擎子系统
     也叫做解释器(Interpreter)，负责解释命令，提交操作系统执行
3.3 本地接口组件
     作用：融合不同的编程语言为Java所用，初衷是融合C/C++程序，在内存中专门开辟了一块区域处理标记为native的代码
     具体做法：Native Method Stack中登记native方法，在Execution Engine执行时加载native libraries
     目前使用越来越少，除非是与硬件有关的应用，比如Java程序驱动打印机，或Java系统管理生产设备，因为现在异构领域间的通信很发达，比如Socket通信、Web Service等
3.4 运行数据域组件
     是整个JVM的重点
     Java生态系统如此繁荣，得益于该区域的优良自治
     所有的数据和程序都是在运行数据区存放
3.4.1 Java Stack(栈)
     栈也叫栈内存，是Java程序的运行区
     线程创建时创建，生命期跟随线程的生命期，线程结束栈内存释放，不存在垃圾回收问题
问题：栈中存的是哪些数据呢？又是什么格式呢？
     格式：栈中数据都以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集
     过程：方法被调用时产生一个栈帧，压入栈中，执行完毕，弹出栈帧，遵循"先进后出"原则
     数据：主要保存3类数据
          本地变量(Local Variables)，包括输入参数和输出参数以及方法内的变量
          栈操作(Operand Stack)，记录出栈、入栈的操作
          栈帧数据(Frame Data)，包括类文件、方法等等
3.4.2 Java Heap(堆)
     一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的
     类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中
     堆内存分为三部分：
          Permanent Space 永久存储区
               是一个常驻内存区域，存放JDK自身的Class，Interface的元数据，即存储运行环境必须的类信息，此区域不会被垃圾回收器回收掉，关闭JVM会释放此区域所占内存
          Young Generation Space 新生区
               是类的诞生、成长、消亡的区域
               分为两部分：
                    伊甸区(Eden Space)
                    幸存者区(Survivor Space)
          Tenure Generation Space 养老区
               保存从新生区筛选出来的Java对象，一般池对象在这个区域活跃
3.4.3 Method Area(方法区)
     被所有线程共享，保存所有字段和方法字节码，以及一些特殊方法如构造函数，接口代码也在此定义
3.4.4 PC Register(程序计数器)
     每个线程都有一个计数器，就是一个指针，指向方法区中的方法字节码，由执行引擎读取下一条指令
3.4.5 Native Method Stack(本地方法栈)
     与VM栈作用类似，只为虚拟机使用到的Native方法服务
     和VM栈一样，也会抛出StackOverflowError和OutOfMemoryError异常
【4.  JVM相关问题】
4.1问：堆和栈区别？
     堆存放对象，栈存对象内的临时变量
     栈跟随线程，有线程就有栈，堆跟随JVM，有JVM就有堆内存
     总体来说：栈主要存放引用和基本数据类型；堆存放new出来的对象实例
4.2问：堆内存中到底存放什么？
     对象，包括对象变量以及对象方法
4.3问：类变量和实例变量区别？
     静态变量是类变量，存在方法区，非静态变量是实例变量，存在堆内存
4.4问：Java的方法(函数)到底是传值还是传址？
     都不是，是以传值的方式传递地址
     具体的说：原生数据类型传递的值，引用类型传递的地址
4.7问：为什么会产生StackOverflowError？
     因为一个线程把Stack内存全部耗尽了，一般是递归函数造成的
4.11问：JVM中到底哪些区域是共享的？哪些是私有的？
     Heap和Method Area是共享的，其他都是私有的
4.12问：什么是JIT？
     Just In Time，Java诞生时是一个解释语言，先编译再翻译，有效率问题。Sun提出一套新的机制，把字节码编译成原生代码
4.13问：为什么不建议在程序中显式声明System.gc()？
     该方法是做堆内存全扫描，Full GC，需停止所有的活动，会影响应用
【5. 深入Java内存区域与OOM】
     对于Java程序员，正因为把内存控制权力交给了JVM，一旦出现泄漏和溢出，如果不了解JVM是怎样使用内存的，那排查错误将非常困难
5.2 JVM运行时的数据区域(参照3.4)
     补充两点
5.2.1 运行时常量池(Runtime Constant Pool)
     Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量表，用于存放编译期已可知的常量，这部分内容在类加载后进入方法区(永久代)存放。不要求一定只有编译期预置入Class的常量表的肉容进入方法区常量池，运行期间也可将新内容放入常量池
【6. 深入垃圾收集器和内存分配策略】
     程序计数器、VM栈、本地方法栈三个区域随线程而生，随线程而灭，内存分配和回收具备很高的确定性，不需要过多考虑回收问题
     而Java堆和方法区(包括运行时常量池)，等到程序实际运行期间才知道创建哪些对象，内存分配和回收是动态的
6.2 垃圾收集算法
6.1 概述
     Java内存运行时区域，其中程序计数器、VM栈、本地方法栈三个区域随线程而生，随线程而灭
6.2.1 引用计数算法(Reference Counting)
     给对象中添加一个引用计数器，当有一个地方引用它，计数器加1，当引用失效，计数器减1，计数器为0的对象不可能再被使用
     简单，效率高
     但无法解决对象循环引用的问题
6.2.2 根追踪算法(GC Roots Tracing)
     Java、C#、Lisp基本思路通过一系列的称为"GC Roots"的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链相连，则对象不可用
     Java语言中，GC Roots包括：
          在VM栈(帧中的本地变量)中的引用 stack
          方法区中的静态引用 static field
          JNI(即一般说的Native方法)中的引用 local var
     判定一个对象死亡，至少经历两次标记过程：进行根搜索后，没有与GC Roots相连接的引用链，被第一次标记，稍后执行他的finalize()方法(如果它有的话)，这是最后一次逃脱死亡的机会，稍后GC进行第二次规模稍小的标记，如果在finalize()中对象拯救自己(重新建立到GC Roots的连接)，第二次标记将被移除出"即将回收"的集合，如果没逃脱，基本离死不远了
6.2.3 标记-清除算法(Mark-Sweep)
     先标记，再回收
     两个缺点：
          效率问题，两个过程效率都不高
          空间问题，清理后会产生大量不连的内存碎片
6.2.4 "复制"(Copying)收集算法
     将可用内存分两块，半区内存用完，将存活对象复制到另一块上，把原来的清理掉
     代价是将内存缩小为原来的一半
6.2.5 "分代收集"(Generational Collecting)算法
     根据不同存活周期将内存划分
6.3 垃圾收集器
【7.JVM调优总结】
7.1.1 数据类型
     Java虚拟机中，数据类型分两类：
          基本类型
          引用类型
     基本类型的变量保存原始值，代表数值本身
     引用类型的变量保存引用值 ，代表某个对象的引用，不是对象本身，对象本身存放在这个"引用值"所表示的地址的位置
     基本类型：
          byte,short,int,long,char,float,double,Boolean,returnAddress
     引用类型：
          类类型、接口类型和数组
7.1.2 堆与栈
     栈是运行时的单位，而堆是存储的单位
          栈解决程序的运行问题，即程序如何执行，或者说如何处理数据
          堆解决数据存储问题，即数据怎么放、放在哪儿
     堆和栈为什么分开？栈不是也可存储数据吗？
          一、栈代表处理逻辑，堆代表数据，使得处理逻辑更清晰，分而治之
          二、堆中内容共享，堆中共享常量和缓存可被所有栈访问，节省空间
          三、栈因运行时的需要，只能向上增长，因此会限制存储能力。而堆不同，可以根据需要动态增长，拆分使得动态增长成为可能，栈只记录堆中一个地址即可
          四、面向对象是堆和栈的完美结合。对象的属性其实就是数据，存放在堆中；对象的行为(方法)就是运行逻辑，存放在栈中
7.1.3 Java对象的大小
     基本数据类型大小固定
     在Java中，一个空Object对象的大小是堆中对象信息占8byte，栈中引用占4byte
     基本类型的包装类型是已经是对象了，至少12byte，Java对象大小是8的整数倍，因此至少是16byte
7.1.4 引用类型
     强引用：一般声明对象时的引用，不会被垃圾回收
     软引用：一般被做缓存来使用，JVM根据当前系统剩余内存来决定是否回收。换句话说，JVM在发生OutOfMemory时，肯定是没有软引用存在的
     弱引用：作为缓存来使用，垃圾回收一定会被回收，生命周期只存在于一个垃圾回收周期内
7.4 分代垃圾回收详述
7.4.2 如何分代
     JVM中划分为三个代：年轻代(Young Generation)、年老代(Old Generation)和持久代(Permanent Generation)
     年老代：在年轻代中经历了N次垃圾回收后仍存活的对象会放在这里
     持久代：存放静态文件，如Java类、方法等
7.5 典型配置和调优举例
7.5.1 堆设置
     -Xms：初始堆大小
     -Xmx：最大堆大小
     -XX:NewSize=n：设置年轻代大小
     -XX:NewRatio=n：设置年轻代和年老代的比值。如3表示1:3，年轻代占整个年轻代年老代和的1/4
     -XX:SurvivorRatio=n：年轻代中Eden区与两个Survivor区的比值。如3表示Eden:Survivor=3:2，一个Survivor区占整个年轻代的1/5
     -XX:MaxPermSize=n：设置持久代大小
</pre>
						</label>
					</label>
				</label>
				<label>《深入Java虚拟机(原书第2版)》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-29 1:09:38
备注：看本书的目的，了解Java技术的底层，看看学了三年多的Java到底是什么
进度：400+/482
适用水平：中、高级(说实话，这本书没看懂 T_T)

启动类装载器
双亲委派机制
Java class文件是什么
	Java class文件是对Java程序二进制文件格式的精确定义
类装载器与双亲委派模型
垃圾收集
	引用计数收集器
	跟踪收集器
	压缩收集器
	拷贝收集器
	按代收集的收集器
	自适应收集器
	火车算法
二进制补码运算
线程同步
	支持多线程是Java语言的一大优势，这种支持主要集中在同步上，或调节多个线程的活动和共享数据
	Java所使用的同步机制是监视器
	Java中的监视器支持两种线程：互斥、协作
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第1章 Java体系对构介绍】
     Java技术的核心就是Java虚拟机——所有的Java程序都在其上运行
1.3.1 Hava虚拟机
     Java的面向网络的核心就是Java虚拟机，它支持Java面向网络体系结构三大支柱的所有方面：平台无关性、安全性和网络移动性
     Java虚拟机的主要任务是装载class文件并且执行其中的字节码
1.3.3 Java class文件
     通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作。而Java class文件是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的二进制文件(因为二进制文件包含了目标处理器的机器语言，而Java编译器把Java源文件的指令翻译成字节码、即Java虚拟机的"机器语言")
【第2章 平台无关】

【第3章 安全】
3.3 类装载器体系结构
     启动类装载器：
          原始类装载器的内置的类装载器被重新命名为启动类装载器，表示它现在只负责装载那些核心Java API的class文件，因为核心Java API的class文件是用于"启动"Java虚拟机的class文件，所以，启动类装载器的名字也因此而得
     双亲委派机制：
          从版本1.2开始，除启动类装载器以外的每一个类装载器，都有一个"双新"类装载器，在某个特定的类装载器试图以常用方式装载类型以前，它会先默认地将这个任务"委派"给它的双亲——请求它的双亲来装载这个类型。这个双亲再依次请求它自己的双新来装载这个类型。这个委派的过程一直向上继续，直到达到启动类装载器，通常启动类装载器是委派链中的最后一个类装载器，如果一个类装载器的双亲类装载器有能力来装载这个类型，则这个类装载器返回这个类型，否则，这个类装载器试图自己来装载这个类型
3.4 class文件检验器
     class文件实质上是一个字节序列、一个线性二进制数据流(class到底是啥 T_T)
     class文件检验器进行四趟独立的扫描来完成操作：
          第一趟，类被装载时进行，检查文件内部结构，保证被安全编译
               每个class文件必须以四个同样的字节开始，0xCAFEBABE开头，其中声明的长度是否和内容一致，声明的主版本号和次版本号是否在Java虚拟机支持范围内
          第二、三趟，连接过程中进行，确认类型数据遵从Java编程语言的语义，包含所有字节码的完整性
               第二趟，类型数据的语义检查
               第三趟，字节码验证
          第四趟，进行动态连接的过程中解析符号引用时进行，确认被引用的类、字段以及方法确实存在
               第四趟扫描验证失败，Java虚拟机抛出一个NoSuchMethodError
               如果引用其他一些包，运行时通过网络下载一些类，就不可能在编译时检验兼容性，这就是第四趟扫描时，必须在运行时检查兼容性的原因
3.5 Java虚拟机中内置的安全特性
     Java虚拟机保证安全的最后一个机制，就是异常的结构化错误处理
     Java虚拟机支持异常，会做一些结构化处理，将抛出一个异常或一个错误，而不是崩溃，导致这个错误线程的死亡，而不是使整个系统陷入瘫痪，使程序能够将控制从发生异常的地方转到处理这个异常的情况
3.7 代码签名和认证
     数字签名过程的第一步是一个单向的散列计算
     单向散列算法是从大量数据(输入)中产生少量数据(消息摘要或者散列)
     之所以被称为"单向"，是因为在只给出散列的情况下，这个散列值不能包含足够的输入的信息，因此不能从散列重新生成原输入。这个计算是单向的，从大到小，从输入到散列
     散列也被称为消息文摘
3.12 Java安全模型的不足和今后的发展方向
     Java的安全模型虽然影响深远，但是并没有解决由移动代码所引起的所有潜在的威胁
     例如，目前Java的安全模型还不能解决恶意移动代码的两个可能的活动：
          不断分配内存直到内存耗尽
          不断生成线程导致每件事都慢得不可忍受
     这种类型的攻击被称为拒绝服务(DOS)
     另一个领域是将权限映射到系统用户，例如UNIX操作系统，基于用户ID对文件访问控制，只能通过一个正确的登录名和密码来获得
【第4章 网络移动性】
     Java处理网络计算环境下软件开发人员所面临的两大挑战：
          平台无关性——不同计算机和设备
          安全模式——网络可以方便地传输病毒和其他青菜式的恶意代码
     此处不说Java如何处理挑战，而是如何把握网络所带来的巨大机遇
     个人计算机互联成网，233
     分布式处理模式，不可忽视的缺点，更难管理，比如升级
【第5章 Java虚拟机】
5.3 Java虚拟机的体系结构
     每个Java虚拟机实例都有一个方法区以及一个堆，类型信息放到方法区，，程序运行时创建的对象放到堆中
     方法区补充：类型中的类(静态)变量同样在方法区中，所有线程都共享方法区。大小不必是固定的
     当每一个新线程被创建时，有自己的PC寄存器(程序计数器)和一个Java栈，PC寄存器总是指向下一条将被执行的指令，栈总是存储该线程中Java方法调用的状态(局部变量，参数，返回值以及运算中间结果等)
     Java栈是由许多栈帧或者说帧组成，一个栈帧包含一个Java方法调用的状态
     当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中；当该方法返回时，这个栈帧被从Java栈中弹出并抛弃
5.3.1 数据类型
基本类型：
     Java语言中的所在基本类型同样是Java虚拟机中的基本类型
     boolean编译器用int或byte表示，false由整数零表示，非零整数表示true，涉及boolean的操作用int，boolean数组是当做byte数组来访问
     一个long在任何虚拟机中总是一个64位二进制补码表示的有符号整数
     returnAddress，程序员不能使用，用来实现Java程序中的finally子句
引用类型：
     类类型的值是对类实例的引用
     数组类型的值是对数组对象的引用
     接口类型的值是对实现了该接口的某个类实例的引用
     特殊的引用值null，表示该引用变量没有引用任何对象
5.3.3 类装载器子系统
     负责查找并装载类型的部分被称为类装载器子系统
5.3.4 方法区
     类型信息 对每个装载的类型，虚拟机都会在方法区中存储以下类型信息：
          这个类型的全限定名
          这个类型的直接超类的全限定名(除非是java.lang.Object，没有超类)
          这个类型是类类型还是接口类型
          这个类型的访问修饰符(public、abstract或final的某个子集)
          任何直接超接口的全限定名的有序列表
     全限定名，在class文件里，所有的"."都被斜杠"/"代替
     除了上面的基本类型信息外，虚拟机还得为每个被装载的类型存储以下信息：
          该类型的常量池
          字段信息
          方法信息
          除了常量以外的所有类(静态)变量
          一个到类ClassLoader的引用
          一个到Class类的引用
     字段信息的清单：
          字段名
          字段的类型
          字段的修饰符(public、private、protected、static、final、volatile、transient的某个子集)
     方法信息的清单：
          方法名
          方法的返回类型(或void)
          方法参数的数量和类型(按声明顺序)
          方法的修饰符(public、private、protected、static、final、synchronized、native、abstract的某个子集)
     类(静态)变量
          类变量是由所有类实例共享，即使没有任何类实例，也可以被访问
          这些变量只与类有关——而非类的实例，因此它们总是作为类型信息的一部分而存储在方法区
     在Java程序中，得到并使用指向Class对象的引用
          Class类中的一个静态方法，Class.forName("java.lang.Object")
          调用任何对象引用的getClass()方法
     Class类使得运行程序可以访问方法区中保存的信息，其中的方法：
          public String getName();
               返回类型的全限定名
          public Class getSuperClass();
          public boolean isInterface();
               判断该类型是否是接口，返回true、false
          public Class[] getInterfaces();
          public ClassLoader getClassLoader();
               返回装载该类型的ClassLoader对象的引用，由启动类装载器装载返回null
5.3.5 堆
     Java程序在运行时创建的所有类实例或数组都放在同一个堆中
     一个Java虚拟机实例中只存在一个堆空间，因此所有线程都共享这个堆
     一个Java程序独占一个Java虚拟机实例，因而每个Java程序有自己的堆空间，不会彼此干扰
     同一个Java程序的多个线程共享着同一个堆空间，需考虑多线程访问对象(堆数据)的同步问题了
垃圾收集
     主要工作是自动回收不再被运行的程序引用的对象所占用的内存。此外，也可能去移动那些还在使用的对象，以此减少堆碎片
     和方法区一样，堆空间也不必是连续的内存区
5.3.9 本地方法栈
     当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界
     本地方法可以通过本地方法接口来访问虚拟机的运行数据区。可以直接使用寄存器或堆中分配内存等，总之，它和虚拟机拥有同样的权限(或者说能力)
【第6章 Java class文件】
6.1 Java class文件是什么
     Java class文件是对Java程序二进制文件格式的精确定义
     Java语言中的程序也可以用编译器编译成其他二进制文件格式
     Java class文件是8位字节的二进制流
     相邻项之间无间隔，文件紧凑；占据多个字节空间的项按照高位在前的顺序分为几个连续的字节存放
     在class文件中，可变长度项的大小和长度位于其实际数据之前。这个特性使得class文件流可以从头到尾被顺序解析，首先读出项的大小，然后读出项的数据
【第7章 类型的生命周期】
7.1 类型装载、连接与初始化
7.2 对象的生命周期
7.2.1 类实例化
     实例化一个类有四种途径：
          明确地使用new操作符
          调用Class或者java.lang.reflct.Constructor对象的newInstance()方法
          调用任何现在对象的clone()方法
          通过java.io.ObjectInputStream类的getObject()方法反序列化
     除了明确地实例化，还有几种情况下对象会被隐含地实例化：
          new、newInstance()、clone()或者ObjectInputStream.readObject()
7.3 卸载类型
     使用启动类装载器装哉的类型永远是可触及的，永远不会被卸载
     判断动态装载的类型的Class实例在正常的垃圾收集过程中是否可以触及有两种方式：
          程序保持对Class实例的明确引用
          如果在堆中还存在一个可触及的对象，在方法区中它的类型数据指向一个Class实例
【第8章 连接模型】
8.1.2 类装载器与双亲委派模型
     1.2版本中引入了类装载器的形式化双亲委派模型
     如果一个用户自定义的类装载器产生委派，它委派的往往是在双亲委派模型中的双亲。双亲再委派给它的双亲，以此类推。委派的过程一直进行到委派的末端，有一个类装载器不再委派，而是决定装载这个类型。大多数情况下，末端的类装载器就是启动类装载器
     如果一个双亲类装载器试图装载这个类型但是却失败了，控制权重新回到子装载器，在双亲委派模型中，子装载器在得知它的双亲(包括祖父，曾祖父……)无法装载此类型时，它会试图自行装载。如果委派链中的某个类装载器第一个成功地装载了类型，那么这个类装载器就会被标记为定义类装载器。这个类装载器以及所有在委派链中排在它前面的类装载器会被标记为初始类装载器。然而，它的双亲、祖父、曾祖父，以及更上一代，他们没有一个成功装载了这个类型，所以不会被标记为类型的初始类装载器
     因为某个类装载器负责装载标准扩展，而指定包正确地以JAR文件格式安装到了标准扩展目录，这个类装载器就能够装载这个类型
P205
【第9章 垃圾收集】
     在Java虚拟机的堆里存放着正在运行的Java程序所创建的所有对象
     垃圾收集就是自动释放不再被程序所使用的对象的过程
9.1 为什么要使用垃圾收集
     优点：
          把用户从释放占用内存的重担中解救出来
          能帮助程序保持完整性
     缺陷：
          加大了程序负担，可能影响程序性能
9.3 引用计数收集器
     堆中每个对象都有一个引用计数
     好处：
          快速执行，交织在程序的运行之中
          这个特性对于程序不能被长时间打断的实时环境很有利
     坏处：
          引用计数无法检测出循环(即两个或者更多的对象互相引用)
          每次引用计数的增加或者减少都带来额外开销
9.4 跟踪收集器
     追踪从根节点开始的对象引用图，遇到的对象打标让
     基本的追踪算法被称作"标记并清除"
     收集过程两个阶段：
          标记阶段，垃圾收集器遍历引用树，标记每一个遇到的对象
          清除阶段，未被标记的对象被释放，对象终结
9.5 压缩收集器
     标记并清除收集器通常使用两种策略：
          压缩和拷贝
     这两种方法都是快速地移动对象来减少堆碎片
     压缩收集器把活动的对象越过空闲区滑动到堆的一端，在这个过程中，堆的另一端出现一个大的连续空闲区。所有被移动的对象的引用也被更新，指向新的位置
     优点：简化了消除堆碎片的工作
     缺点：每一次对象访问都带来了性能损失
9.6 拷贝收集器
     拷贝垃圾收集器把所有的活动对象移动到一个新的区域
     拷贝过程中，它们被紧挨着布置，所以可消除原本它们在旧区域的空隙
     原有区域被认为都是空闲区
     过程：
          一般的拷贝收集器算法被称为"停止并拷贝"，堆被分为两个区域，任何时候都只使用其中的一个区域。对象在同一个区域中分配，直到这个区域被耗尽，此时程序执行被中止，堆被遍历，遍历时遇到的活动对象被拷贝到另外一个区域，当停止和拷贝过程结束时，程序恢复执行
     好处：对象可以在从根对象开始的遍历过程中随着发现而被拷贝，不再有标记和清除之分
     坏处：对于指定大小的堆来说需要两倍大小的内存，因为任何时候都只能使用其中的一半
          
9.7 按代收集的收集器
     简单的停止并拷贝收集器的缺点是，每一次收集时，所有的活动对象都必须被拷贝。但是：
          大多数程序创建的大部分对象都具有很短的生命期
          大多数程序都创建一些具有非常长生命周期的对象
     浪费效率，每次都把生命周期很长的对象来回拷贝，消耗大量的时间
     按照寿命来分组
     每当对象在它所属的年龄层(代)中变得成熟(逃过了多次垃圾收集)之后，它们就被转移到更高的年龄层中去
     优点：可应用于拷贝算法或标记并清除算法，可以提高最基本的垃圾收集算法的性能
9.8 自适应收集器
     自适应算法监视堆中的情形，并且对应地调整为合适的垃圾收集技术
     在程序调整的时候可能会调整某种简单的垃圾收集算法的参数
9.9 火车算法
     如果一种垃圾收集算法可能导致用户可察觉得到的停顿或者使得程序无法适合实时系统的要求这种算法被称作破坏性的
     渐进式垃圾收集器就是不试图一次性发现并回收所有不可触及的对象，而是每次发现并回收一部分
     除了最高寿的那个年龄层(成熟对象空间)之外，每一个子堆中都可以给定一个最大尺寸，成熟对象空间无法给定最大尺寸，因为，它们没有其他地方可去
9.11 对象可触及性的生命周期
     在垃圾收集器看来，堆中的每一个对象都有三种状态之一：
          可触及的，可复活的，以及不可触及的
【第10章 栈和局部变量操作】
P280
【第11章 类型转换】
P290
【第12章 整数运算】
12.1 二进制补码运算
     Java虚拟机所支持的所有的整数类型——byte、short、int和long，都是带符号的二进制补码数
     二进制补码方案既能够描述正整数，也能够描述负整数
     二进制补码数中，最重要的位就是符号位，1表示负整数，0表示正整数和数字0
【第13章 逻辑运算】
P304
【第14章 浮点运算】
P308
【第15章 对象和数组】
P318
【第16章 控制流】
P326
【第17章 异常】
P334
【第18章 finally子句】
P342
【第19章 方法的调用与返回】
P350
【第20章 线程同步】
P363
     可以在语言级支持多线程是Java语言的一大优势，这种支持主要集中在同步上，或调节多个线程的活动和共享数据
     Java所使用的同步机制是监视器
20.1 监视器
     Java中的监视器支持两种线程：互斥、协作
           Java虚拟机通过对象锁来实现互斥，允许多个线程在同一个共享数据上独立而互不干扰地工作
           协作通过Object类的wait方法和nofify方法来实现，允许多个线程为了同一个目标而共同工作
     活动线程会通过两条途径释放监视器：
          完成它正在执行的监视区域或者执行一个等待命令
20.2 对象锁
     Java虚拟机的一些运行时数据区会被所有的线程共享(方法区和堆)，其他的数据是各个线程私有的
     Java程序需要为两种多线程访问数据进行协调：
          保存在堆中的实例变量
          保存在方法区中的类变量
     Java栈中的局部变量程序不需要协调，因为Java栈中的数据是属于拥有该栈的线程私有的
     Java虚拟机为每一个对象和类都关联一个锁("锁住一个对象"就是获取对象相关联的监视器)
     类锁实际上用对象锁实现，当Java虚拟机装载一个class文件的时候，它会创建一个java.lang.Class类的实例，当锁住一个类的时候，实际上锁住的是那个类的Class对象
     一个线程可以允许多次对同一个对象上锁，每一个对象，Java虚拟机维护一个计数器，(只有已经拥有了这个对象的锁的线程才能对该对象再次加锁。在它释放锁之前，其他的线程不能对这个对象加锁)释放锁一次，计数器减1，当为0锁被完全释放，其他线程可以使用
     注意：Java编程人员不需要自己动手加锁，对象锁是在Java虚拟机内部使用的。在Java程序中，你只需要编写同步语句或者同步方法就可以标志一个监视区域。当Java虚拟机运行你的程序的时候，每一次进入一个监视区域的时候，它每次都会自动锁上对象或者类
20.3 指令集中对同步的支持
     在Java中，有两种内置方法来标志监视区域：同步语句和同步方法
20.3.1 同步语句
     表达式中加上synchronized关键字
     注意：catch子句用来确保被加锁的对象将被释放(解锁)，即使从同步语句块中抛出异常。不管被同步的语句块是如何退出的，线程进入这个块时获得的锁总是一定会被释放的
20.3.2 同步方法
     方法修饰符中加上synchronized关键字
     对于实例方法，虚拟机在方法将要被调用的时候获取对象相关联的锁
     对于类方法，它获取方法所属的类的锁(其实是对Class对象上锁)
     当同步方法执行完毕的时候，不管是正常结束还是抛出异常，虚拟机都会释放这个锁
20.4 Object类中的协调支持
     Object类声明了5个方法，程序员可以用来访问Java虚拟机同步的协调支持
     只有在同步方法或者同步语句中才能调用这些方法。换句话说，在这些方法被调用的时候，相关联的对象必须已经被加锁了
     void wait()
          进入监视器的等待区，直到被其他线程唤醒
     void wait(long timeout)
          进入等待区，直到被其他线程唤醒，或经过指定的毫秒数后自动苏醒
     void wait(long timeout,int nanos)
          进入等待区，直到被其他线程唤醒，或经过指定毫秒数加指定纳秒数后自动苏醒
     void notify()
          唤醒监视器的等待区中的一个等待线程(如果没有，就什么都不干)
     void notifyAll()
          唤醒监视器的等待区中的所有线程(如果没有，就什么都不干)
</pre>
						</label>
					</label>
				</label>
				<label>《数据结构与算法》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-26 03:46:37
备注：看本书目的，了解数据结构与算法，有些好奇
进度：1/216 （未看完）

Java共有八种基本数据类型：
	四种整型，两种浮点型，一种字符型以及布尔类型
异常
	Error表示Java运行时环境出现的错误，Error类对象由Java虚拟机生成并抛出
	常见的RuntimeException：
               IllegalArgumentException(非法参数异常)
               NullPointerException(空指针异常)
               ArrayIndexOutOfBoundsException(下标越界异常)
               ClassCastException(类转换异常)
               NumberFormatException(类型转换异常)
               ArithmeticException(算术异常)
               MissingResourceException(丢失资源异常)
               ClassNotFoundException(找不到类异常)
               SecurityException(安全异常)
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第一章 Java与面向对象程序设计】
1.1 Java语言基础知识
1.1.1 基本数据类型及运算
     Java共有八种基本数据类型：
          四种整型，两种浮点型，一种字符型以及布尔类型
     Java常见的算术运算符和完备的关系运算符
     Java七种位运算符：&(与)、|(或)、^(异或)、~(非)、>>(右移)、<<(左移)、>>>(高位填充0的右移)
     Java还支持一种三元运算符?:。形式为condittion?e1:e2
1.1.2 流程控制语句
     计算机高级语言程序设计中共有三种流程结构：顺序、分支、循环
     Java中有两种语句用于分支结构，if条件语句和switch多选择语句
     Java中循环语句主要有三种：for循环、while循环、do...while循环
1.1.3 字符串
     指一个字符序列，Java中没有内置的字符串类型，而是在标准Java库中包含一个名为String的预定义类。每个被一对双引号括起来的字符序列均是String类的一个实例
     Java允许使用符号+把两个字符串连接在一起，当一个字符串和一个非字符串连接，后者将被转成字符串进行连接
     Java的String类最常用的一些方法：
          char charAt(int index)
          int compareTo(String anotherString)
          int compareToIgnoreCase(String str)
          boolean endsWith(String suffix)
          boolean equals(Object anObject)
          boolean equalsIgnoreCase(String anotherString)
          int indexOf(String str)
          int lastIndexOf(String str)
          int length()
          boolean startsWith(String prefix)
          String substring(int beginIndex)
          String substring(int beginIndex,int endIndex)
          char[] toCharArray()
          String toLowerCase()
          String toString()
          String toUpperCase()
          String trim()
1.1.4 数组
     存放一组具有相同类型数据的数据结构
     可以通过整型下标来访问数组中的每一个值
     可以通过在某种数据类型后面加上[]来定义
     数组一旦被创建，就不能改变它的大小
     数组的下标从0开始计数，到数组大小减1结束。在Java中不能越过数组下标范围去访问数组中的数据，否则产生一个名为ArrayIndexOutOfBoundsException的运行时错误
     数组的大小可以通过数组的变量length返回
     为得到两个不同的但每个分量的值均相等的数组，可以使用循环语句或System类中的arraycopy方法来完成
     当数组作为方法的参数传递时，传递的是对于数组的引用，方法中操作会影响原来的数组
1.2 Java的面向对象特性
     面向对象程序设计(OOP,Object Oriented Programming)是目前主流的程序设计方法，取代了以前基于过程的程序设计技术
     面向对象程序设计主要是指在程序设计中采用抽象、封装、继承等设计方法
1.2.1 类与对象
     在面向对象思想中，抽象决定了对象的对外形象、内部结构以及处理对象的外部接口，其关键是处理对象的可见外部特征
     抽象主要是从现实世界中抽象出合理的对象结构
     一个类的每个对象均包含它所定义的结构与行为
     所以对象也叫做类的实例
     类的定义
          由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。所以Java中提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西。私有的方法数据只能通过该类的成员代码来访问
     this关键字主要有两个作用，一是表示对隐式参数的引用，一是调用类中的其他构造方法
     类内部定义私有成员变量，为了使外部获取或修改，定义了四个get、set方法
     构造方法是一种特殊的方法，作用是构造并初始化对象，可定义多个
1.2.2 继承
     继承是子类自动获取父类的数据和方法的机制，是类之间的一种关系
     在定义和实现一个类的时候，可以在一个已经存在的类的基础之上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容
     抽象的说，"is-a"关系就是继承的特点
     在Java中使用关键字extends来实现继承
     super关键字主要有两个作用，一是调用父类的构造方法，一是调用父类的方法
     如果想要把对某个类的对象引用转换为对另一个类的对象引用，需要用圆括号把目标类名括起来，然后放到需要转换的对象引用之前
     如果上述不能完成，程序在运行时会抛出异常。为了使转换在允许的情况进行，可以使用instanceof关键字
          如：if(p instanceof Student)Student s=(Student)p;
     在Java中有一个非常特殊的预定义类，那就是Object类。在Java中Object类是所有类的祖先，每个类都有Object类扩展而来。因此可以使用Object类的变量引用任意类型的对象
     在Java中不支持多继承。Java对于多继承大部分功能的实现是通过接口机制来完成的
1.2.3 接口
     接口是Java实现多继承的一种机制，一个类可以实现一个或多个接口
     接口是一系列方法的声明，是一些方法特征的集合，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为
     简单的说，接口不是类，但是定义了一组对类的要求，实现接口的某些类要与接口一致
     在Java中使用关键字interface来定义接口
     让类实现一个接口需要使用关键字implements，然后在类中实现接口所定义的方法
     注意：在Java中接口不是类，不能使用new实例化接口构造接口对象，但可以声明接口变量。并且只要类实现了接口，就可以在任何需要该接口的地方使用这个接口的对象
1.3 异常
     Java使用了一种被称为"异常处理"的机制来进行处理
     在Java中一个异常对象总是Throwable子类的实例
     在Java程序设计中，我们关注于Exception这个分支体系，一般来说由编程导致的错误会引起不同类型的RuntimeException
     两种方法来处理异常，一种是由方法本身捕获这个异常并进行相应的处理，使用try...catch结构；另一种是将这个异常从方法中抛出，使用throws以及throw关键字
     补充(阅读感悟)：
          Error表示Java运行时环境出现的错误，Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关
          常见的RuntimeException：
               IllegalArgumentException(非法参数异常)
               NullPointerException(空指针异常)
               ArrayIndexOutOfBoundsException(下标越界异常)
               ClassCastException(类转换异常)
               NumberFormatException(类型转换异常)
               ArithmeticException(算术异常)
               MissingResourceException(丢失资源异常)
               ClassNotFoundException(找不到类异常)
               SecurityException(安全异常)
1.4 Java与指针
     Java中没有显示的使用指针并且也不允许程序员使用指针，而实际上对象的访问就是使用指针来实现的
     一个对象会从实际的存储空间的某个位置开始占据一定数量的存储体。该对象的指针就是一个保存了对象的存储地址的变量，并且这个存储地址就是对象在存储空间中的起始地址
     在许多高级语言中指针是一种数据类型，而在Java中是使用对象的引用来替代的
     null是一个空指针，它不指向任何地方，也就是不指向任何类的对象，因此null可以赋值给任何类的对象的引用
     操作符new的作用实际上是为对象开辟足够的内存空间，而引用是指向这一内存空间地址的指针
     注意：
          关系运算符==比较的是存储空间是否一致
          boolean equals(Object anObject) Compares thie string to the specified object.
          如上述说明，字符串比较的是内容，对象比较时如下
     如果希望完成对象的拷贝，可以通守实现Cloneable接口并重写clone方法来完成
     如果希望判断两个对象引用是否一致可以覆盖继承自Object类的equals方法来实现
     补充(阅读感悟)：
          String a="";String b="";
              ==比较存储空间是否一致
               equals比较内容是否一样，一样内容占一份内存
          Object oa=new Object();Object ob=new Object();
               ==比较存储空间是否一致
               equals比较对象引用是否一样，即便是一样对象占两份内存
【第二章 数据结构与算法基础】
2.1 数据结构
2.1.1 基本概念
     数据结构：指相互之间存在一种或多种特定关系的数据元素的集合
     数据结构：逻辑结构、存储结构
     逻辑结构(按照数据元素之间相互关系的特性来分)：
          集合、线性结构、树形结构和图形结构
2.2 算法及性能分析
2.2.1 算法
     算法：是指令的集合，是为解决特定问题而规定的一系统操作
     五个特征：输入、输出、可行性、有穷性、确定性
【第三章 线性表】
3.1 线性表及抽象数据类型
3.1.1 线性表定义
     线性表是n个类型相同数据元素的有限序列
【第四章 栈与队列】

【第五章 递归】

【第六章 树】

【第七章 图】

【第八章 查找】

【第九章 排序】
P198
</pre>
						</label>
					</label>
				</label>
				<label>《Maven实战》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-26 03:35:45
备注：看本书的目的，学习大数据时首次知道maven，不会用，有些好奇
进度：1/382 （未看完）

Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理
Maven现在几乎已经成为了所有Java开源项目的标配
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
本书适合所有Java程序员阅读，它能帮助你更规范、更高效地管理Java项目
Maven在2007年至2010年取得了飞速的发展，现在几乎已经成为了所有Java开源项目的标配
【第1章 Maven简介】
1.1 何为Maven
     可翻译为"知识的积累"，或"专家"或"内行"
     跨平台的项目管理工具，是Apache组织中的一个颇为成功的开源项目
     Maven主要服务于基于Java平台的项目构建、依赖管理和项目信息管理
1.1.1
     发现BUG，先本地重现再说
     我们每天除了编写源代码，相当一部分时间花在了编译、运行单元测试、生成文档、打包和部署等烦琐且不起眼的工作上，这就是构建
1.1.3 Maven不仅仅是构建工具
     它提供了中央仓库，能帮我们自动下载构件
     Maven还为全世界的Java开发者提供了一个免费的中央仓库，在其中几乎可以找到任何的流行开源类库。通过一些Maven的衍生工具(如Nexus)，我们还能对其进行快速地搜索。只要定位了坐标，就能自动下载，省去了手工劳动
1.2 为什么需要Maven
1.3.1 组装PC和品牌PC
     使用脚本建立高度自定义的构建系统就像买  组装PC，耗时费力，结果也不一定很好
     使用Maven就像购买品牌PC，省时省力，直接就能使用，并能得到成熟的构建系统，还能得到来自于Maven社区的大量支持
1.2.2 IDE不是万能的
     IDE能大大提高开发效率。然而IDE是有其天生缺陷的：
          IDE依赖大量的手工操作。编译、测试、代码生成等工作都是相互独立的。手工劳动意味着低效，易出错
          很难在项目中统一所有的IDE配置，因个人喜好，一个机器上可成功运行，到了另一个机器可能就会失败
1.2.3 Make
     最早的构建工具，1977年
     但是，Make将自己和操作系统绑定在一起，就不能实现(至少很难)跨平台的构建，这对Java来说非常不友好。此外，Makefile语法也成问题
1.2.4 Ant
     不是指蚂蚁，而是"另一个整洁的工具"(Another Neat Tool)，它最早用业构建著名的Tomcat。我们可以将Ant看成是一个Java版本的Make，是跨平台的，使用XML定义构建脚本，build.xml
     Ant和Make一样，是过程式的，显式指定每一个目标，以完成要执行任务
     Maven是声明式的，构建过程各个阶段工作都由插件实现，很大程度消除了重复
     Ant没有依赖管理，后台有了借助lvy管理依赖
     Maven内置了依赖管理
     Ant打包，无非就是创建目录，复制文件，编译源代码，使用一堆任务，然后再jar、zip、war，打包就成功了
1.2.5 不重复发明轮子
     为什么没有人说"我自己写的代码最灵活，所以我不用Spring，我自己实现IOC；我不用Hibernate，我自己封装JDBC"？
1.3 Maven与极限编程
     极限编程(XP)是近些年在软件行业红得发紫的每捷开发方法，强调拥抱变化
     在传统的瀑布模型开发中，项目依次要经历需求开发、分析、设计、编码、测试和集成发布阶段。使用Maven从设计和编码阶段开始来建立项目的构建系统，有了自动化构建系统，可节省手动测试时间。最后，Maven还能快速地发布项目
1.4 被误解的Maven
     C++之父Bjame Stroustup说过一句话："只在两类计算机语言，一类语言天天被人骂，还有一类没人用。"，Ruby是个例外
     Eclipse的Maven插件——m2eclipse
     Maven是用来管理项目的，清理、编译、测试、打包、发布，以及一些自定义的过程本身就是一件复杂的事情
【第2章 Maven的安装和配置】
【第3章 Maven使用入门】
P33
【第4章 背景案例】

【第5章 坐标和依赖】

【第6章 仓库】

【第7章 生命周期和插件】

【第8章 聚合与继承】

【第9章 使用Nexus创建私服】

【第10章 使用Maven进行测试】

【第11章 使用Hudson进行持续集成】

【第12章 使用Maven构建Web应用】

【第13章  版本管理】

【第14章 灵活的构建】

【第15章 生成项目站点】

【第16章 m2eclipse】

【第17章 编写Maven插件】

【第18章 Archetype】

【附录A POM元素参考】

【附录B Settings元素参考】

【附录C 常用插件列表】

</pre>
						</label>
					</label>
				</label>
			</label>
			<label>BIG</label>
			<label>
				<label>《NoSQL数据库》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-11 00:49:51
备注：看本书目的，了解一下NoSQL及适用场景
进度：209/209

本书介绍了memcached、Tokyo Tyrant、Redis和MongoDB这4种NoSQL数据库
本书仅仅将NoSQL定位为"关系型数据库之外的另一种选择"
典型的NoSQL数据库
     临时性键值存储：memcached、(Redis)
     永久性键值存储：Tokyo Tyrant、Flare、ROMA、(Redis)
     面向文档的数据库：MongoDB、CouchDB
     面向列的数据库：Cassandra、HBase、HyperTable
各种NoSQL数据库的特征
     memcached
          挥发性的键值存储
          一般作为关系型数据库的缓存来使用
          具有非常快的处理速度
          由于存在数据丢失的可能，所以一般用来处理不需要持久保存的数据
          用于需要使用expires时(需要定期清除数据)
          使用Consistent Hashing算法来分散数据
     Tokyo Tyrant
          持久性的键值存储
          用来处理需要持久保存，高速处理的数据
          具有非常快的处理速度
          用于不需要定期清除数据时
          使用Consistent Hashing算法来分配数据
     Redis
          兼具memcached和Tokyo Tyrant优势的键值存储
          擅长处理数组类型的数据
          具有非常快的处理速度
          可以高速处理时间序列的数据，易于处理集合运算
          拥有很多可以进行原子处理的方法
          使用Consistent Hashing算法来分散数据
     MongoDB
          面向无需定义表结构的文档数据
          具有非常快的处理速度
          通过BSON的形式可以保存和查询任何类型的数据
          无法进行JOIN处理，但是可以通过嵌入(embed)来实现同样的功能
          使用sharding(范围分割)算法来分散数据
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
本书介绍了memcached、Tokyo Tyrant、Redis和MongoDB这4种NoSQL数据库，为读者开发数据库提供更多选择。书中最后还介绍了如何将MySQL数据库NoSQL化

本书适合所有数据库开发人员

本书仅仅将NoSQL定位为"关系型数据库之外的另一种选择"

基本的CRUD处理(创建、检索、更新、删除)

【第1章 NoSQL数据库的基础知识】
1.NoSQL，Not Only SQL，意义是：适用关系型数据库就使用关系型数据库，不适用的时候也没有必要非使用关系型数据库不可，可以考虑使用更加合适的数据存储
2.关系数据库包括Oracle、Microsoft SQL、DB2、PostgreSQL，本书主要指MySQL
3.1969年，科德发表一篇论文，首次提出了关系数据模型的概念，成为了现今关系型数据库的基础
4.数据库根据不同的数据模型(数据的表现形式)主要分成阶层型、网络型和关系型3种
     阶层数据库
          以简单的树型结构来定义
          遇到复杂数据时往往会造成数据的重复，出现数据冗余的问题
          不理解数据结构就无法进行高效的查询
     网络型数据库
          为解决数据重复问题，拥有同阶层型数据库样近的数据结构，数据如同网状交织在一起，因此而得名
          阶层型数据库只能通守父子关系来表现数据之间的关系。针对这一不足，网络型数据库可以使子记录同时拥有多个父记录，从而解决数据冗余问题
          复杂的关系更新困难，同样，对数据结构有很强的依赖性，不理解数据结构就无法进行相应的数据访问
     关系型数据库
          把所有数据都通过行和列的二元表现形式表示出来
          将作为操作对象的数据和操作方法(数据之间的关联)分离开来，消除了对数据结构的依赖性，让数据和程序的分离成为可能
5.关系型数据库的优势
     通用性及高性能
          本书一个重要的大前提，"关系型数据库的性能绝对不低，它具有非常好的通用性和非常高的性能"，对于绝大多数的应用来说它都是最有效的解决方案
     突出的优势
          保持数据的一致性(事务处理) #最大优势
          由于以标准化为前提，数据更新的开销很小(相同的字段基本上都只有一处)
          可以进行JOIN等复杂查询
          存在很多实际成果和专业技术信息(成熟的技术)
     不擅长的处理
          毕竟是一个通用型的数据库，并不能完全适应所有的用途
          大量数据的写入处理
          为有数据更新的表做索引或表结构(schema)变更
               增加必要字段改变表结构时，需要对表进行共享锁定
               名称-共享锁，别名-读锁，锁的影响范围-其他连接可以对数据进行读取但是不能修改数据
               名称-排他锁，别名-写锁，锁的影响范围-其他连接无法对数据进行读取和修改操作
          字段不固定时应用
          对简单查询需要快速返回结果的处理
               称不上缺点，但不管怎样，不擅长对简单的查询快速返回结果，对SQL语言进行解析、对表的锁定和解锁这样的额外开销。并不是说关系型数据库的速度太慢，而只是想告诉大家若希望对简单查询进行高速处理，则没有必要非用关系型数据库不可
               #这里所说的"简单"指的是没有复杂的查询条件，而不是用JOIN的意思
6.不利用SQL而是直接进行数据访问
     3306号端口 SQL MySQL的数据文件
     9998/9999号端口HandlerSocket MySQL数据文件
7.各个数据之间存在关联是关系型数据库得名的主要原因
     为了进行JOIN处理，不得不把数据存储在同一个服务器内，不利于数据的分散
8.想要使服务器能够轻松处理更大量的数据，只有两个选择：
     提升性能-方法简单，成本较高
     增大规模-使用多台廉价服务器提高处理能力，可控制成本
9.典型的NoSQL数据库
     临时性键值存储：memcached、(Redis)
          最常见的NoSQL，基本上只能通过键的完全一致查询获取数据
          根据数据的保存方式分为临时性、永久性和两者兼具3种
     永久性键值存储：Tokyo Tyrant、Flare、ROMA、(Redis)
          1Redis首先把数据保存到内存中，在满足特定条件(默认15分钟一次以上，5分钟内10个以上，1分钟内10000个以上的键发生变更)的时候将数据写入到硬盘中。这样既确保了内存中数据的处理速度，又可以通过写入硬盘来保证数据的永久性。这种类型的数据库特别适合于处理数组类型的数据
     面向文档的数据库：MongoDB、CouchDB
          不需要定义表结构，可以利用复杂的查询条件
     面向列的数据库：Cassandra、HBase、HyperTable
          普通的关系型数据库都是以行为单位来存储数据的，擅长进行以行为单位的读入处理。因此，关系型数据库也被称为面向行的数据库
          优势：高扩展性，数据增加也不会降低相应的处理速度，所以主要应用于需要处理大量数据的情况
          优势：对大量行少数列进行读取，对所有行的特定列进行同时更新
          应用十分困难，由于跟现行数据库存储的思维方式有很大不同
10.通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库
【第2章 NoSQL数据库的种类和特征】
1.memcached(临时性键值存储)
     Danga Interactive公司开发的开源软件
     http://memcached.org/
     响应速度是直接影响到用户行为和营业额的非常重要的指标
     memcached是通过散列表(关联数组)来存储各种格式数据的键值存储
     保存数据的时候进行序列化处理，读取数据的时候进行反序列化处理
     优势1：极其快速的处理速度，内存中对数据的访问速度是硬盘中的10~100万倍
     优势2：简单易用性
     在使用多台服务器来运行memcached的时候，会使用一致性散列(Consistent Hashing)算法来分散数据
     一致性散列(Consistent Hashing)-分散算法
     用键的散列值除以服务器台数，除以4的余数只能是0、1、2、3(每个数据都与4台服务器相对应)，但，服务器台数增减带来缓存错误问题
     这个算法首先对各个服务器对应的散列值进行计算，把它们配置到一个圆周上。同时对各个数据对应的键的散列值进行计算，从键的散列值出发沿圆周向右，由距离该散列值最近的服务器来负责处理这条数据(数据的保存、读取都由这个服务器来执行)
     这样的分配方式能够减小服务器增减带来的影响
     对1、2、3号服务器负责处理的数据没有任何影响
     唯一受影响的是4号服务器负责的范围
     由此可见这个算法将会把服务器增减带来的缓存错误的影响减小到非常低的水平
     不足1：数据临时性
     不足2：只能通过指定键来读取数据，不能用模糊查询，必需完全匹配
     当保存的数据量超过-m参数设定的时候，会以LUR(Least Recently Used最近最少使用算法)的顺序来丢弃数据
     memecached默认的等机端口号是11211
     由于memcached通过一致性散列算法来分散数据，所以数据会根据服务器的台数进行自动分散
2.Tokyo Tyrant(永处性键值存储)
     官方网站：http://1978th.net/tolyotyrant
     数据保存在硬盘，保证数据的持久性，由C语言编写的，可以对硬盘访问进行优化，从而实现数据的高速处理
     Tokyo Cabinet，key-value具有键值存储功能，数据存储的部分
     Tokyo Tyrant，为了让Tokyo Cabinet支持网络而进行的封装
     和memcached一样，通过键值这样的散列表结构保存数据
     引入了数据类型，可以根据选择的数据类型，在缓存数据库、散列数据库、B-tree数据库和表格数据库等数据保存方式间进行转换
     根据数据类型的不同，也存在和memcached同样的把数据保存在内存中的情况
     优势：
          持久性
          保存和读取数据时，与硬盘的IO处理无关，可实现对数据的高速访问。可以获得比关系型数据库快很多的处理速度
     Tokyo Tyrant的数据类型和特征
          数据类型     数据的保存方式     特征
          缓存数据库 以键值的形式把数据保存在内存中 和memcached相同
          散列数据库 以键值的形式把数据保存在硬盘上 擅长随机存取
          B-tree数据库 一个键对应多个值的保存和读取。数据保存在硬盘上 擅长范围查询和连续访问
          表格数据库 像关系型数据库那样通过多个字段把数据保存在硬盘上 可以进行复杂条件的查询
     不足：
          安装难度比较大
          没有memcached那么多的成熟技术，安装实例也没有memcached那么多
     通过启动时指定的文件名来指定使用哪种数据库类型，这种方式较为奇特
     由于这是在日本国内开发的键值存储，所以这里以日本国内的实例为主
     默认的待机端口号是1978
     memcached和Tokyo Tyrant的不同
          名称     数据的持处性 expires(失效时间)     复制
          memcached 无(保存在内存中) 有  不用为标准支持(通过repcached等支持)
          Tokyo Tyrant 有(保存在硬盘上) 无 标准支持

3.Redis(临时性/持久性键值存储)
     官方网站：http://redis.io/
     数据在读取、变更和更新之间都会存在时间延迟，Redis会把这样的一连串的操作定义为原子操作，并且提供很多命令来保证数据的一致性
     请参考URL：http:ja.wikipedia.0org/wiki/不可分操作
     memcached通过CAS(Compare-and-Swap或者Check and Set的简称)操作来保证数据的一致性
     memcached虽然可以通过CAS操作来保证数据的一致性，但是仍然需要考虑多进程的问题，处理失败的时候还要考虑重新处理的逻辑。如果想处理数组类型的数据，Redis真的是不错的选择
     数据快照
     不足：
          最大的问题就是这项新技术的使用实例比较少
     默认的待机端口号是6379
4.MongoDB(面向文档的数据库)
     官方网站：http://www.mongodb.org/
     存储类型上略有不同，但却是一种非常实用的NoSQL数据库
     优点：
          无表结构的数据库
          对于任何key都可以像关系型数据库那样进行复杂查询等操作
          比关系型数据库处理速度更快
          可以通过添加索引来进行高速处理
     保存数据时把数据和数怕结构都完整地以BSON(JSON的二进制化产物)的形式保存起来，并把它作为值和特定的键进行关联。所以不需要定义表结构因而被称为面向文档数据库
     关系型数据库中表在面向文档数据库中称为集合，表中记录称为文档
     无法是行JOIN查询，但可以在对象中事先嵌入其他对象获得同样的效果
     在保存数据时需要预留出很大的空间，对硬盘的空间需求量呈逐渐增大的趋势
     优势：
          无表结构，减少了添加字段等表结构变更所需要的开销
          灵活地指定查询条件。比如正则表达式查询，或者对数组中特定数据的判断都可以完成
     不足：
          不支持JOIN查询和事务处理
          不能实时向硬盘中写入数据，可能出现数据丢失(参考一下http://www.mongodb.org/pages/viewpage.action?pageId=5079223)
     默认端口号：27017
     MongoDB的sharding是通过范围分割算法进行的，范围分割是以范围为单位把数据集中分散到某一台服务器上，因此比较擅长进行范围查询
     由数据分散算法造成的不同
          数据的分配算法(sharding)     优点     缺点
          Consistent Hashing     根据服务器的增加进行自动分配 缓存错误问题
          范围分割     擅长范围查询     元信息需要在其他服务器管理
【第3章 试用NoSQL数据库】
1.缓存数据的粒度
     缓存数据的粒度     优点     缺点
     小     可以充分发挥缓存的效率     缓存的管理和清除比较繁锁
     大     缓存的清除很简单     缓存的效率不高
2.PV：page view即页面浏览量，或点击量
   UU：Unique Users指在单位时间内访问某一站点的所有不同的用户的数量
【第4章 性能验证】
1.插入处理的性能
     使用独立协议的Tokyo Tyrant和Redis的处理速度非常快
     由于程序库的影响，memcached和使用memcached兼容协议的Tokyo Tyrant却并没有表现出预想的性能。当然，比关系型数据要更快
     MongoDB性能介于键值存储和关系型数据库之间，相当实用，但是，MongoDB在数据创建和更新时写入磁盘的处理是异步的，需特别注意
2.查询的性能
     MySQL和MongoDB使用索引功能
     同插入比较，通过创建索引，MySQL和MongoDB都可以获得非常高的处理速度。虽然适当地创建索引可以提高查询的性能，但是请一定注意，不要过多地创建索引，不然在添加和更新数据的时候，会由于需要更新索引而造成延迟
     与MySQL进行比较的NoSQL数据库的性能对比
         memcached Tokyo Tyrant(mem) Tokyo Tyrant Redis MongoDB 
     插入 快速 快速 非常快速 非常快速 较快速
     查询 快速 快速 非常快速 非常快速 速度相同
【第5章 NoSQL化的关系型数据库】
1.各种NoSQL数据库的特征
     memcached
          挥发性的键值存储
          一般作为关系型数据库的缓存来使用
          具有非常快的处理速度
          由于存在数据丢失的可能，所以一般用来处理不需要持久保存的数据
          用于需要使用expires时(需要定期清除数据)
          使用Consistent Hashing算法来分散数据
     Tokyo Tyrant
          持久性的键值存储
          用来处理需要持久保存，高速处理的数据
          具有非常快的处理速度
          用于不需要定期清除数据时
          使用Consistent Hashing算法来分配数据
     Redis
          兼具memcached和Tokyo Tyrant优势的键值存储
          擅长处理数组类型的数据
          具有非常快的处理速度
          可以高速处理时间序列的数据，易于处理集合运算
          拥有很多可以进行原子处理的方法
          使用Consistent Hashing算法来分散数据
     MongoDB
          面向无需定义表结构的文档数据
          具有非常快的处理速度
          通过BSON的形式可以保存和查询任何类型的数据
          无法进行JOIN处理，但是可以通过嵌入(embed)来实现同样的功能
          使用sharding(范围分割)算法来分散数据
2.将MySQL数据库NoSQL化的方法
     HandlerSocket插件，MySQL的非SQL接口，通过它可以不使用SQL就能读取和更新MySQL的数据，不支持事务处理，只支持查询带有索引的数据
     关系型数据库必须要对SQL进行解析，还会增加锁表和解锁这样的额外开销，详见：http://dev.mysql.com/doc/refman/5.1/ja/handler.html
     具有非常高的处理速度，经MySQL为基础的。虽然它并不是很成熟，稳定性仍需观望

</pre>
						</label>
					</label>
				</label>
				<label>《Redis入门指南》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-06 22:20:00
备注：看本书目的，了解Redis基础
进度：189/189

2009年诞生
Redis是Remote DIctionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容
到目前为止Redis支持的键值据类型如下：
	字符串类型 string
	散列类型 hash
	列表类型 list
	集合类型 set
		集合类型在Redis内部是使用值为空的散列表(hash table)实现的
	有序集合类型 zset
关于Redis和Memcached优劣
	在性能上Redis是单线程模型，而Memcached支持多线程
	在多核服务上后者的性能更高一些
Redis中的事务(transaction)是一组令的集合
Redis过期键删除机制：
	惰性删除
		expire的键到期后，不会自动删除，不过在每次读取该键时进行检查，检查该键是否已经过期，如果过期，则进行删除动作。
	定期删除
		每隔一段时间执行一次cron删除操作，从每个db的expire-keys中随机找出一定数量的key（默认是20个），检查key是否超时。如果已经超时，则进行删除
	大于maxmemory的自动删除
		如果当前的内存已经超过了max-memory，那么则进行清理，直到内存占用在maxmemory线以下
Redis对于过期键删除使用的是惰性删除 + 定期删除 + 大于maxmemory的自动清除的策略
持久化：RDB方式、AOP方式
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
2009年诞生
【第1章 简介】
新浪微博拥有着几百台Redis服务器

VMware公司从2010年开始赞助Redis的开发，Salvatore Sanfilippo和Pieter Noordhuis也分别于同年的3月和5月加入VMware，全职开发Redis

Redis是Remote DIctionary Server(远程字典服务器)的缩写，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容

到目前为止Redis支持的键值据类型如下：
字符串类型 string
散列类型 hash
列表类型 list
集合类型 set
有序集合类型 zset

在一台普通的笔记本电脑上，Redis可以在一秒内读写超过十万个键值

Redis可以为每个键设置生存时间(Time To Live,TTL)

关于Redis和Memcached优劣
在性能上Redis是单线程模型，而Memcached支持多线程
在多核服务上后者的性能更高一些
Redis的性能已足够优异，在绝大部分场合下其性能都不会成为瓶颈，所在在使用时更应该关心的是二者在功能上的区别
如果需要用到高级的数据类型或是持久化等功能，Redis将会是Memcached很好的替代品

Redis的列表类型可以用来实现队列，并且支持阻塞式读取，可以很容易地实现一个高性能的优先级队列

数组直接以列表类型存入Redis

【第2章 准备】
Redis的版本规则，Redis约定次版本号(即第一个小数点后的数字)为偶数的版本是稳定版(如2.4版、2.6版)，奇数版本是非稳定版(如2.5版、2.7版)

>make #命令完成编译
>make install #命令来将这些可执行程序复制到/usr/local/bin目录中以便以后执行程序时可以不用输入完整的路径

启动Redis两种方式：
直接启动-开发环境
     >redis-server
     >redis-server --port 6380 #自定义端口号
     #6379是手机键盘上MERZ对应的数字，MERZ是一名意大利歌女的名字
通过初始化脚本启动-生产环境
     #在Redis源代码目录的utils文件夹中redis_init_script的初始化脚本文件
     #需要本置Redis的运行方式和持久化文件、日志文件的存储位置等
     #1.配置初始化脚本，将脚本复制到/etc/init.d目录中，文件名为redis_端口号，修改脚本第6行的REDISPORT变量的值
     #2.建立需要的文件夹
          /etc/redis #存放Redis的配置文件
          /var/redis/端口号 #存放Redis的持久化文件
     #3.修改配置文件
          将配置文件模板复制到/etc/redis目录中，以端口号命名
          daemonize yes #使Redis以守护进程模式运行
          pidfile /var/run/redis_端口号.pid #设置Redis的PID文件位置
          port 端口号 #设置Redis监听的端口号
          dir /var/redis/端口号 #设置持久化文件存放位置
     使用/etc/init.d/redis_端口号 start来启动Redis
     sudo update-rc.d redis_端口号 defaults #随系统自动启动

 停止Redis
考虑到Redis有可能正在将内存中的数据同步到硬盘，强行终止Redis进程可能会导致数据丢失
正确停止方式应该是向Redis发送SHUTDOWN命令
>redis-cli SHUTDOWN
当Redis收到SHUTDOWN命令后，会先断开所有客户端连接，然后根据配置执行持久化，最后完成退出
Redis可以妥善处理SIGTERM信号，所以使用"kill Redis进程的PID"也可以正常结束Redis，效果与发送SHUTDOWN命令一样

redis-cli(Redis Command Line Interface)
是Redis自带的基于命令行的Redis客户端
>redis-cli -h 127.0.0.1 -p 6379 #自定义地址和端口号

命令返回值
1.状态回复-status reply
     >PING #PONG
2.错误回复-error reply
     #(error)错误信息
3.整数回复
     #(integer)数字
4.字符串回复-bulk reply
     #""
     #(nil)
5.多行字符串回复-multi-bulk reply
     #每行字符串都以一个序号开头

Redis支持通过配置文件来设置启动参数
1.将配置文件的路径作为启动参数
     >redis-server /path/to/redis.conf --loglevel warning
2.还可以在Redis运行时通过CONFIG SET命令在不重新启动情况下动态修改部分Redis配置
     >CONFIG SET loglevel warning
     >CONFIG GET loglevel #第一行选项名，第二行选项值

多数据库
Redis每个数据库对外都是以一个从0开始的递增数字命名，Redis默认支持16个数据库，可通过配置参数九databases修改
Redis不支持自定义数据库的名字，每个数据库都以编号命名
Redis不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限

【第3章 入门】
>KEYS pattern #pattern支持glob风格通配符格式
     #glob风格通配符规则
     ?     匹配一个字符
     *     匹配任意个(包括0个)字符
     []     匹配括号间的任一字符，可以使用"-"符号表示一个范围，如a[b-d]可以匹配"ab","ac"和"ad"
     \x     匹配字符x，用于转义符号。如要匹配"?"就需要使用\?

注意：KEYS命令需要遍历Redis中的所有键，当键的数量较多时会影响性能，不建议在生产环境中使用
提示：Redis不区分命令大小写，但在本书中均会使用大写

技巧：DEL命令的参数不支持通配符，但可以结合Linux的管道和xargs命令自己实现删除所有符合规则的键
     >redis-cli KEYS "user:*" | xargs redis-cli DEL
    #由于DEL命令支持多个键作为参数
     >redis-cli DEL 'redis-cli KEYS "user:*"'
     #同样的效果，但是性能更好

获得键值的数据类型
TYPE命令用来获得键值的数据类型，返回的值可能是
string(字符串类型)、hash(散列类型)、list(列表类型)、set(集合类型)、zset(有序集合类型)

1.字符串类型
能存储任何形式的字符串，包括二进制数据，比如用户邮箱、JSON化的对象甚至是一张图片
一个字符串类型键允许存储的数据的最大容量是512MB
#在Redis3.0版本中可能会放宽这一限制，但考虑到内存存储，512MB的限制已经非常宽松了
字符串类型是其他4种数据类型的基础，其他数据类型和字符串类型的差别从某种角度来说只是组织字符串的形式不同

原子操作取"原子"的"不可拆分"的意思，原子操作是最小的执行单位，不会在执行的过程中被其他命令插入打断

提示：Redis对于键的命名并没有强制的要求，但比较好的实践是用"对象类型:对象ID:对象属性"来命名一个键，如user:1:friends，对于多个单词则推荐使用"."分隔
Redis以前版本键名不能包含空格等特殊字符，在客户端容易输入
虽然采用较短的名称可以节省存储空间，但由于键值的长度往往远远大于键名的长度，所以这部分的节省大部分情况下并不如可读性来得重要

增加指定浮点数
     >INCREBYFLOAT bar 2.7 #"6.7"
     >INCRBYFLOAT bar 5E+4 #"50006.699...9929"

位操作
利用位操作命令可以非常紧凑地存储布尔值。比如某网站的每个用户都有一个递增的整数ID，如果使用一个字符类型键配合位操作来记录每个用户的性别(用户ID作为索引，二进制位值1和0表示男性和女性)，那么记录100万个用户的性别只需占用100KB多的空间，这样读取二进制位值性能很高

2.散列类型
散列类型(hash)的键值也是一种字典结构，其存储了字段(filed)和字段值的映射，但字段值只能是字符串，不支持其他数据类型，换句话说，散列类型不能嵌套其他的数据类型
一个散列类型可以包含至多2^32-1个字段

提示：除了散列类型，Redis的碁 他数据类型同样不支持数据类型的嵌套

散列类型适合存储对象：使用对象类别和ID构成键名，使用字段表示对象的属性，而字段值则存储属性值
键-对象:ID 字段-属性 字段值-属性值

提示：在Redis中每个键都属于一个明确的数据类型，如通过HSET命令建立的键是散列类型，通过SET命令建立的键是字符串类型等。使用一种数据类型的命令操作另一种数据类型的键会提示错误
并不是所有命令都是如此，比如SET命令可以覆盖存在的键而不论原来键是什么类型

3.列表类型
列表类型(list)可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某一个片段
列表类型内部是使用双向链表(double linked list)实现的，所以获取越接近两端的元素速度就越快
不过使用链表的代价是通过索引访问元素比较慢
借助列表类型，Redis还可以作为队列使用
与散列类型最多能容纳的字段数量相同，一个列表类型键最多能容纳2^32-1个元素

可以使用列表类型来模拟栈和队列的操作：
如果想把列表当做栈，则搭配使用LPUSH和LPOP或RPUSH和RPOP
如果想把列表当成队列，则搭配使用LPUSH和RPOP或RPUSH和LPOP

4.集合类型
在集合中的每个元素都是不同的，且没有顺序
一个集合类型(set)键可以存储至多2^32-1个字符串

集合类型和列表类型对比：
               集合类型     列表类型
存储内容     至多2^32-1个字符串     至多2^32-1个字符串
有序性     否     是
唯一性     是     否

集合类型在Redis内部是使用值为空的散列表(hash table)实现的
SRANDMEMBER命令返回的数据似乎并不是非常的随机
出现这种情况是由集合类型采用的存储结构(散列表)造成的
散表表使用散列函数将元素映射到不同的存储位置(桶)上以实现O(1)时间复杂度的元素查找
当使用散列表存储元素时，使用散列函数计算出散列值，存入编号为该值的桶(bucket)中，查找时用同样的函数计算值并到相应的桶中找元素
当两个不同的元素散列值相同是会出现冲突，Redis使用拉链法来解决冲突，即将散列值冲突的元素以链表的形式存入同一桶中，查找元素时先找到元素对应的桶，然后再从桶中的链表中找到对应的元素。所以元素所在的桶中的元素数量越少，其被随机选中的可能性就越大
Redis会先从所有桶中随机挑一个非空的桶，然后再从桶中随机选择一个元素

5.有序集合类型
在集合类型的基础上有序集合类型为集合中的每个元素都关联了一个分数

有序集合类型和列表类型异同：
相同
     (1)二者都是有序的
     (2)二者都可以获得某一范围的元素
不同
     (1)列表类型是通过链表实现的，获取靠近两端的数据速度极快，在元素增多后，访问中间数据的速度会较慢，适合实现如"新鲜事"或"日志"这样很少访问中间元素的应用
     (2)有序集合类型是使用散列表和跳跃表(Skip list)实现的，所以即使读取位于中间部分的数据速度也很快
     (3)列表中不能简单地调整某个元素的位置，但有序集合通过更改过个元素的分数可以
     (4)有序集合要比列表类型更耗费内存
有序集合类型算得上是Redis的5种数据类型中最高级的类型了
分数不仅可以是整数，还支持双精度浮点数
     >zadd testboard +inf c
     #其中+inf和-inf分别表示正无穷和负无穷
如果两个元素的分数相同，Redis会按照字典顺序(即"0"<"9"<"A"<"Z"<"a"<"z"这样的顺序)来进行排列，中文取决于中文的编码方式
     >zrangebyscore scoreboard 80 100
     #分数范围包含两端
     >zrangebyscore scoreboard 80 (100
     #分数范围不包含端点值
     >zrangebyscore scoreboard (80 +inf
     #不知道最高分是多少，正无穷大

【第4章 进阶】
Redis中的事务(transaction)是一组令的集合
     >multi #OK
     >sadd "user:1:following" 2 #QUEUED
     >sadd "user:2:followers" 1 #QUEUED
     >exec #(integer)1 (integer)1
返回QUEUED表示这两条命令已经进入等待执行的事务队列中了
EXEC命令将等待执行的事务队列中所有命令按照发送顺序依次执行
如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列
使用事务来解决竞态条件的方法

错误处理
(1)语法错误
只要有一个命令有误法错误，执行EXEC后直接返回错误，都不执行
Redis2.6.5之前会忽略语法错误的命令，执行其他正确的命令
(2)运行错误
实际执行之前无法发现的，会被Redis接受并执行，其他命令依然会继续执行(包括出错命令之后的命令)
Redis的事务没有关系数据库事务提供的回滚(rollback)功能，也使得Redis在事务上可以保持简洁和快速
语法错误可以在开发时找出并解决
另外如果能够很好地规划数据库(保证键名规范等)的使用，是不会出现如命令与数据类型不匹配这样的运行错误的

WATCH命令介绍
     >set key 1 #OK
     >watch key #OK
     >set key2 #OK
     >multi #OK
     >set key 3 #queued
     >exec #(nil)
     >get key #2
提示：由于WATCH命令的作用只是当被监控的键值被修改后阻止之后一个事务的执行，而不能保证其他客户端不修改这一键值，所以我们需要在EXEC执行失败后重新执行整个函数
在代码中判断要赋值的字段是否存在，如果不存在就不执行事务中的命令，但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响

生存时间
在Redis中可以使用EXPIRE命令设置一个键的生存时间，到时间后Redis会自动删除它

脏页
脏页是linux内核中的概念，因为硬盘的读写速度远赶不上内存的速度，系统就把读写比较频繁的数据事先放到内存中，以提高读写速度，这就叫高速缓存，linux是以页作为高速缓存的单位，当进程修改了高速缓存里的数据时，该页就被内核标记为脏页，内核将会在合适的时间把脏页的数据写到磁盘中去，以保持高速缓存中的数据和磁盘中的数据是一致的
详见http://www.tuicool.com/articles/7JFnIfm
脏页是因为内存中的很多数据没来得及更新到磁盘导致的

Redis过期键删除机制：
惰性删除：
    -  expire的键到期后，不会自动删除，不过在每次读取该键时进行检查，检查该键是否已经过期，如果过期，则进行删除动作。这样可以保证删除操作只会在非做不可的情况下进行   
定期删除：
    - 每隔一段时间执行一次cron删除操作，从每个db的expire-keys中随机找出一定数量的key（默认是20个），检查key是否超时。如果已经超时，则进行删除
    - 通过限制删除操作执行的时长和频率，并以此来减少删除操作对 CPU 时间的影响。
大于maxmemory的自动删除：
    - 每次client和server进行command交互时，server都会检查maxmemory的使用情况
    - 如果当前的内存已经超过了max-memory，那么则进行清理，直到内存占用在maxmemory线以下
    - 清理的策略基于淘汰机制（LRU,TTL,RANDOM等）
Redis对于过期键删除使用的是惰性删除 + 定期删除 + 大于maxmemory的自动清除的策略
相对而言，比较合理的方式是基于使用情况设置redis的maxmemory大小，用于让redis实现自身的数据清理机制，确保把mem限制在maxmemory设定范围内

实现访问频率限制之一
     限制每分钟每个用户最多只能访问100个页面
          字符串类型键"rate.limiting:用户IP"，每次访问INCR递增键值，生成时间1分钟，每分钟会自动被删除，所以下一分钟用户的访问次数又会重新计算，也就达到了限制访问频率的目的
          为保证建立键和为键设置生存时间一起执行，可以用事务功能
               >MULTI
               >SET
               >EXPIRE
               >EXEC
实现访问频率限制之二
     每个用户每分钟只能访问10次，使用一个列表类型的键来记录最近10次访问博客的时间，元素超过10个，判断最早元素距现在的时间是否小于1分钟，是则限制，不是就将现在的时间加入到列表中，同时把最早的元素删除
          >if(LLEN rate.limiting:$IP<10) #代码是now()是获得当前的Unix时间
               LPUSH rate.limiting:$IP now()
             else
                  if((now()-())<60)
                      访问频率超过了限制，请稍后再试
                 else
                      LPUSH rate.limiting:$IP now()
                      LTRIM rate.limiting:$IP 0,9

实现缓存
     为了提高网站的负载能力，常常需要将一些访问频率高但是对CPU或IO资源消耗较大的操作的结果缓存起来，并让其自动过期
     比如成绩排名，计算过程较耗资源，可用一个字符串键缓存起来，每隔两个小时重新计算一次。每次访问先查询缓存键是否存在
     当服务器内存有限时，大量使用缓存键且生存时间过长会导致Redis占满内存；另一方面防止生存时间太短，导致缓存命中率过低且大量内存闲置，为此可以限制Redis使用的最大内存，这种方式在只将Redis用作缓存系统时非常实用
     方法：修改配置文件maxmemory参数，单位字节，超出限制时Redis会依据maxmemory-policy参数指定的策略来删除不需要的键，直到Redis占用的内存小于指定内存，如当该参数设置为allkeys-lru时，一旦占用内存超过限制值，Redis会不断地使用LRU算法删除数据库中最近最少使用的键，直到占用内存小于限制值
     注：事实上Redis并不会准确将整个库中最久未被使用的键删除，而是每次随机取3个键，删除中最久未被使用的，可通过配置文件中的maxmemory-samples设置

有序集合的集合操作
     有序集合常见的使用场景是大数据排序，如排行榜，很少需要获得键中的全部数据。同样Redis认为开发者在做完交集、并集运算后不需要直接获得全部结果，而是将结果存入新的键中以便后续处理，所以有ZINTERSTORE和ZUNIONSTORE而没有ZINTER和ZUNION
     如需直接获得集合运算结果，可用5个命令自己实现ZINTER
          >MULTI
          >ZINTERSTORE temp ...
          >ZRANGE temp ...
          >DEL temp
          >EXEC

SORT命令
     可以对列表类型、集合类型和有序集合类型键进行排序，并且可以完成与关系数据库中的连接查询相类似的任务
     在对有序集合类型排序时会忽略元素的分数，只针对元素自身的值进行排序
     除了排列数字，还可通过ALPHA参数实现按照字典顺序排列非数字元素，默认尝试将所有元素转换成双精度浮点数来比较，无法转换则提示错误
          >SORT mylistlpha ALPHA
     分页显示，LIMIT参数来返回指定范围的结果，LIMIT offset count，表示跳过前n个元素并获取之后的m个元素
          >SORT tag:ruby:posts DESC LIMIT 1 2
     BY参考键，可以是字符串类型键或者是散列类型键的某个字段(表示为键名->字段名)，不再依据元素自身的值进行排序，而是对每个元素使用元素的值替换参数键中的第一个"*"并获取其值，然后依据该值对元素排序
          >SORT tag:ruby:posts BY post:*->time DESC #time字段存的Unix时间
     当参考键不包含"*"时(即常量键名，与元素值无关)，SORT命令将不会执行排序操作，因为Redis认为这种情况是没有意义的(因为所有要比较的值都一样)
     常量键名不存在，此时SORT结果与LRANGE结果相同，没有执行排序操作

GET参数

按照规则订阅

字符串类型

【第5章 实践】

【第6章 脚本】
     Redis在2.6版推出了脚本功能，允许开发者使用Lua语言编写脚本传到Redis中执行
     使用脚本的好处：
     (1)减少网络开销：发送多次请求变成只需发送一个请求即可，减少了网络往返时延
     (2)原子操作：作为一个整体执行，中间不会被其他命令插入，无需担心会出现竞态条件，也就无需使用事务。事务可以完成的功能都可以用脚本来实现
     (3)复用：客户端发送的脚本会永久存储在Redis中

Lua语言
     Lua是一个高效的轻量级脚本语言
     实际上很多IOS游戏中都使用了Lua语言，例如2011年很火的游戏《愤怒的小鸟》就是使用Lua语言实现的关卡，另外风靡全球的网络游戏《魔兽世界》的插件也是使用Lua语言开发的

Lua语法
     Lua是一个动态类型语言，一个变量可以存储任何类型的值
     1.数据类型
     2.变量
          Lua的变量分为全局变量和局部变量。全局变量无需声明可直接使用，默认值是nil
          在Redis脚本中不能使用全局变量，防止脚本之间相互影响
               loca c
          局部变量的作用域为从声明开始到所在层的语句块末尾
     3.注释
          单行注释以--开始，到行尾结束，一般习惯在--后面跟上一个空格
          多行注释以--[[开始，到]]结束
     4.赋值
          Lua支持多重赋值
               local a,b=1,2 #a值是1，b值是2
               local c,d=1,2,3 #c值是1，d值是2，3被舍弃了
               local e,f=1 #e值是1，f值是nil
Lua的表类型索引是从1开始的，后文件介绍
     5.操作符
     6.if语句
          注意：Lua中只有nil和false才是假，其余值，包括空字符串和0，都被认为是真值
     7.循环语句
          提示：for语句中的循环变量是局部变量，作用域为for循环体内。加然没有使用local声明，但它不是全局变量
     8.表类型
          注意：Lua约定数组的索引是从1开始的，而不是0
     9.函数

【第7章 管理】
持久化：RDB方式
     save 900 1 #指定了快照条件，可存多个条件，之间是"或"的关系，意思是在15分钟(900秒钟)内有至少一个键被更改则进行快照，如要禁用自动快照，删除所有save参数即可
     Redis默认会将快照文件存储在当前目录的dump.rdb文件中
     快照的过程：
          (1)Redis使用fork函数复制一份当前进程(父进程)的副本(子进程)
          (2)父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘的临时文件
          (3)当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成
     新的RDB文件存储的是执行fork一刻的内存数据
     Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存
     通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据
持久化：AOP方式
     默认情况下Redis未开启AOF(append only file)方式的持久化
          appendonly yes
     开启AOF持入化后每执行一条会更改Redis中的数据的命令，Redis就会将该命讼写入硬盘中的AOF文件，位置和RDB相同，可设置，默认文件名是appendonly.aof
     AOF文件是纯文本文件，其内容正是Redis客户端向Redis发送的原始通信协议的内容
     每当达到一定条件时Redis就会自动重写AOF文件
     重写的过程只和内存中的数据有关，和之前的AOF文件无关，与RDB相似，不过二者的文件格式完成不同
     在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，速度相较RDB会慢 一些
     虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，30秒内异常退出会导致硬盘缓存中的数据丢失
     需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中
          appendsync always #everysec no
          默认采用everysec规则，即每秒执行一次同步操作，既兼顾了性能又保证了安全。always表示每次执行写入都会执行同步，这是最安全也是最慢的方式。no表示不主动进行同步操作，完全交由操作系统来做(即每30秒一次)，这是最快但最不安全的方式
     Redis允许同时开启AOF和RDB，既保证了数据安全双使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少
复制
     通过持久化功能，Redis保证了即使在服务器重启的情况下也不会损失(或少量损失)。为避免单点故障，将数据库复制多个副本以部回教晨不同的服务器上，Redis提供了复制(replication)功能可以自动实现同步的过程
配置
     同步后的数据库分为两类，一类是主数据库(master)，一类是从数据库(slave)。主数据库可以进行读写操作，当发生写操作时自动将数据同步给从数据库。而从数据库一般是只读的，并接受主数据库同步过来的数据。一主可有多从，一从只有一主
     可以通过设置从数据库的配置文件中的slave-read-only为no以使从数据库可写，但不会同步，被同步时会被覆盖
     如果已经是其他主数据库的从数据库了，SLAVEOF命令会停止和原来数据库的同步转而和新数据库同步。还可以使用SLAVEOF NO ONE来使当前数据库停止接收其他数据库的同步转成主数据库
原理
     当一个从数据库启动后，会向主数据库发送SYNC命令，主收到SYNC命令后会开始在后台保存快照(即RDB持久化的过程)，并将保存期间按收到的命令缓存起来，当快照完成后，Redis会将快照文件和所有缓存的命令发送给从。当主从数据库断开重连后会重新执行上述操作，不支持断点续传
     Redis服务器使用TCP协议通信
     从将收到的内容写入到硬盘上的临时文个把中，当写入完成后从会用该临时文件替换RDB快照文件，之后的操作就和RDB持久化时启动恢复的过程一样了
     需要注意的是在同步的过程中从数据库并不会阻塞，而是继续处理命令，默认用同步前的数据对命令进行响应。可以配置slave-server-stale-data参数为no使从在同步完成前对所有命令(除INFO和SLAVEOF)都回复错误
     之后主数据库的任何数据变化都会同步给从，同步肉容和Redis通信协议一样
     在复制过程中，快照无论在主还是从都起了很大的作用，只要执行复制就会进行快照，即使关闭RDB持久化。无论是否启用RDB，Redis在启动时都会尝试读取dir和dbfilename两个参数指定的RDB文件来恢复数据库
读写分离
     通过复制可以实现读写分离以提高服务器的负载能力
     可以通过复制功能建立多个从数据库，主只写，从只读
从数据库持久化
     持久化相对很耗时，为提高性能，可通过复制功能建立一个(或若干个)从数据库，并在从启用持久化，同时在主禁用持久化。当从崩溃时重启主会自动将数据同步过来，无需担心数据丢失。而当主崩溃时，需要在从中使用SLAVEOF NO ONE命令将从提升主继续服务，并在原来的主启动后使用SLAVEOF命令将其设置成新的主的从，即可将数据同步回来
安全
     提示：配置Redis复制的时候如果主设置了密，需要在从配置文件中通过masterauth参数设置主的密码，以使从连接主时自动使用AUTH命令认证
通信协议
     Redis通信协议是Redis客户端与Redis之间交流的语言，通信协议规定了命令和返回值的格式
     Redis支持两种通信协议，一种是二进制安全的统一请求协议，一种是比较直观的便于在telnet程序中输入的简单协议。这两钟协议只是命令的格式有区别，命令返回值的格式是一样的
     Redis的AOF文件和主从复制时主数据库向从数据库发送的内容都使用了统一请求协议。如果要开发一个和Redis直接通信的客户端，推荐使用此协议。如果只是想通过telnet向Redis服务器发送命令则使用简单协议就可以了
管理工具
redis-cli
     Redis自带的命令行客户端
     介绍几个管理Redis时非常有用的命令：
     1.耗时命令日志(slow log)
          slowlog-log-slower-than #命令执行时间限制，单位微秒，1000000微秒相当于1秒，默认10000
          slowlog-max-len #限制记录的条数
          >SLOWLOG GET
          每条日志都由以下4个部分组成：
          (1)该日志唯一ID
          (2)该令执行的UNIX时间
          (3)该命令的耗时时间，单位是微秒
          (4)命令及其参数
     提示：为了产生一些耗时命令日志作为演示，这里将时间设为0，即记录所有命令。如果设置为负数则会关闭耗时命令日志
     2.命令监控
          MONITOR命令来监控Redis执行的所有命令
          此时任何命令都会在redis-cli中打印，可打开另一个redis-cli
          MONITOR命令非常影响Redis的性能，一个客户端使用MONITOR命令会降低Redis将近一半的负载能力。所以只适合用来调试和纠错
phpRedisAdmin
     当Redis中键较多时，管理数据并不是很方便，如同管理MySQL时使用phpMyAdmin一样，Redis同样有一个PHP开发的网页端管理工具phpRedisAdmin。支持以树形结构查看键列表，编辑键值，导入/导出数据库数据，查看数据库信息和查看键信息等功能

</pre>
						</label>
					</label>
				</label>
				<label>《Redis实战》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-06 06:54:44
备注：看本书目的，了解Redis存储，使用Java API
进度：53/53

Redis是一个Key-Value存储系统
String(字符串)、Lists(列表)、Sets(集合)、Sorted sets(有序集合)、Hashes(哈希表)
大型互联网应用以及提供云计算服务时，保证系统在海量数据环境下的高性能、高可靠性、高扩展性、高可用性、低成本
Key-Value Store最大的特点就是它的可扩展性，也是最大的优势
Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多语言的API
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第一章 Redis快速入门】
Redis是一个Key-Value存储系统

string(字符串)、list(链表)、set(集合)和zset(有序集合)

和Memcached类似，区别是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步

大型互联网应用以及提供云计算服务时，保证系统在海量数据环境下的高性能、高可靠性、高扩展性、高可用性、低成本

Key-Value数据库分为很多种类，具体如下图：

Key-Value Store最大的特点就是它的可扩展性，也是最大的优势
所谓可扩展性，两方面，一是指可以支持极大的数据的存储，它的分布式架构决定了只要有更多的机器，就能够保证存储更多的数据。另一方面，可以支持数量很多的并发查询，RDBMS一般几百个并发查询就很吃力，而一个Key-Value Store可以很轻松的支持上千的并发查询
分布式：多台机器(nodes)同时存储数据和状态，彼此交换消息来保持数据一致，可视为一个完整的存储系统

Redis实际应用案例
目前全球最大的Redis用户是新浪微博，200多台物理机，400多个端口运行着Redis，+4G的数据跑在Redis上来为微博用户提供服务
在新浪微博Redis的部署场景大概分为如下两种：
第一种是应用程序直接访问Redis数据库
applications writes/reads redis server
第二种是应用程序直接访问Redis，只有当Redis访问失败时才访问MySQL
Applications&Queues
     --W/R-->redis server-->redisSDK-->MySQL
     --reads when redis miss-->MySQL

Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多语言的API。从2010年3月15日起，Redis的开发工作由VMvare主持

作为Key-Value型数据库，Redis提供了键和键值的映射关系
除了常规的数值或字符串
Redis的键值还可以是以下形式之一
Lists(列表)、Sets(集合)、Sorted sets(有序集合)、Hashes(哈希表)
可重复、不可重、不可重、不可重

持久化
通常，Redis将数据存储于内存中，或被配置为使用虚拟内存
两种方式实现数据持久化：
     使用截图方式，将内存中的数据不断写入磁盘
     使用类似MySQL的日志方式，记录每次更新的日志
前者性能较高，但是可能会引起一定程度的数据丢失;后者相反

主从同步
Redis支持将数据同步到多台从库上，这种特性对提高读取性能非常有益

适用场合
Redis开创了一种新的数据存储思路，使用Redis，我们不用在面对功能单调的数据库时，把精力放在如何把大象放进冰箱这样的问题上，而是利用Redis灵活多变的数据结构和数据操作，为不同的大象构建不同的冰箱。希望你喜欢这个比喻

取最新N个数据的操作
网站的最新文章，将最新的5000条评论的ID放在Redis的List集合中，并将超出集合部分从数据库获取
if id_list.length<num_items SQL_DB("select ... order by time limit ...")
 
排行榜应用，取TOP N操作
前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时用sorted set

下载
http://redis.io/download

将Redis作为Linux服务随机启动
>vi /etc/rc.local #使用vi编辑器打开随机动配置文件
/root/4setup/redis-2.2.12/src/redis-server

停止Redis实例
Ctrl+C
>src/redis-cli shutdown

警告
因为redis速度相当快，所以在一台比较好的服务器下，一个外部的用户可以在一秒钟进行150K次的密码尝试，这意味着你需要指定非常非常强大的密码来防止暴力破解

 maxmemory
设置redis能够使用的最大内存，当内存满了的时候，如果还接收到set命令，将先尝试剔除设置过expire信息的key，不管是否到达，按照过期时间进行删除，如果带有expire信息的key都删光了，那么将返回错误，不再接收写请求，只接收get请求。maxmemory的设置比较适合于把redis当作类似memcached的缓存来使用

hash-max-zipmap-entries
在redis 2.0中引入了hash数据结构

操作数据库
>set name wwl
>get name
>del name
>exists name

【第二章 Redis数据类型及操作】
解决复杂问题的方法就是让复杂问题永远不要提复杂的问题

Redis的作者antirez曾笑称Redis为一个数据结构服务器(data structures server)，我认为这是一个非常准确的表达，Redis的所有功能就是将数据以其固有的几种结构来保存，并提供给用户操作这几种结构的接口

strings类型及操作
string类型是二进制安全的
struct sdshdr{long len;long free;char buf[];};
数组长度
数组中剩余可用字节数
本质上就是个byte数组，可以包含任何数据
>set #设置key对应的值为string类型的value
>setnx #not exist，如果key已存在，返回0，本次修改不生效
>setex #设置值并指定此键值对应的有效期
     >set haircolor 10 red #haircolor=red，指定有效期10秒
>setrange #设置指定key的value值的子字符串
     >setrange name 8 gmail.com
     #从下标为9(包含8)的字符开始替换
>mset #一次设置多个key的值，成功返回ok表示都成功，失败返回0表示没有任何值被设置
>msetnx #一次设置多个key的值，失败时操作都会回滚，都不会被执行
>get #获取key对应的string值，如果key不存在返回null
>getset #设置key的值，并返回key的旧值，key不存在，返回null
>getrange #获取指定key的value值的子字符串
     >getrange name 0 6
     #字符串左面下标是从0开始的
     >getrange name -7 -1
     #字符口中 右面下标是从-1开始的
     #当下标超出字符串长度时，将默认为是同方向的最大下标
>mget #一次获取多个key的值，如果对应key不存在，则对应返回nil
>incr #对key的值加加操作，并返回新的值
     #注意incr一个不是int的value会返回错误
     #incr一个不存在的key，则设置key为1
>incrby #同incr类似，加指定值
     #key不存在时候会设置key，并认为原来的value是0
>decr #对key的值做的是减减操作
     #decr一个不存在的key，则设置key为-1
>decrby #同decr，减指定值
     #decrby完全是为了可读性，可以通过incrby一个负值来实现同样效果，反之一样
>append
     #给指定key的字符串值追加value，返回新字符串值的长度
>strlen #取指定key的value值的长度

hashes类型及操作
     Redis hash是一个string类型的filed和value的映射表
     hash特别适合用于存储对象，新建一个hash对象时开始是用zipmap(又称为small hash)来存储的，并不是hash table，相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销，如果filed或者value的大发出一定限制后，Redis会在内部自动将zipmap替换成正常的hash实现
     一个对象存储在hash类型中会占用更少的内存，并且更方便的存取整个对象
配置文件指定：
     hash-max-zipmap-entries 64 #配置字段最多64个
     hash-max-zipmap-value 512 #配置value最大为512字节
>hset #设置hash filed为指定值，如果key不存在，则先创建
>hsetnx #同上，如果filed已经存在，返回0，nx是not exist的意思
>hmset #同时设置hash的多个filed
     >hmset myhash filed1 Hello filed2 World
>hget #获取指定的hash filed，空则返回nil
>hmget #获取全部指定的hash filed
     >hmget f1 f2 f3
>hincrby #指定的hash filed加上给定值
>hexists #测试指定filed是否存在
>hlen #返回指定hash的filed数量
>hdel #删除指定hash的filed
>hkeys #返回hash的所有filed
>hvals #返回hash的所有value
>hgetall #获取某个hash中全部的filed及value

lists类型及操作
list是一个链表结构，主要功能是push、pop、获取一个范围的所有值等等，操作中key理解为链表的名字
Redis的list类型其实就是一个每个子元素都是string类型的双向链表。链表的最大长度是(2的32次方）。push,pop操作从头部或尾部添加删除元素。这使得list既可以用作栈，也可以用作队列
list的pop操作还有阻塞版本的，主要是为了避免轮询带来的延迟
     举个简的例子如果用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去获取任务这样就可以避免轮询去检查是否有任务存在。当任务来的时候工作线程可以立即返回，也可以避免轮询带来的延迟
>lpush #在key对应list的头部添加字符串元素
>rpush #在key对应list的尾部添加字符串元素
>linsert #在key对应list的特定位置之前或之后添加字符串元素
     >linsert mylist before "world" "there"
>lset #设置list中指定下标的元素值(下标从0开始)
     >rpush mylist "one"
     >rpush mylist "two"
     >rpush mylist "three"
     >lset mylist 0 "four"
     >lset mylist -2 "five"
     >lrange mylist 0 -1 #"four""five""three"
>lrem #从key对应list中删除count个和value相同的元素
     #count>0时，按从头到尾的顺序删除
          >lrem mylist 2 "hello"
     #count<0时，按从尾到头的顺序删除
          >lrem mylist -2 "hello"
     #count=0，删除全部
>ltrim #保留指定key的值范内的数据
     >ltrim mylist 1 -1 #去第一个
     >ltrim mylist -1 0 #全删
>lpop #从list的头部删除元素，并返回删除元素
>rpop #从list的尾部删除元素，并返回删除元素
>brpop #接收两个参数，键名和超时时间，单位秒 超过时间仍没获得新元素就返回nil，0表式不限制等待的时间，永远阻塞
>blpop
>rpoplpush #从第一个list的尾部移除元素并添加到第二个list的头部
     #最后返回被移除的元素值，整个操作是原子的
     #如果第一个list是空或者不存在返回nil
     >rpoplpush mylist1 mylist2
>lindex #返回名称为key的list中index位置的元素
>llen #返回key对应的list的长度
my test
#list #userlist 01 02 03 04 #list只存id
#string #user:id:01 user:id:02 user:id:03 user:id:04
#hash #user:01 user:02 user:03 user:04 #设置name属性
>sort userlist by * get user:id:* get # alpha
>sort userlist get user:*->name
#*代表了list中的元素值，返回的排序后list集合中的元素
#get操作可以将list中的值与pattern组成新的key，用该新key去获取出来的list长度个数的值进行排序(排序是排列的get出的值，而不是list中的值)，如果用新组成的key不存在，则返回(nil)
#get返回的是数组中的元素用key对应的string类型的值
#"#"特殊符号引用的是原始集合也就是list
#[LIMIT start count] 限定返回结果的数量，下标从0开始，获取n个
#[STORE dstkey] 如果对集合经常按照固定的模式排序，把结果缓存可减少CPU开销，将内容保存到指定key中，类型是list

sets类型及操作
set是集合
对集合的操作有添加删除元素，有对多个集合求交并差等操作，操作中key理解为集合的名字
set是通过hash table实现的，所以添加、删除和查找的复杂度都是0(1)，hash table会随着添加或者删除自动的调整大小
需要注意的是调整hash table大小时候需要同步(获取写锁)会阻塞基他读写操作，sorted set中已使用了跳表(skip list)来实现
集合的取并集(union)，交集(intersection)，差集(difference)
>sadd #向名称为key的set中添加元素
>smembers #查看名称为key的set中所有元素
>srem #删除名称为key的set中的元素member
>spop #随机返回并删除名称为key的set中一个元素
>sdiff #返回所有给定key与第一个key的差集
     #后者相对前者没有的元素
     #集合A-集合B，代表属于A且不属于B
     >smembers myset1 #23
     >smembers myset2 #12
     >sdiff myset1 myset2 #3
     >sdiff myset2 myset1 #1
     #这个结果中只显示了，myset2中元素与myset1中不同的元素
>sdiffstore #返回所有给定key与第一个key的差集，并将结果存为另一个key
     >sdiffstore myset_new myset1 myset2
     >smembers myset_new #3
>sinter #返回所有给定key的交集
>sinterstore #返回所有给定key的交集，并将结果存为另一个key
>sunion #返回所有给定key的并集
>sunionstore #返回所有给定key的并集，并将结果存为另一个key
>smove #从第一个key对应的set中移除member并添加到第二个对应set中
     >smove myset_old myset_new three
     >smembers myset_new
>scard #返回名称为key的set的元素个数
>sismember #测试member是否是名称为key的set的元素
>srandmember #随机返回名称为key的set的一个元素，但是不删除元素

sorted sets类型及操作
sorted set是set的一个升级版本，在set的基础上增加了一个顺序属性，这一属性在添加修改元素的时候可以指定，每次指定后，zset会自动重新按新的值调整顺序
可以理解为有两列的mysql表，一表存value，一列存顺序
操作中key理解为zset的名字
也是string类型元素的集合，不同的是每个元素都会关联一个double类型的score
sorted set的实现是skip list和hash table的混合体
sorted set最经常的使用方式应该是作为索引来使用，把要排序的字段作为score存储，对象的id当元素存储
>zadd #向名称为key的zset中添加元素member，score用于排序
     #如果该元素已存在，则根据score更新该元素的顺序
     >zadd myzset 1 "one"
     >zadd myzset 2 "one"
     >zrange myzset 0 -1 withscores #"one""3"
>zrem #删除名称为key的zset中的元素member
>zincrby #如果在名称为key的zset中已经存在元素member，则该元素的score增加increment，否则向集合中添加该元素，其score的值为increment
     >zadd myzset 1 "one"
     >zincrby myzset 2 "one"
     >zrange myzset 0 -1 withscores #"one""3"
>zrank #返回名称为key的zset中member元素的排名(按score从小到大排序)即下标
     #返回的是下标，而不是score，从零开始的排名
>zrevrank #返回名称为key的zset中member元素的排名(按score从大到小排序)即下标
     #按从大到小排序的话是第n个元素，下标是n-1
>zrevrange #返回名称为key的zset(按score从大到小排序)中的index从start到end的所有元素
     >zrevrange myzset 0 -1 withscores
     #首先按score从大到小排序，再取出全部元素
>zrangebyscore #返回集合中score在给定区间的元素
     >zrangebyscore myset 2 3 withscores
     #本例中，返回了score在2~3区间的元素
>zcount #返回集合中score在给定区间的数量
     >zcount myzset 2 3
>zcard #返回集合中元素个数
>zscore #返回给定元素对应的score
     >zscore myzset two
>zremrangebyrank #删除集合中排名在给定区间的元素
     >zremrangebyrank myzset 3 3
     #将myzset中按从小到大排序结果的下标为3的元素删除了
>zremrangebyscore #删除集合中score在给定区间的元素
     >zremrangebyscore myzset 1 2
     #将myzset中按从小到大排序结果的score在1~2之间的元素删除了

【第三章 Redis常用命令】
键值相关命令
>keys #返回满足给定pattern的所有key
     >keys * #用表达式*，代表取出所有的key
     >keys mylist* #代表取出所有以mylist开头的key
>exists #确认一个key是否存在
>del #删除一个key
>expire #设置一个key的过期时间(单位：秒)
     >expire addr 10
     >ttl addr #TTL(Time To Life)命令，返回值是键的剩余时间(单位是秒)
     #当键不存在时TTL命令会返回-1，另外同样会返回-1的情况是没有为键设置生存时间(即永久存在，这是建立一个键后的默认情况)
     #-2键不存在;-1没有过期时间,永久数据;有过期时间返回剩下的时限
     #EXPIRE的seconds参数必须是整数，最小单位是1秒，如想更精确应该用PEXPIRE，唯一区别是前者时间单位是毫秒，即PEXPIRE key 1000与EXPIRE key 1等价，对应的可以用PTTL以毫秒为单位返回键的剩余时间
     提示：如果使用WATCH命令监测了一个拥有生存时间的键，该键时间到期自动删除并不会被WATCH命令认为该键被改变
     #EXPIREAT 使用Unix时间作为第二个参数表示键的生存时间的截止时间
          >EXPIREAT foo 1351858600
     #PEXPIREAT 同上，时间单位是毫秒
>move #将当前数据库中的key转移到其它数据库中
     >move age 1
     >select 1
     >get age
>persist #移除给定key的过期时间
     #取消键的生存时间设置(即将键恢复成永久的)
     #生存时间被成功清除返回1，否则返回0(因为键不存在或键本来就是永久的)
     #使用SET或GETSET赋值会同时清除生存时间，EXPIRE重新设置生存时间，其他只对键值进行操作的命令均不会影响键的生存时间
>randomkey #随机返回key的一个key
>rename #重命名key
>type #返回值的类型
服务器相关命令
>ping #测试连接是否存在
>echo #在命令行打印一些内容
>select #选择数据库，Redis数据库编号从0~15
>quit #退出连接
>dbsize #返回当前数据库中key的数目
>info #获取服务器的信息和统计
>monitor #实时转储收到的请求
>config get #获取服务器配置信息
     >config get dir
     >config get *
>flushdb #删除当前选择数据库中的所有key
>flushall #删除所有数据库中的所有key

</pre>
						</label>
					</label>
				</label>
				<label>《HBase实战》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-10-24 01:50:39
备注：看本书目的，搭建HBase集群，使用Java API
进度：341/341

HBase列式数据库， MySQL关系型数据库，有时也把HBase称为无模式数据库
用一种根本上不同的方式来考虑数据，从如何驱动商业价什的角度来考虑数据，这种数据就是大数据
Google发表了Google文件系统(Google File System)、MapReduce的论文和BigTable的论文
2007年，发布了实验性代码，开源的BigTable，称其谓HBase
HBase可以以3种模式运行：单机、伪分布式和全分布式
     单机意味着在一个Java进程里运行HBase的全部内容
     伪分布式模式需要在一台机器上运行多个Java进程
     全分布模式需要一个服务器集群
HBase面向半结构化数据，在半结构化逻辑模型里数据构成是松耦合的，有利于物理分散存放，这点也影响了逻辑模型。这种物理模型设计迫使HBase放弃了一些关系型数据库具有的特性，不能实施关系约束(constraint)并且不支持多行事务(multirow transaction)
HBase使用坐标系统来识别单元里的数据:[行键,列族,列限定符,时间版本]
ZooKeeper是一种高可用的、可靠的分布式配置服务
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【第一部分 HBase基础】
【第1章：HBase介绍】
     HBase列式数据库， MySQL关系型数据库
     用一种根本上不同的方式来考虑数据，从如何驱动商业价什的角度来考虑数据，这种数据就是大数据
     Google发表了Google文件系统(Google File System)、MapReduce的论文和BigTable的论文
     2007年，发布了实验性代码，开源的BigTable，称其谓HBase
     当工具崩溃时，会以Bug报告的形式返回一个软件崩溃报告，需要一个系统收集这些报告，用来指导研发部门研制更稳定的产品
     HBase可以以3种模式运行：单机、伪分布式和全分布式
     单机意味着在一个Java进程里运行HBase的全部内容
     伪分布式模式需要在一台机器上运行多个Java进程
     全分布模式需要一个服务器集群
     HHbase基要下用Java编写，只有几个部件不是
     HBase有两种方式读取数据：get和scan
     scan命令非特别指定，返回表里的所有行
【第2章：入门】
     整个Hadoop系列，包括HBase，都使用Java。HBase客户端函数库是Java，MapReduce函数库也是Java
     HBase中的表必须至少有一个列族，列族直接影响HBase数据存储的物理特性
     describe命令可以看到表的所有的默认参数:describe 't1'
     和数据操作有关的HBase API称为命令(command)。有5个基本命令用来访问HBase，Get(读)、Put(写)、Delete(删除)、Scan(扫描)和Increment(递增)
     为了存储数据，需创建一个Put实例，不能直接存储字符串，HBase中所有数据都是作为原始数据(raw data)使用字节数组的形式存储的
     HBase使用坐标来定位表中的数据，行键、列族、列限定符(列或标志)。因为HBase是无模式的，不需事先定义列限定符或设定数据类型，它们是动态的。表中确定一个单元的坐标是[rowkey,column family,column qualifier]
     写操作会写入预写式日志(WAL)和称为MemStore的内存写缓冲区。客户端在写的过程中不会与底层的HFile直接交互
     当MemStore写满时，会刷写到硬盘，生成一个新HFile，HFile是HBase使用的底层存储格式。HFile对应于列 族，一个列族可以有多个HFile，但一个HFile不能存储多个列族的数据。在集群的每个节点上，每个列族有一个MemStore。
     数据模型
     HBase在表里存储数据使用的是四维坐标系统
     关系型数据库围绕表、列和数据类型——数据的形态使用严格的规则。遵守这些严格规则的数据称为结构化数据
     HBase设计上没有严格形态的数据，可能包含不一致的列、不确定的大小等，这种数据称为半结构化数据
     HBase面向半结构化数据，在半结构化逻辑模型里数据构成是松耦合的，有利于物理分散存放，这点也影响了逻辑模型。这种物理模型设计迫使HBase放弃了一些关系型数据库具有的特性，不能实施关系约束(constraint)并且不支持多行事务(multirow transaction)
     HBase中使用的逻辑数据模型有许多有效的描述，图2-6把这个模型解释为键值数据库
     HBase使用坐标系统来识别单元里的数据:[行键,列族,列限定符,时间版本]
     HBase按照时间戳降序排列各时间版本，所以最新数据总是在最前面，其他的映射键按照升序排列
     物理模型：面向列族
     每个列族在硬盘上有自己的HFile集合，HFile自身是二进制文件，文件里没有空记录(null)，如果没有数据，HBase不会存储任何东西。因此列族的存储是面向列的
     一行中一个列族的数据不一定存放在同一个HFile里，唯一的要求是，一行中列族的数据需要物理存放在一起
     每个列族使用自己的HFie意味着，当执行读操作时HBase不需要读出一行中所有的数据，只需要读取用到列族的数据。面向列意味着当检索指定单元时，HBase不需要读占位符记录。这两个物理细节有利于稀疏数据集合的高效存储和快速读取
     HBase管理整行的工具，HBase称这种机制为region
     表中某行的所有数据在一个region里管理
     没有查询(query)命令，查找某个特定值的记录唯一方法是，使用扫描命令读出表的某些部分，然后再使用过滤器来得到有关记录。扫描返回的记录是排好序的，HBase设计上支持这种方式，因此速度很快
     MD5是一种单向散列算法
    小结：
     HBase是一种专门为半结构化数据和水平可扩展性设计的数据库，无类型数据库，无模式数据库
     有5个基本命令用来访问HBase中的数据，即Get、Put、Delete、Scan和Increment。基于非行键值查询HBase的唯一办法是通过带过滤器的扫描
【第3章：分布式的HBase、HDFS和MapReduce】
1.切分和分配大表
     和其他数据库一样，HBase中的表也由行和列组成，表可达数十亿行和数百万列。表大小可达TB级甚至PB级，显然不可能在一台机器上存放整个表。
     表会切分成小的数据单位，分配到多台服务器，数据单位叫region，托管region的服务器叫RegionServer
     RegionServer和HDFS DataNode内型情况下并列配置在同一物理硬件上
     单个region大小由hbase-site.xml文件的配置参数HBase.hregion.max.filesize决定，当一个region大小大于该值，分切分成两个region
2.如何找到region
     HBase中两个特殊表，-ROOT-和.META.，用来查找各种表的region位置在哪里
     -ROOT-永远不会切分超过一个region，.META.和其他表一样可以按需要切分成许多region
     访问某行时，先找-ROOT-表，查找负责某行的region，-ROOT-指向.META.表的region，由入口地址判断托管的RegionServer。查找过程像一个3层分布式B+树
3.如何找到-ROOT-表
     ZooKeeper是一种高可用的、可靠的分布式配置服务
     HBase模仿了Google的BigTable，ZooKeeper模仿Google的Chubby
     客户端与HBase系统的交互步骤：
【第二部分 高级概念】
【第4章：HBase表设计】
1.如何开始模式设计
     有时也把HBase称为无模式数据库
     提示：HBase没有跨表或跨行事务的概念，请避开在客户端代码里需要事务逻辑的设计，因为这会让你不得不维护复杂的客户端
     客户端寻找正确的RegionServer和region，花费3次固定运算找到正确的region-查找ZK，查找-ROOT-，查找.META.。这是一次O(1)运算
     O(n)称为渐进标记，O(n)表示该算法的时间复杂度随着n的大小线性增长，O(1)意味着无论输入的大小，该算法的运行在固定的时间内完成。关于渐进表示的启蒙读物，参见http://mng.bz/4GMf
     可以在http://en.wikipedia.org/wiki/Skip_list了解更多关于跳表的信息
     散列和MD5：散列函数是把变长的巨大数值映射到定长的小数值上的一种函数
     KeyValue对象的结构
          键：行键、列族、列限定符、时间戳；值：单元值
                              行键     列族     列限定符     时间戳
          限制行            1          0               0               0
          限制               1          1               0               1
          限制硬盘IO     1          1               0               1
          限制网络IO     1          1               1               1
     索引建立在KeyValue对象的Key部分上，Key由行键、列限定符和时间戳按次序组成
     散列支持定长键和更好的数据分布，但是失去了排序的好处
2.反规范化是HBase世界里的词语
     规范化和反规范化
          规范化：关系型数据库世界的一种技术，每种重复信息都放进一个表，更新时，保存单一副本而不是多个副本，减少空间占用，查询时，在SQL中使用JOIN子句重新联结这个数据
          反规范化：数据是重复的，存在多个地方，查询更容易、更快
          从性能观点看，规范化为写做优化，而反规范化为读做优化
          前者读取时付出联结数据的开销，后者写入时付出多个副本的开销
3.行键设计策略
     关系型数据库可以在多个列上建立索引，但HBase只能在键上建立索引
4.从关系型到非关系型
     一些基本概念
          关系型数据库建模3个主要概念：实体(映射到表)、属性(映射到列)、联系(映射到外键)
     (没有)索引，在关系型数据库中，很容易声明索引并且由数据库引擎自动维护，这种能力是关系型数据库提供的最有吸引力且最有用的功能之一。在HBase中直到现在，问题的答案是：很不幸，HBase没有索引。可以过通反规范化处理数据和写入多张表来获得这个特性的一些近似方法
【第5章 使用协议处理器扩展HBase】
【第6章 其他HBase客户端选择】
1.Java是Hadoop产品家族DNA的核心部分
     HBase Shell作为HBase默认安装的一部分随机预装
【第三部分 应用系统实例】
【第7章 通过实例学习HBase：OpenTSDB】
【第8章 在HBase上查询地理信息系统】
1.Guava是Java里漏掉的utils library。如果你是一个专业的Java开发员但从没有研究过它，你就错过好东西了。在wiki上有一个细致的介绍：http://mng.bz/ApbT
【第四部分 让HBase运转起来】
【第9章 部署HBase】
1.配置
     -Xmx8g #设置进程的最大堆空间
     -Xms8g #设置初始堆大小
     -Xmn128m #设置年轻代大小
     -XX:+UseParNewGC #设置垃圾回收器对年轻代使用并行收集器，这种收集器会暂停Java进程，然后进行垃圾回收，因为年轻代比较小，并且进程不会停止很长时间(通常几毫秒)，这种工作模式对它是可接受的。这种暂停有时也被称为stop-the-world垃圾回收暂停
     -XX:+UseConcMarkSweepGC #因年老代空间比年轻代大，并行垃圾收集器不合适。对年老代来说，stop-the-world垃圾回书要持续几秒，会导致超时。CMS垃圾回收和其他任务在JVM中并行进行，不会暂停进程
     -XX:CMSInitiatingOccupancyFraction
     hbase.zookeeper.quorum #HBase集群中的所有组件都需要知道哪些服务器构成Zookeeper quorum，该配置参数就是放置这个信息的地方
     hbase.roodir #HBase在HDFS上持久化存储它的数据，使用该参数明确地配置数据的存储位置
     hbase.cluster.distributed #HBase可以运行在单机模式，伪分布模式或完全分布式模式下。单机模式和伪分布模式只用于测试和研究，不能用于生产环境
【第10章 运维】
1.监控指标框架涉及两部分功能——收集(collection)和图形展示(graphing)
     Ganglia(原生支持Hadoop的监控指标框架)或者一些通过JMX收集监控指标信息的框架
     Ganglia是一种被设计用来监控集群的分布式监控框架
     它是在加州大学伯克利分校开发的开源项目
     Hadoop和HBase社区一直使用它作为监控集群的业界标准方案
2.通用监控指标
     HDFS吞吐量和延迟
     HDFS使用情况
     存储硬盘的吞吐量
     每个节点的网络吞吐量和延迟
【附录A 探索HBase系统】
A.1 探索ZooKeeper
     >./hbase shell
     >zk_dump
          #输出ZooKeeper记录的关于HBase安装的信息
          #显示该HBase安装的父znode
          #显示当前一切都以单机模式运行在本机上，包括HBase master
          #为-ROOT-表提供服务的RegionServer
          #Zookeeper保存组成集群的RegionServer列表。当RegionServer上线时会到ZooKeeper里登记
A.2 探索-ROOT-
     >scan '-ROOT-'
          #-ROOT-表存储了关于.META.表的相关信息
A.3 探索.META.
【附录B 更多关于HDFS的工作原理】
B.1 分布式文件系统
B.2 分离元数据和数据：NameNode和DataNode
B.3 HDFS写过程
B.5 HDFS读过程
B.4 通过副本快速恢复硬件故障
     当一切运行正常时，DataNode会周期性发送心跳信息给NameNode(默认是每3秒钟一次)。如果NameNode在预定的时间内没有收到心跳信息(默认是10分钟)，它会认为DataNode出问题了，把它从集群中移除，并且启动一个进程去恢复故障
     当一个硬盘故障时，HDFS会检测到存储在该硬盘的数据块的副本数量低于要求，然后主动创建需要的副本，以达到满副本数状态
B.6 跨多个DataNode切分文件
【关于封面插图】
     利布尔尼亚渔妇，亚得里亚海东北的沿海地区，属于今天的克罗地亚
     Hacquet是奥地利医生和科学家，所用其著作插图
     地区的独特性和个性
     用两个世纪前的服装作为书的封面，借此颂扬计算机行业中的创新精神、主动精神和趣味性
</pre>
						</label>
					</label>
				</label>
				<label>《大数据面试宝典》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-19 04:04:05
备注：看本书的目的，报着试试看的心态，233
进度：178/178
备注：题目看的懂，答案看不懂 T_T

DataNode程序负责HDFS数据存储
Hadoop集群分析：
	Hadoop的集群是基于master/slave模式，namenode和jobtracker属于master,datanode和tasktracker属于slave,master只有一个，而slave有多个
集群的最主要瓶颈是：磁盘IO
Hadoop是R语言开发的
Hadoop不支持数据的随机读写，Lucene支持随机读写，而HDFS只支持随机读。HBase提供随机读写
Hadoop只能阻止好人犯错，但是不能阻止坏人干坏事
进程间几种通信方式？？？？？
求二叉树的最大距离(即相距最远的两个叶子节点)，写代码？？？？？
求二叉树的宽度，先简介思路再写代码？？？？？
打印二叉树两个子节点间的路径，写代码？？？？？
JVM的结构和类加载原理？？？？？
classloader的双亲代理机制？？？？？
Struts漏洞，Hibernate是安全的吗？？？？？
NIO是否了解，阻塞之后通知机制是怎样的？？？？？
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
【知识点】
1.Hashmap、Hashtable和concurrentHashMap的区别，各自的实现原理
Hashmap的扩容机制、concurrentHashMap的桶分割原理、多线程安全性？？？？？
2.JVM内存模型与GC内存回收机制
3.JVM内存调优
4.classloader的双亲代理机制？？？？？
5.servlet/filter作用原理配置
6.Spring aop用了什么设计原则，自动注入配置是做什么用的
7.session共享机制
8.NIO是否了解，阻塞之后通知机制是怎样的？？？？？
9.HTTP协议，返回码，301与302区别？？？？？
10.hadoop中，有哪些地方使用了缓存机制，作用分别是什么
11.DataNode程序负责HDFS数据存储
12.JobTracker程序通常与NameNode在一个节点启动
13.Hadoop集群分析：
     Hadoop的集群是基于master/slave模式，namenode和jobtracker属于master,datanode和tasktracker属于slave,master只有一个，而slave有多个
     SecondaryNameNode内存需求和NameNode在一个数量级上，所以通常secondary NameNode(运行在单独的物理机器上)和NameNode运行在不同的机器上
     JobTracker和TaskTracker
JobTracker对应于NameNode
TaskTracker对应于DataNode
DataNode和NameNode是针对数据存放而言的
JobTracker和TaskTracker是针对于MapReduce执行而言的
     mapreduce中几个主要概念，mapreduce整体上可以分为这么几条执行线索
mapreduce,JobTracker与TaskTracker
(1)JobClient会在用户端通过JobClient类将应用已经配置参数打包成jar文件存储到hdfs，并把路径提交到Jobtracker，然后由JobTracker创建每一个Task(即MapTask和ReduceTask)，并将它们分发到各个TaskTracker服务中去执行
(2)JobTracker是一个master服务，软件启动之后JobTracker接收Job，负责调度Job的每一个子任务task运行于TaskTracker上，并监控它们，如果发现有失败的task就重新运行它。一般情况应该把JobTracker部署在单独的机器上
(3)TaskTracker是运行在多个节点上的slaver服务。TaskTracker主动与JobTracker通信，接收作业，并负现直接执行每一个任务
TaskTracker都需要运行在HDFS的DataNode上
14.Hadoop作者：Doug cutting
15.集群的最主要瓶颈是：磁盘IO
     集群的目的是为了节省成本，用廉价的pc机，取代小型机及大型机
     小型机和大型机特点：
          cpu处理能力强
          内存够大
          网络是一种稀缺资源，但并不是瓶颈
          由于大数据面临海量数据，读写数据都需要io，然后还要冗余数据，hadoop一般备3份数据，所以IO就会打折扣
     可以把IO理解为水的管道，管道越大越强，对于T级的数据读取就越快，所以IO的好坏，直接影响了集群对于数据的处理
16.SecondaryNameNode：目的是帮助NameNode合并编辑日志，减少NameNode启动时间
17.Hadoop是R语言开发的
18.Hadoop不支持数据的随机读写
     Lucene支持随机读写，而HDFS只支持随机读。但是HBase可以来补救
     HBase提供随机读写，来解决Hadoop不能处理的问题。HBase自底层设计开始即聚焦于各种可伸缩性问题：表可以很"高"，有数十亿个数据行；也可以很"宽"，有数百万个列；水平分区并在上千个普通商用机节点上自动复制。表的模式是物理存储的直接反映，使系统有可能提高高效的数据结构的序列化、存储和检索
19.Hadoop只能阻止好人犯错，但是不能阻止坏人干坏事
20.>hadoop dfsadmin -report
     #命令用于快速定位出哪些节点down掉了，HDFS的容量以及使用了多少，以及每个节点的硬盘使用情况
21.进程间几种通信方式？？？？？
22.求二叉树的最大距离(即相距最远的两个叶子节点)，写代码？？？？？
求二叉树的宽度，先简介思路再写代码？？？？？
打印二叉树两个子节点间的路径，写代码？？？？？
23.多线程的适用场景是什么？为啥要用多线程？？？？？？
24.LSM含义：日志结构合并树？？？？？
25.JVM的结构和类加载原理？？？？？
26.Struts漏洞，Hibernate是安全的吗？？？？？
27.Hadoop运行的原理：
     Hadoop主要由三方面组成
     1.HDFS
     2.MapReduce
     3.HBase
     简单一句话解释MapReduce就是"任务的分解与结果的汇总"
     Map(展开)：就是将一个任务分解成为多个任务
     Reduce：就是将分解后多任务处理的结果汇总起来，得出最后的分析结果
     我一直认为Hadoop的卡通图标不应该是一个小象，应该是蚂蚁，分布式计算就好比蚂蚁吃大象，廉价的机器群可以匹敌任何高性能的计算机，纵向扩展的曲线始终敌不过黄向扩展的斜线
     MapReduce框架由一个单独的master JobTracker和每个集群节点一个slave TaskTracker共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务，而slave仅负责执行由master指派的任务
28.HDFS存储的机制：
     HDFS的三个实体
     数据块
          磁盘块一般为512字节，HDFS也有块的概念，默认为64M(一个map处理的数据大小)。HDFS上的文件也被划分为块大小的多个分块，与其他文件系统不同的是，HDFS中小于一个块大小的文件不会占据整个块的空间
     NameNode节点
          NameNode管理HDFS文件系统的命名空间，维护着文件系统树及整棵树的所有的文件及目录
     DataNode节点
          DataNode是HDFS文件系统的工作节点，根据需要存储并检索数据块，受NameNode节点调度，并定期向NameNode发送它们所存储的块的列表
29.只要你想抱怨，那就总会有可抱怨的东西。这点起源于人思维的善变以及欲望的无边界特质
30.Java实现非递归二分法算法？？？？？
31.Hive是Hadoop家族成员，是一种解析like sql语句的框架。它封装了常用MapReduce任务，让你像执行sql一样操作存储在HDFS的表
     Hive的表分为两种：内表和外表
32.数据倾斜？？？？？
</pre>
						</label>
					</label>
				</label>
				<label>HBASE完全分布式搭建</label>
				<label>
					<label>搭建步骤及配置文件</label>
					<label>
						<label>
<pre>
<xmp>
Hadoop+Zookeeper+HBase完全分布式集群搭建

【注意】
	1.HBase简述：HBase在表里存储数据使用的是四维坐标系统(行键-rowkey、列族-column family、列限定符column qualifier、时间版本version)
	2.若是虚拟机环境，虚拟机安装，各机器网络配置自行百度
	3.我用的超极本，内存有限，只搭了三台(三台是最低配，挂一台集群就挂了)，如果内存够大的话，最好搭7台，一主6从
	4.报错首先看对应的目录下log日志文件，用关键字上网查方法
	5.所有命令都在hadoop00上操作，另两台机器直接复制过去即可，Zookeeper的myid文件注意别忘修改
	6.目前测试环境用的这个集群，Java API比较简单，别引错Jar包，要对应版本
		#配置文件若写的域名，别忘改hosts
		#Java API调用10s没反应就是连不上了(不会报错，引错Jar包也没反应)
【一、安装前准备及环境】
1.所用tar包及版本：
	hadoop-2.2.0.tar.gz
	zookeeper-3.4.6.tar.gz
	hbase-0.98.23-hadoop2-bin.tar.gz
Hadoop2.x版本对应的HBase版本是0.98，zookeeper版本没要求，JAVA API引jar包时注意版本，否则连接不上
Hadoop1.x版本的搭建就不写了，对应的HBase版本是0.94，zookeeper版本没要求
Linux环境需求：
	JDK，自行百度
	DNS域名解析hosts文件
2.本人环境目录：
	JDK
		文件目录：/etc/profile
		内容：
			export JAVA_HOME=/home/work/jdk
			export PATH=$PATH:$JAVA_HOME/bin:
			export CLASSPATH=.:$CLASSPATH:$JAVA_HOME/lib
	hosts
		文件目录：/etc/hosts
		内容：
			192.168.10.10 hadoop00
			192.168.10.11 hadoop01
			192.168.10.12 hadoop02
	软件安装路径：
		/home/work
【二、安装及配置】
1.解压tar包，改文件名，注意权限(我用的root，最好创建一个用户，给文件夹添加这个用户的权限)
	>cd /home/work
	>tar -zxvf hadoop-2.2.0.tar.gz
	>mv hadoop-2.2.0.tar.gz hadoop
	>tar -zxvf zookeeper-3.4.6.tar.gz
	>mv zookeeper-3.4.6.tar.gz zookeeper
	>tar -zxvf hbase-0.98.23-hadoop2-bin.tar.gz
	>mv hbase-0.98.23-hadoop2-bin.tar.gz hbase
2.配置文件
	篇幅较大，放在最后
3文件夹准备(没有就创建，在配置文件中指定的，可修改)
	Hadoop：
		/home/work/data/hadoop/dfs/data
		/home/work/data/hadoop/dfs/name
		/home/work/data/hadoop/pids
		/home/work/data/hadoop/tmp
	Zookeeper：
		/home/work/data/zookeeper/data
			注意：在此data文件夹里创建myid文件，写机器ID。如：hadoop00这台机器写1，hadoop01这台机器写2，hadoop02这台机器写3(在Zookeeper配置文件中指定，可修改)
		/home/work/data/zookeeper/datalog
	HBase：
		/home/work/data/
4.启动前检查
	>df -h
		#检查磁盘空间占用情况
	>date
		#查看三台服务器时间是否一致
	#不一致的话，用下面命令改成一致，如果报错，自行百度
	>rdate -s 210.72.145.44
		#网络时间同步命令 中国国家授时中心 NTP服务器
5.多台机器之间免密钥登录
	>cd .ssh
	>ssh-keygen -t rsa
		#一路回车即可
	>cat id_rsa.pub >> authorized_keys
	>scp authorized_keys  root@hadoop01:/root/.ssh/
	>scp authorized_keys  root@hadoop02:/root/.ssh/
	>ssh root@hadoop01
		#登录成功，配置成功。如果还提示输入密码，配置失败
6.注意
	启动顺序：Hadoop->Zookeeper->HBase
	关闭顺序：HBase->Zookeeper->Hadoop
【三、启动集群】
1.Hadoop格式化文件系统
	>/home/work/hadoop/bin/hadoop namenode -format
	注意：如果以安全模式启动运行时会报错，不是可忽略
		离开安全模式
		>/home/work/hadoop/bin/hadoop dfsadmin -safemode leave
2.启Hadoop
	>/home/work/hadoop/sbin/start-all.sh
	#稍等一会儿，输入jps查看进程
		#hadoop00机器
			>jps
			#NameNode、SecondaryNameNode、RedourceManager
		#hadoop01机器
			>jps
			#DataNode、NodeManager
		#hadoop02机器
			>jps
			#DataNode、NodeManager
	#看到这五个进程，Hadoop启动成功
3.启Zookeeper
	>/home/work/zookeeper/bin/zkServer.sh start
	>jps
		#QuorumPeerMain
		#看到此进程，Zookeeper启动成功
	>/home/work/zookeeper/bin/zkServer.sh status
		#查看当前机器是leader还是follower(只有一个leader，主挂了，一个从会升为主，三台是最低配)
4.启HBase
	>/home/work/hbase/bin/start-hbase.sh
		#可查看日志，看有无报错，日志目录默认：/home/work/hbase/log/
5.连接HBase
	>/home/work/hbase/bin/hbase shell
	#注意：命令敲错不能删除，可在连接软件中配置，我用的SecureCRT，选项-终端-仿真-映射键，把勾勾掉，记不清了，自行百度吧
	>list
		#查看数据库
	>status
		#查看机器状态
	>help
		#查看帮助
	>create 'tab1','cf1'
		#创建一个表，有一个列族
	>put 'tab1','rk1','cf1:name','zhang'
		#存入tab1表，rk1行键，cf1列族，name列的值
	>get 'tab1','rk1'
		#查看某一行键
	>scan 'tab1'
		#扫描全表
	>disable 'tab1'
		#屏蔽表(或叫禁用表)
	>drop 'tab1'
		#删除表(必须先屏蔽表再行)
【四、关闭集群】
1.关HBase
	>/home/work/hbase/bin/stop-hbase.sh
2.关Zookeeper
	>/home/work/zookeeper/bin/zkServer.sh stop
3.关Hadoop
	>/home/work/hadoop/sbin/stop-all.sh
【补允：配置文件】
1.hadoop-6个
	我的hadoop配置文件在 /home/work/hadoop/etc/hadoop/ 里面
	(1/6)core-site.xml
		<configuration>
			<property>
				<name>fs.defaultFS</name>
				<value>hdfs://hadoop00:9000</value>
				<description>The name of the default file system.Either the literal string "local" or a host:port for NDFS.</description>
				<final>true</final>
			</property>
			<property>
				<name>io.file.buffer.size</name>
				<value>131072</value>
			</property>
			<property>
				<name>hadoop.tmp.dir</name>
				<value>file:/home/work/data/hadoop/tmp</value>
				<description>Abase for other temporary directories.</description>
			</property>
		</configuration>
	(2/6)hdfs-site.xml
		<configuration>
			<property>
				<name>dfs.namenode.secondary.http-address</name>
				<value>hadoop00:9001</value>
			</property>
			<property>
				<name>dfs.namenode.name.dir</name>
				<value>file:/home/work/data/hadoop/dfs/name</value>
				<description>Determines where on the local filesystem the DFS name node should store the name table.If this is a comma-delimited list of directories,then name table is replicated in all of the directories,for redundancy.</description>
				<final>true</final>
			</property>
			<property>
				<name>dfs.datanode.data.dir</name>
				<value>file:/home/work/data/hadoop/dfs/data</value>
				<description>Determines where on the local filesystem an DFS data node should store its blocks.If this is a comma-delimited list of directories,then data will be stored in all named directories,typically on different devices.Directories that do not exist are ignored.
				</description>
				<final>true</final>
			</property>
			<property>
				<name>dfs.replication</name>
				<value>1</value>
			</property>
			<property>
				<name>dfs.webhdfs.enabled</name>
				<value>true</value>
			</property>
		</configuration>
	(3/6)mapred-site.xml
		<configuration>
			<property>
				<name>mapreduce.framework.name</name>
				<value>yarn</value>
			</property>
			<property>
				<name>mapreduce.jobhistory.address</name>
				<value>hadoop00:10020</value>
			</property>
			<property>
				<name>mapreduce.jobhistory.webapp.address</name>
				<value>hadoop00:19888</value>
			</property>
		</configuration>
	(4/6)yarn-site.xml
		<configuration>
			<property>
				<name>yarn.nodemanager.aux-services</name>
				<value>mapreduce_shuffle</value>
			</property>
			<property>
				<name>yarn.nodemanager.aux-services.mapreduce.shuffle.class</name>
				<value>org.apache.hadoop.mapred.ShuffleHandler</value>
			</property>
			<property>
				<name>yarn.resourcemanager.address</name>
				<value>hadoop00:8032</value>
			</property>
			<property>
				<name>yarn.resourcemanager.scheduler.address</name>
				<value>hadoop00:8030</value>
			</property>
			<property>
				<name>yarn.resourcemanager.resource-tracker.address</name>
				<value>hadoop00:8031</value>
			</property>
			<property>
				<name>yarn.resourcemanager.admin.address</name>
				<value>hadoop00:8033</value>
			</property>
			<property>
				<name>yarn.resourcemanager.webapp.address</name>
				<value>hadoop00:8088</value>
			</property>
		</configuration>
	(5/6)yarn-env.sh
		export HADOOP_FREFIX=/home/work/hadoop
		export HADOOP_COMMON_HOME=${HADOOP_FREFIX}
		export HADOOP_HDFS_HOME=${HADOOP_FREFIX}
		export PATH=$PATH:$HADOOP_FREFIX/bin
		export PATH=$PATH:$HADOOP_FREFIX/sbin
		export HADOOP_MAPRED_HOME=${HADOOP_FREFIX}
		export YARN_HOME=${HADOOP_FREFIX}
		export HADOOP_CONF_HOME=${HADOOP_FREFIX}/etc/hadoop
		export YARN_CONF_DIR=${HADOOP_FREFIX}/etc/hadoop
		export JAVA_HOME=/home/work/jdk
		export HADOOP_PID_DIR=/home/work/data/hadoop/pids
	(6/6)hadoop-env.sh
		#内容跟yarn-env.sh一模一样，复制即可
2.zookeeper-1个
	配置文件在 /home/work/zookeeper/conf/ 里面
	zoo.cfg
		tickTime=2000
		dataDir=/home/work/data/zookeeper/data
		dataLogDir=/home/work/data/zookeeper/datalog
		clientPort=2181
		initLimit=5
		syncLimit=2
		server.1=192.168.10.10:2888:3888
		server.2=192.168.10.11:2888:3888
		server.3=192.168.10.12:2888:3888
3.hbase-2个
	配置文件在 /home/work/hbase/conf/ 里面
	(1/2)hbase-env.sh
		export JAVA_HOME=/home/work/jdk
		export HBASE_PID_DIR=/home/work/data
		export HBASE_MANAGES_ZK=false
	(2/2)hbase-site.xml
		<configuration>
			<property>
				<name>hbase.rootdir</name>
				<value>hdfs://hadoop00:9000/hbase</value>
			</property>
			<property>
				<name>hbase.cluster.distributed</name>
				<value>true</value>
			</property>
			<property>
				<name>hbase.master</name>
				<value>hdfs://hadoop00:60000</value>
			</property>
			<property>
				<name>hbase.zookeeper.quorum</name>
				<value>hadoop00,hadoop01,hadoop02</value>
			</property>
			<property>
				<name>hbase.tmp.dir</name>
				<value>/home/work/data/hbase/data</value>
			</property>
		</configuration>
</xmp></pre>
						</label>
					</label>
				</label>
			</label>
			<label>LINUX</label>
			<label>
				<label>常用指令</label>
				<label>
					<label>
<pre>
【WINDOWS】
>at 22:50 shutdown -s
     #在预定时间关机
>shutdown -a
     #取消这个计划
>shutdown -s -t 300
     #倒计时300秒后关机
>shutdown -i
     #远程关机对话框
【 LINUX】
#Linux三个常用关机命令
>shutdown
     #以一种安全的方式关闭系统。所有登录用户都可以看到关机信息提示，并且login将被阻塞
     #可以指定立刻关机或一定延时后关机
     #所有进程都将接收到SIGTERM信号，将处于编辑状态的文件进行存储，将所有缓冲池内的数据进行适当的清除等
>halt
     #最简单的关机命令，其实就是调用shutdown -h
     #执行时会杀死应用进程，执行sync系统调用，文件系统写操作完成后就会停止内核
>poweroff
     #在关闭计算机操作系统之后，最后会发送ACPI指令，通知电源，最后切断电源供应
>curl -d "" "http://api.tmooc.cn/student" #POST
>vim /etc/bashrc
     alias ls="ls --color" #加入此行
     #下次启动bash时就可以像Slackware里那样显示彩色的目录列表了
     蓝色-目录
     绿色-可执行文件
     红色-压缩文件
     浅蓝色-链接文件
     灰色-其他文件
>ls [选项] [目录名]
     -l,除了文件名，权限、所有者、大小等详细信息
     -R,-recursive(递归) 同时列出所有子目录层
>free -m
     #清理前内存使用情况
     #其中第一行全局角度描述系统使用的内存状况
          total-总物理内存
          used-已使用内存，一般较大因为包括了cache+应用程序使用的内存
          free-完全未被使用的内存
          shared-应用程序共享内存
          buffers-缓存，主要用于目录方面，inode值等(ls大目录可看到这个值增加)
          cached-缓存，用于已打开的文件
     note:
          total=used+free
          used=buffers+cached(maybe add shared also)
     #第二行描述应用程序的内存使用
          前个值表示-buffres/cache-应用程序使用的内存大小，used减去缓存值
          后个值表示+buffers/cache-所有可供应用程序使用的内存大小，free加上缓存值
     note:
          -buffer/cache=used-buffers-cached
          +buffers/cache=free+buffers+cached
     #第三行表示swap的使用
          used-已使用
          free-未使用
     #开始清理
     >echo 1 >/proc/sys/vm/drop_caches
     #完成，查看内存条数命令
     >dmidecode | grep -A16 "Memory Device$"
>grep -n '' a.txt --color=auto
     #输出显示颜色
     -c 计数
     -i
     -C n 前后各一行
     -o 只显示匹配内容
     #grep命令是Linux中强大的文本搜索工具
     #grep : g (globally) search for a re (regular expression) and p (print ) the results
     #grep命令使用正则表达式搜索文本，并把匹配的行打印出来
     netstat命令各个参数说明如下：
　　-t : 指明显示TCP端口
　　-u : 指明显示UDP端口
　　-l : 仅显示监听套接字(所谓套接字就是使应用程序能够读写与收发通讯协议(protocol)与资料的程序)
　　-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。
　　-n : 不进行DNS轮询，显示IP(可以加速操作)
     即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··
>netstat -ntlp
     #用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况
     #查看当前所有tcp端口
     netstat -ntulp |grep 80   //查看所有80端口使用情况·
     netstat -an | grep 3306   //查看所有3306端口使用情况·
>df -h
     #检查Linux服务器的文件系统的磁盘空间占用情况
>du -sh * | sort -n
     #统计当前目录大小，并按大小排序
     对文件和目录磁盘使用的空间查看
>rm -rf
     #文件名 删除
     -f,--force 忽略不存在的文件，从不给出提示
     -r,-R,--recursive
     #指示rm将参数中列出的全部目录和子目录均递归地删除
>mv
     #移动文件或将文件改名
>cp
     #复制文件或目录
>mkdir
     #创建指定名称的目录
>touch
     #创建不存在的文件或修改文件时间戳
>cat
     #连接文件或标准输入并打印
     >cat >> file #在file里面继续添加内容
     >cat > file #重新编辑file文件内容
     主要三大功能：
     1.一次显示整个文件:cat filename
     2.从键盘创建一个文件:cat > filename #只能创建新文件，不能编辑已有文件
     3.将几个文件合并为一个文件:cat file1 file2 > file
>more
     #和cat的功能一样都是查看文件里的内容，但不同是more可以按页来查看文件的内容，还支持直接跳转行等功能
>less
     #对文件或其输出进行分页显示的工具，Linux正统查看文件内容工具
     #功能极其强大
     /字符串 #向下搜索功能
     ?字符串 #向上搜索功能
     n #重复前一个搜索
     N #反向重复前一个搜索
     >ps -ef|less #ps查看进程信息通过less分页显示
     >history|less #查看命令历史使用记录并通过less分页显示
     >less log1.log log2.log #浏览多个文件，输入n切换到下一个，输入p切换到上一个
     #1.全屏导航
          ctrl+F #向前移动一屏
          ctrl+B #向后移动一屏
          ctrl+D #向前移动半屏
          ctrl+U #向后移动半屏
     #2.单行导航
          j #向前移动一行
          k #向后移动一行
     #3.其它导航
          G #移动到最后一行
          g #移动到第一行
          q / ZZ #退出less命令
     #4.其它有用的命令
          v #使用配置的编辑器编当前文件
          h #显示less的帮助文件
          &pattern #仅显示匹配模式的行，而不是整个文件
     #5.标记导航
          #查看大文件时，可以在任何一个位置作标记，再导航到标记的位置
          ma #使用a标记文本的当前位置
          'a #导航到标记a处
>head
     #显示开头某个数量的文字区块
>tail
     #从指定点开始将文件写到标准输出，常用来循环查看文件内容
     -f #查阅正在改变的日志文件，不断刷新，看最新内容
>which
     #查看可执行文件的位置
     #在PATH变量指定的路径中搜索某个系统命令的位置，并返回第一个搜索结果，可用来检查某个命令是否存在，以及执行命令的位置
     >which cd #cd命令找不到，因为cd是bash内建的命令，which默认是找PATH内所规范的目录
>whereis
     #查看文件的位置，从数据库查
     #该数据库文件并不是实时更新，默认一星期更新一次，可能会查已删除
>locate
     #配合数据库查看文件位置，从数据库查
     #数据库由updatedb程序来更新，内定值一天跑一次，可修改/etc/crontab来更新设定值
>find
     #实际搜寻硬盘查询文件名称，遍历硬盘查
     >find pathname -options
     -name
     >find . -name '*.log' | sort #在当前目录查找以.log结尾的文件，并排序
     >find . -name '[A-Z]*[0-9]' -print
>top
     #是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用情况，类似于Windows的任务管理器
>ifconfig
     #获取网络接口配置信息并对此进行修改(interface config)
>ping
     #测试与目标主机的连通性，Linux下ping不会自动终止
>telnet
     #通常用于远程登录
     telnet程序是基于TELNET协议的远程登录客户端程序
>ps -ef|grep tom
     #以System V方式显示
>ps -aux|grep tom 
     #以BSD方式显示
     #显示特定进程信息，连同命令行
     #Process Status，列出系统中当前运行的哪些进程，列出的是快照，如果想要动态的显示进程信息，可以使用top
     #Linux上进程有5种状态及状态码：
          运行(正在运行或在运行队列中等待)-R
          中断(休眠中，受阻，在待待某个条件的形成或按受到信号)-S
          不可中断(收到信号不唤醒和不可运行，进程必须等待直到有中断发生)-D
          僵死(进程已终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放)-Z
          停止(进程收到SIGSTOP,SIGSTP,SIGTIN,SIGTOU信号后停止运行)-T
>su - root
     切换到root用户
>who am i或who mom likes
     当前登录用户
>cat /etc/passwd |grep kevin
     查看用户kevin
>vipw /etc/passwd
     编辑所有用户
>kill -9 1790
>userdel -r sam
     删除用户sam在系统文件中的记录，删时删除用户的主目录
>cat /etc/group | sort
     读取文件内容并输出，| sort表示将读取的文件进行一个字典排序
>w
     #查看链接本机的网络连接状况
>rpm -qa | grep java
     #查看JDK
>rpm -e --nodeps java-1.6.0.openjdk
     #移除
>tzselect
     #5 9 1 1 设置linux的时区
>date
     #查看系统时间
>hwclock --show
     #查看硬件时间
>hwclock --hctosys
     #将硬件时间设置成系统时间
>hwclock --systohc
     #将系统时间设置成硬件时间
>hwclock --set --date="mm/dd/yy hh:mm:ss"
     #修改硬件时间到指定时间
>date -s "dd/mm/yyyy hh:mm:ss"
     #修改系统时间到指定时间
>ntpdate 0.rhel.pool.ntp.org
>date -s 07/13/2011
     #系统时间
>date -s 11:12:00
>ntpdate -u 210.72.145.44
     #网络时间同步命令 中国国家授时中心 NTP服务器(上海):ntp.api.bz
>rdate -s 210.72.145.44
     #OK
【VIM】
>Ctrl+f
     #向前翻页
>Ctrl+b
     #向后翻页
>两次 [ 回到顶部
>/+查找的关键字
     #代表搜索(Ctrl+r,Shift+",搜索复制的内容)，n:跳至下一个高亮处;N:向前跳
>数字+gg
     #快速跳转到第几行
>光标移到关键词上+gd  
>i
     #插入模式
>dd/cc
     #剪切当前行
>yy
     #复制当前行
>v+左右选择+y
     #复制选中内容
>p
     #黏贴
>注释某些行：Ctrl+v，选择一列小方块，大写I，输入//，两次Esc
>取消注释：块选择之后，x
>u
     #撤消操作
>自动补全：Ctrl+n
>剪切当前光标至末尾：D，之后p粘贴
【命令规类】
一.文件目录操作命令：(15)
     ls、cd、pwd、mkdir、rm、rmdir、mv、cp、touch、cat、nl、more、less、head、tail
二.文件查找命令：(7)
     which、whereis、locate、find、find之exec、find之xrags、find参数详解
三.文件和目录属性：(3)
     Linux目录结构、Linux文件类型与扩展名、Linux文件属性详解
四.文件打包上传和下载：(3)
     用SecureCRT来上传和下载文件、tar、gzip
五.Linux文件权限设置：(4)
     chmod、chgrp、chown、/etc/group文件详解
六.磁盘存储相关：(2)
     df、du
七、性能监控和优化命令：(5)
     top、free、vmstat、iostat、lsof
八.网络命令：(9)
     ifconfig、route、ping、traceroute、netstat、ss、telnet、rcp、scp
其他命令：(10)
     ln、diff、date、cal、grep、wc、ps、watch、at、crontab
【其他】(从笔记中随便拿了一些)
IP地址的分类：
          A类：1~126
               255.0.0.0 二进制8位
          B类：128~191
               255.255.0.0 二进制16位
          C类：192~223
               255.255.255.0 二进制24位
          D类：224~239组播
          E类：240~254科研
OSI协议模型-OSI的七层框架功能-数据单元(PDU)
     应用层：网络服务与最终用户的一个接口 定义用户接口-APDU-计算机
     表示层：数据的表示、安全、压缩 如加密、压缩 编码-PPDU
     会话层：建立、管理、中止会话，例如断点续传 加密-SPDU
     传输层：定义传输数据的协议端口号，以及流量控制和差错校验，实现了程序与程序的互连，可靠与不可靠的传输--程序间连接(端到端连接)-TPDU(段、数据段)-TCP UDP-端到端-防火墙
     网络层：进行逻辑地址寻址，实现不同网络(异构)之间的通信，定义了IP地址，为数据传输选择最佳路径，路由器工作在网络层-报文(包、数据包)-路由器-主机间点到点
     数据链路层：建立逻辑连接、进行硬件地址寻址(物理地址、网卡编号)、差错校验等功能、通过MAC地址实现数据的通信，帧包装、帧传输、帧同步。交换机工作在数据链路层-帧(数据帧)-交换机
     物理层：建立、维护、断开物理连接，定义了接口及介质，实现了比特流的传输-比特-网卡 中继器 集线器
TCP/IP协议族的组成
     应用层：HTTP FTP TFTP SMTP SNMP DNS
     传输层：TCP UDP
     网络层：ICMP IGMP IP ARP RARP
     数据链路层：由底层网络定义的协议
     物理层：由底层网络定义的协议
数据的封装与解封装过程
     --数据封装过程
     应用层：上层数据
     传输层：TCP头部、上层数据
     网络层：IP头部、TCP头部、上层数据
     数据链路层：MAC头部、IP头部、TCP头部、上层数据
     物理层：比特流传输
     --数据解封装过程
     物理层：比特流传输
     数据链路层：MAC头部、IP头部、TCP头部、上层数据
     网络层：IP头部、TCP头部、上层数据
     传输层：TCP头部、上层数据
     应用层：上层数据
</pre>
					</label>
				</label>
			</label>
			<label>WEB</label>
			<label>
				<label>常用笔记</label>
				<label>
					<label>
<pre><xmp>
【常用笔记】
1.获取父级元素
parent()
     #获得其父元素，一个
parents()
     #从父元素开始
     #沿DOM树向上遍历，直到文档的根元素为止，将每个祖先元素添加到一个临时的集合；如果应用了选择器，则会基于该选择器对这个集合进行筛选
     #返回包含零个、一个或多个元素的jQuery对象
closest()
     #从当前元素开始
     #沿DOM树向上遍历，直到找到已应用选择器的一个匹配为止
     #返回包含零个或一个元素的jQuery对象
2.获取同级元素
next()
     #获得匹配元素紧邻的下一个同胞元素。如果提供选择器，则取回匹配该选择器的下一个同胞元素
nextAll()
     #获得匹配元素后面的所有同胞元素，由选择器筛选是可选的
prev()
     #获得匹配元素紧邻的前一个同胞元素(与next相反)
prevAll()
     #获得当前匹配元素前面的所有同胞元素(与nextAll相反)
3.获取子元素
children()
     #返回匹配元素的子元素，添加可选参数可通过选择器进行过滤
find()
     #获得当前元素的后代
#字符串操作
str.replace(/n/g,"1")
     #替换所有n成1
     #g-global全局搜索
     #i-忽略大小写搜索
     #m-多行搜索
str.replace(/<\/?[^>]*>/gim,"")
     #去掉所有的html标记
str.replace(/(^\s+)|(\s+$)/g,"")
     #去掉前后空格
str.replace(/\s/g,"")
     #去除文章中间空格
str.substr(0,2)
     #起始位置从0开始，截取长度
str.substring(0,3)
     #起始位置从0开始，截取值为从0到n-1索引位置
#三种引入写法
<script type="text/javascript" src="jquery-1.10.2.min.js"></script>
<script language="javascript" src="jedate.min.js"></script>
<script src="laydate.js"></script>
<script type="text/javascript"></script>

<link rel="stylesheet" type="text/css" href="myStyle.css" />
<style type="text/css"></style>
【其他】(从笔记中随便拿了一些)
KeyPress 和KeyDown 、KeyPress之间的区别
	keyup：键盘按键一落一起，起时触发
	keypress：返回ASCII字符，长按重复触发，a-97、A-65
	keydown：返回键盘的代码，长按重复触发，a-65、A-65
CSS
	Cascading Style Sheets：层叠样式表，又叫级联样式表，简称样式表
"一切皆为框"：页面上所有的元素都可以显示为框
	display:
          none：-让生成的元素根本没有框 -该框及其所有内容就不再显示，不占用文档中的空间
          block：-让行内元素表现得像块级元素一样
     visibility：
          规定元素是否可见
          visible：默认值，元素可见
          hidden：元素不可见，但是依然占据空间
JavaScript
          JavaScript是一种运行于JavaScript解释器/引擎中的解释型脚本语言
          完整的Javascript语言由三部分组成：
               核心（ECMAScript）
               文档对象模型（DOM,Document Object Model）
               浏览器对象模型（BOM,Browser Object Model）
JavaScript数据类型
	原始类型：number、string、boolean、null、undefined
	引用类型：
	      Array：数组
          Object：对象
          Function：函数
          Number：数字
          String：字符串
          Boolean：布尔
          Date：日期
          Error：错误
浏览器兼容性问题的根源
	ECMAScript是欧洲计算机制造商协会(European Computer Manufacturers Association)通过ECMA-262标准化的脚本程序设计语言，它是一个Web行业标准。
	任何厂家都可以根据ECMAScript标准编写自己的浏览器脚本语言实现，在实现了ECMAScript所有的标准特性之外，还可以编写扩展自己的特殊功能——但这样的扩展功能往往就是造成浏览器兼容性问题的根源。
DOM对象->jQuery对象
	使用$()将DOM对象包装起来
	例：var obj=document.getElementById('d1');var $obj=$(obj);$obj.html('hello jQuery');
jQuery对象->DOM对象
	通过jQuery提供的get(index)方法，得到对应的DOM对象
	jQuery对象是一个数组对象
	例：var $obj=$('#d1');var obj=$obj.get(0);obj.innerHTML='hello jQuery';
Canvas
	Canvas也是HTML5中最强大的特性之一。允许开发者使用动态和交互式可视化方法在Web上实现桌面应用程序的功能
SVG
	SVG（Scalable Vector Graphics）是一种使用XML技术描述二维图形的语言
SVG与Canvas的区别
	SVG
	   -不依赖分辨率
	   -支持事件处理器
	   -最适合带有大型渲染区域的应用程序（例如百度地图）
	   -不适合游戏
	Canvas
	   -依赖分辨率
	   -不支持事件处理器
	   -能够以".png"或".jpg"格式保存结果图象
	   -最合适图像密集型的游戏
JavaScript是基于原型的面向对象
Java是基于类(Class)的面向对象
JQuery九类选择器
  基本选择器
  层级选择器
  过滤选择器
	   基本过滤选择器
	   子元素过滤选择器
	   内容过滤选择器
	   可见性过滤选择器
	   属性过滤选择器
	   表单对象属性过滤选择器
  表单选择器
基本选择器
     #id
     .className
     element
     *
     selector1,selector2-并集
层级选择器
     sel1 空格 sel2-祖先元素与后代元素
     sel1 > sel2-父元素与子元素
     sel1 + sel2-指定元素的下一个元素
     sel1 ~ sel2-指定元素后面所有的兄弟元素
过滤选择器
     用法-在选择器前增加":"
     基本过滤器
          :first-匹配第一个
          :last-匹配最后一个
          :even-匹配索引值为偶数
          :odd-匹配索引值为奇数
          :eq(index)-匹配索引值为index的元素
          :gt(index)-匹配索引值大于index的元素
          :lt(index)-匹配索引值小于index的元素
          :not(selector)-与selector选择器相反的元素
          :header-匹配h1~h6标题元素
               在实际开发中很少使用
          :animated-匹配jQuery的动画效果
               只能匹配jQuery实现的动画效果
     内容过滤选择器
          :contains(文本)-匹配包含指定文本内容的元素
          :empty-匹配没有子元素也没有文件元素的空元素
     可见性过滤选择器
          :visible-匹配可见的所有元素
          :hidden-匹配不可见的所有元素
     属性过滤选择器
          [attrName]-匹配包含性性attrNamer的元素
          [attrName=value]-匹配包含属性attrName的元素
          [attrName!=value]-匹配包含性性attrName不等于value的元素)包含没有attrName属性的元素)
          [attrName^=value]-匹配包含属性attrName以value开始的元素
          [attrName$=value]
          [attrName*=value]
          [attrName1][attrName2]-交集
     子元素过滤选择器-在其前面增加空格，从1开始
          :nth-child(index)-匹配第index个子元素
          :first-child-匹配第一个子元素
          :last-child-匹配最后一一个子元素
          :only-child-匹配唯一一个子元素
     表单对象属性过滤选择器
          :enabled-可用输入框
          :disabled-不可用输入框
          :checked-被选中
          :selected-被选中
     表单选择器
</xmp></pre>
					</label>
				</label>
			</label>
			<label>架构</label>
			<label>
				<label>《大型网站技术架构：核心原理与案例分析》</label>
				<label>
					<label>关键字</label>
					<label>
						<label>
<pre>
时间：2016-11-07 02:36:31
备注：看本书的目的，随便看看，233
进度：240/240
笔记字数：25769，达到了目前读书笔记字数之最，是这本书太经典了还是自己知道的太少了呢，233

李智慧，在阿里巴巴担任架构师，人称"教授"
"当此书人手一本的时候，阿里、腾讯、京东……的面试官们怎么办呢？"--书评
山寨与创新的最大区别不在于是否抄袭、是否模仿，而在于对问题和需求是否真正理解与把握
大型网站架构演化发展历程
	1.应用程序、数据库、文件等都在一台服务器上
	2.应用服务和数据服务分离
	3.使用缓存改善网站性能：	本地缓存、远程分布式缓存
	4.使用应用服务器集群改善网站的并发处理能力：	可伸缩性、负载均衡调度服务器
	5.数据库读写分离
	6.使用反向代理和CDN加速网站响应：	CDN和反向代理的基本原理都是缓存
	7.使用分布式文件系统和分布式数据库系统
	8.使用NoSQL和搜索引擎
	9.业务拆分：	分而治之、拆分应用、独立部署维护、消息队列
	10.分布式服务
网站架构模式
	1.<b>分层</b>：	横向维度上切分，应用层、服务层、数据层，如应用层可以再细分为视图层(美工负责)和业务逻辑层(工程师负责)
	2.<b>分割</b>：	纵向方面对软件进行切分，成为高内聚低耦合的模块，数据库放在不同的数据库服务器上
	3.<b>分布式</b>：	资源独立分布式部署，独立的域名，动静分离，各种NoSQL产品几乎都是分布式的
	4.<b>集群</b>：	多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务，失效转移机制
	5.<b>缓存</b>：	CDN、反向代理、本地缓存、分布式缓存
	6.<b>异步</b>：	系统解耦合的一个重要手段，异步消息队列
	7.<b>冗余</b>：	数据冗余备份，全球范围内部署灾备数据中心
	8.<b>自动化</b>：	目前主要集中在发布运维方面，自动化代码管理、自动化测试、自动化安全检测、自动化部署、自动化报警、自动化换效转移、自动化失效恢复、自动化降级、自动化分配资源
	9.<b>安全</b>：	密码和手机校验码，网络通信加密，敏感数据加密，验证码，垃圾及敏感信息进行过滤，风险控制
大型网站核心架构要素
	性能、可用性、伸缩性、扩展性和安全性
瞬时响应：网站的<b>高性能</b>架构
	1.Web前端性能优化
		浏览器访问优化
			减少http请求:合并CSS、合并JavaScript、合并图片
			使用浏览器缓存
			启用压缩
			CSS放在页面最上面、JavaScript放在页面最下面
			减少Cookie传输
		CDN加速
			(Content Distribute Network，内容分发网络)本质是一个缓存，即所谓网络访问第一跳
			CDN部署在网络运营商的机房
		反向代理
			反向代理服务器位于网站机房一侧
	2.应用服务器性能优化
		分布式缓存
		二八定律，即80%的访问落在20%的数据上，因此将20%数据缓存，可改善系统性能
		缓存雪崩
		缓存穿透
		异步操作:消息队列,削峰
		使用集群
		代码优化
			多线程
			资源复用:比如数据数库连接、网络通信连接、线程、复杂对象等
			数据结构
			垃圾回收
	3.存储服务器性能优化
		机械硬盘 vs 固态硬盘
		B+树 vs LSM树
		RAID vs HDFS
万无一失：网站的<b>高可用</b>架构
	用多少个9来衡量网站的可用性
	保证数据存储高可用的手段主要是<b>数据备份</b>和<b>失效转移机制</b>
	数据一致性
	数据备份
	失效转移
	网站运行监控
	监控管理
永无止境：网站的<b>伸缩性</b>架构
	渐进式的演化过程，最重要的技术手段就是使用服务器<b>集群</b>
	伸缩性设计分成两类：
		不同功能进行物理分离实现伸缩
		单一功能通过集群规模实现伸缩
	具体来说，集群伸缩性又可分两种：
		应用服务器集群伸缩性（HTTP重定向负载均衡、DNS域名解析负载均衡、反向代理负载均衡、IP负载均衡、数据链路层负载均衡、负载均衡算法）
		分布式缓存集群的伸缩性（分布式缓存的一致性Hash算法）
		数据存储服务器集群伸缩性（关系型数据库集群的伸缩性设计、NoSQL数据库的伸缩性设计）
			HBase为可伸缩海量数据储存而设计，HBase的线性伸缩
	高手定律：
		这个世界只有遇不到的问题，没有解决不了的问题，高手之所以成为高手，是因为他们遇到了常人很难遇到的问题，并解决了。所以百度有很多广告搜索的高手，淘宝有很多海量数据的高手，QQ有很多高并发业务的高手，原因大抵如此。一个100万用户的网站，不会遇到1亿用户同时在线的问题；一个拥有100万件商品网站的工程师，可能无法理解一个拥有10亿件商品网站的架构
随需应变：网站的<b>可扩展</b>架构
	指对现在系统影响最小的情况下，系统功能可持续扩展或提升的能力
	模块分布部署以后具体聚合方式主要有<b>分布式消息队列</b>和<b>分布式服务</b>
	Web Service，用以整合异构系统及构建分布式系统
	除了以上，还需要：负载均衡、失效转移、高效的远程通信、整合异构系统、对应用最少侵入、版本管理、实时监控
	分布式服务框架设计
		Facebook利用Thrift,国内阿里巴巴的Dubbo
	可扩展的数据结构
		NoSQL数据库使用的ColumnFamily(列族)设计,数据表可以包含数百万的字段，可以随意扩展
	利用开放平台建设网站生态圈
	开放平台的架构设计
固若金汤：网站的<b>安全</b>架构
	<b>XSS</b>和<b>SQL注入</b>攻击构成网站应用攻击最主要的两种手段，全球大约70%的Web应用攻击都来自于此，常见的还包括CSRF、Session劫持等手段
	XSS：
		XSS攻击即跨站点脚本攻击(Cross Site Script)，指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，探制用户浏览器进行恶意操作的一种攻击方式
		反射
		持久型XSS攻击
	注入攻击：
		SQL注入攻击和OS注入攻击
	手段：消毒、参数绑定、表单Token、验证码、Referer check
	Web应用防火墙
	网站安全漏洞扫描
	信息加密技术及密钥安全管理
		单项散列加密
		对称加密
		非对称加密
	信息过滤与反垃圾
</pre>
						</label>
					</label>
					<label>阅读笔记</label>
					<label>
						<label>
<pre>
李智慧，在阿里巴巴担任架构师，人称"教授"

"当此书人手一本的时候，阿里、腾讯、京东……的面试官们怎么办呢？"--书评 Oracle资深工程师 付银海

传统的企业应用系统面对的技术挑战是处理复杂凌乱、千变万化的所谓业务逻辑
而大型网站主要面对的技术挑战是处理超大量的用户访问和海量的数据处理
前者的挑战来自功能性需求，后者的挑战来自非功能性需求
功能性需求也许还有"人月神话"聊以自慰，通过增加人手解决问题，而非功能需求大多是实实在在的技术难题，无论有多少工程师，做不到就是做不到

小结：山寨与创新的最大区别不在于是否抄袭、是否模仿，而在于对问题和需求是否真正理解与把握

本书起源
2011年年末，京东图书促销，打5折基础上满一百送一百
点击"购买"按钮，浏览器迟迟没有响应，过了一会，页面显示"Service is too busy"。京东信息部的同事很可能是错误地判断了系统的瓶颈及伸缩性架构的困难，对老板做出了过度承诺，而这背后折射出的是他们对网站架构的本质缺乏了解
2012年年初，当时的中国铁道部官方售票网站www.12306.cn在春运期间因为大量用户访问而崩溃，无法有效访问。12306的架构师似乎对这种可能发生的大规模并发访问产生的问题完全没有一点概念，系统好像根本没有经过任何高并发场景下的性能评估和性能测试，就那么干脆利落地崩溃了，趴在那里长时间起不来

第1篇 概述
【1 大型网站架构演化】
1.某些B2C网站逢促销必宕机几乎成为一种规律，而铁道部电子客标官方购票网站的频繁故障和操作延迟更将这一现象演绎的淋漓尽致
2.大型网站软件系统的特点
     高并发，大流量
     高可用
     海量数据
     用户分布广泛，网络情况复杂
     安全环境恶劣
     需求快速变更，发布频繁
     渐进式发展
3.大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得很棘手。大型网站架构主要就是解决这类问题
4.大型网站架构演化发展历程
(1)应用程序、数据库、文件等都在一台服务器上
(2)应用服务和数据服务分离
     服务器对硬件资源的要求，需要处量大量的业务逻辑，因此需要更快更强大的CPU
     数据库服务器需要快速磁盘检索和数据缓存，因此需要更快的硬盘和更大的内存
     文件服务器需要存储大量用户上传的文件，因此需要更大的硬盘
(3)使用缓存改善网站性能
     网站访问特点和现实世界的财富分配一样遵循二八定律：80%的业务访问集中在20%的数据上
     既然大部分的业务访问集中在一小部分数据上，如果把这一小部分数据缓存在内存中，是不是就可以减少数据库的访问压力，提高整个网站的数据访问速度，改善数据库的写入性能了呢？
     网站使用的缓存可以分为两种：缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器上的远程缓存。本地缓存的访问速度更快一些，但是受应用服务器内存限制，其缓存数据量有限。远程分布式缓存可以使用集群的方式，可以在理论上做到不受内存容量限制的缓存服务
     使用缓存后，数据访问压力得到有效缓解，但是单一应用服务器能够处理的请求连接有限，成为整个网站的瓶颈
(4)使用应用服务器集群改善网站的并发处理能力
     持续增加服务器不断改善系统性能，从而实现系统的可伸缩性
     通过负载均衡调度服务器，可将来自用户浏览器的访问请求分发到应用服务器集群中的任何一台服务器上，使应用服务器的负载压力不再成为整个网站的瓶颈
(5)数据库读写分离
     网站使用缓存后，使绝大部分数据读操作访问都可以不通过数据库就能完成，但仍有一部分读操作(缓存访问不命中、缓存过期)和全部的写操作需要访问数据库，数据库因为负载压力过高而成为网站的瓶颈
     目前大部分的主流数据库都提供主从热备功能，实现数据库读写分离，从而改善数据库负载压力
(6)使用反向代理和CDN加速网站响应
     CDN和反向代理的基本原理都是缓存
     CDN部署在网络提供商的机房，用户请求网站服务从距离最近的机房获取数据
     反向代理部署在网站的中心机房，请求到达中心机房，首先访问的服务器是反向代理服务器，如其中缓存着请求的资源，就将其直接返回
     目的都是尽早返回数据给用户，一方面加快访问速度，另一方面也减轻后端服务器的负载压力
(7)使用分布式文件系统和分布式数据库系统
     随着网站业务的发展依然不能满足需求，这时需要使用分布式数据库，分布式文件系统
     分布式数据库是网站数据库拆分的最后手段，只有在单表数据规模非常庞大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务分库，将不同业务的数据库部署在不同的物理服务器上
(8)使用NoSQL和搜索引擎
     随着网站业务越来越复杂，对数据存储和检索的需求也越来越复杂，需采用一些非关系数据库技术如NoSQL和非数据库查询技术如搜索引擎
(9)业务拆分
     为应对日益复杂的业务场景，通过使用分而治之的手段将整个网站业务分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务团队负责
     具体到技术上，也会根据产品线划分，将一个网站拆分成许多不同的应用，每个应用独立部署维护。应用之间可以通过一个越链接建立关系(在首页上的导航链接每个都指向不同的应用地址)，也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统
(10)分布式服务
     随着业务拆分越来越小，存储系统越来越庞大，应用系统的整体复杂度呈指数级增加，部署维护越来越困难
     将应用系统中需要执行的许多相同的业务操作提取出来，独立部署，比如用户管理、商品管理等
     由这些可复用的业务连接数据库，提供共用业务服务，而应用系统只需要管理用户界面，通过分布式服务调用共用业务服务完成具体业务操作
大型网站的架构演化到这里，基本上大多数的技术问题都得以解决
5.驱动大型网站技术发展的主要力量是网站的业务发展
     是业务成就了技术，是事业成就了人，而不是相反。所以网站架构师应该对成就自己技术成绩的网站事业心存感恩，并努力提高技术回馈业务，才能在快速发展的互联网领域保持持续进步
6.网站架构设计误区
一味追随大公司的解决方案
     由于大公司巨大成功的光环效应，再加上从大公司挖来的技术高手的影响，网站在讨论架构决策时，最有说服力的一句话就成了"淘宝就是这么搞的"或者"Facebook就是这么搞的"
      大公司的经验和成功模式固然重要，值得学习借鉴，但如果因此而变得盲从，就失去了坚持自我的勇气，在架构演化的道路上迟早会迷路
为了技术而技术
      网站技术是为业务而存在的，除此毫无意义
企图用技术解决所有问题
     2012年年初12306故障事件后，软件开发技术界的反应
     各路专业和非专业人士众说纷纭地帮12396的技术架色出谋划策，甚至有人提议帮12306写一个开源的网站，解决其大规模并发访问的问题
     真正的问题其实不在于它的技术架构，而在于它的业务架构：根本就不应该在几亿中国人一票难求的情况下以窗口售票的模式在网上售票(零点开始出售若干天后的车票)。12306需要重构的不仅是它的技术架构，更重要的是它的业务架构：调整业务需求，换一种方式卖票，而不要去搞促销秒杀这种噱头式的游戏
     后来证明12306确实是朝这个方向发展的：在售票方式上引入了排队机制、整点售票调整为分时段售票。其实如果能控制住并发问的量，很多棘手的技术也就不是什么问题了
     技术是用来解决业务问题的，而业务的问题，也可以通过业务的手段去解决
【2】大型网站架构模式
1.网站架构模式
(1)分层
     将系统在横向维度上切分成几个部分，每个部分负责一部分相对比较单一的职责，然后通过上层对下层的依赖和调用组成一个完整的系统
     网络的7层通信协议是一种分层结构
     计算机硬件、操作系统、应用软件也可以看作是一种分层结构
     在大型网站架构中也采用分层结构，将网站软件系统分为应用层、服务层、数据层
     在实践中，大的分层结构内部还可以继续分层，如应用层可以再细分为视图层(美工负责)和业务逻辑层(工程师负责)
     分层架构模式最初的目的是规划软件清晰的逻辑结构便于开发维护，但在网站的发展过程中，分层结构对网站支持高并发向分布式方向发展至关重要
(2)分割
     纵向方面对软件进行切分
     网站越大，功能越复杂，服务和数据处理的种类也越多，将这些不同的功能和服务分割开来，包装成高内聚低耦合的模块单元，一方面有助于软件的开发和维护；另一方面，便于不同模块的分布式部署，提高网站的并发处理能力和功能扩展能力
     把数据库分割开来，分别放在不同的数据库服务器上，可以减少每台服务器上的数据量，以便减少硬盘I/O(输入/输出)处理
(3)分布式
     分层和分割的一个主要目的是为了切分后的模块便于分布式部署，即将不同模块部署在不同的服务器上，通过远程调用协同工作
分布式在解决网站高并发问题的同时也带来了其他问题
     分布式意味着服务调用必须通过网络，可能会对性能造成比较严重的影响
     服务器越多，服务器宕机的概率也越大，使网站可用性降低
     数据在分布式的环境中保持数据一致性也非常困难，分布式事务也难以保证，这对网站业务正确性和业务流程有可能造成很大影响
     分布式还导致网站依赖错综复杂，开发管理维护困难
因此分布式设计要根据具体情况量力而行，切莫为了分布式而分布式
网站应用中，常用的分布式方案
     分布式应用和服务
          将分层和分割后的应用和服务模块分布式部署
     分布式静态资源
          网站的静态资源如JS，CSS，Logo图片等资源独立分布式部署，并采用独立的域名，即人们常说的动静分离
          静态资源分布式部署可以减轻应用服务器的负载压力
          独立域名加快浏览器并发加载的速度
     分布式数据和存储
          除了对传统的关系数据库进行分布式部署外，为网站应用而生的各种NoSQL产品几乎都是分布式的
     分布式计算
          严格说来，应用、服务、实时数据处理都是计算
          目前网站普遍便用Hadoop及其MapReduce分布式计算框架进行此类批处理计算，其特点是移动计算而不是移动数据，将计算程序分发到数据所在的位置以加还计算和分布式计算
     此外，还有可以支持网站线上服务器配置实时更新的分布式配置；分布式环境下实现并发和协同的分布式锁；支持云存储的分布式文件系统等
(4)集群
     使用分布式虽然已经将分层和分割后的模块独立部署，但是对于用户访问集中的模块(比如网站的首页)，还需要将独立部署的服务器集群化，即多台服务器部署相同应用构成一个集群，通过负载均衡设备共同对外提供服务
     当某台服务器发生故障时，负载均衡设备或者系统的失效转移机制会将请求转发到集群中其他服务器上，使服务器故障不影响用户使用
(5)缓存
     缓存就是将数据存放在距离计算最近的位置以加快处理速度
     CDN
          即内容分发网络，部署在距离终端用户最近的网络服务商，如视频网站和门户网站将热点内容缓存在CDN
     反向代理
          反向代理属于网站前端架构的一部分，部署在网站的前端
          请求到达网站的数据中心最先访问到的就是反向代理服务器，缓存的静态资源
          无需将请求继续转发给应用服务器就能返回给用户
     本地缓存
          在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数，而无需访问数据库
     分布式缓存
          大型网站的数据量非常庞大，所以除了本地缓存，还需要分布式缓存
          将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据
     使用缓存有两个前提条件，一是数据访问热点不均衡，被频繁的访问；二是数据在某个时间段内有效，不会很快过期，否则会因失效而产生脏读，影响结果的正确性
          缓存除了可以加快数据访问速度，还可以减轻后端应用和数据存储的负载压力
(6)异步
     计算机软件发展的一个重要目标和驱动力是降低软件耦合性
     事物之间直接关系越少，就越少被彼此影响，越可以独立发展
     系统解耦合的一个重要手段是异步，业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个阶段之间通过共享数据的方式异步执行进行协作
     在单一服务器内部可通过多线程共享内存队列的方式实现异步，处在业务操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理；在分布式系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作内存队列的分布式部署
     异步架构是典型的生产者消费者模式，两者不存在直接调用，只要保持数据结构不变，彼此功能实现可以随意变化而不互相影响，这对网站护展新功能非常便利
     异步消息队列有如下特性：
          提高系统可用性
               消费者服务器故障，数据在消息队列服务器中存储堆积，生产者服务器可以继续处理业务请求，系统整体表现无故障。恢复正常后，继续处理消息队列中的数据
          加快网站响应速度
               处理业务处理前端的生产者服务器在处理完业务请求后，将数据写入消息队列，不需要等待消费者服务器处理就可以返回，响应延迟减少
          消除并发访问高峰
               使用消息队列将突然增加的访问请求数据放入消息队列中，等等消费者服务器依次处理，就不会对整个网站负载造成太大压力
     注意：使用异步方式处理业务可能会对用户体验、业务流程造成影响，需要网站产品设计方面的支持
(7)冗余
     通过冗余实现服务高可用
     网站需要7x24小时连续运行，可能出现某台服务器宕机
     数据冗余备份
     数据库除了定期备份，存档保存，实现冷备份外，为了保证在线务高可用，还需要对数据库进行主从分离，实时同步实现热备份
     为了抵御地震、海啸等不可抗力导致的网站完全瘫痪，某些大型网站会对整个数据中心进行备份，全球范围内部署灾备数据中心
(8)自动化
     目前大型网站的自动化架构设计主要集中在发布运维方面
     发布过程自动化
          减少人为干预，有效减少故障，发布过程包括诸多环节
     自动化代码管理
          代码版本控制、代码分支创建合并等过程自动化，工程师提交产品代号，系统就会自动为其创建开发分支，后期会自动进行代码合并
     自动化测试
          代码开发完成，提交测试后，系统自动将代码部署到测试环半日，启动自动化测试用例进行测试，向相关人员发送测试报告，向系统返馈测试结果
     自动化安全检测
          安全检测工具通过对代码进行静态安全扫描及部署到安全测试环境进行安全医疗击测试，评估其安全性
     最后进行自动化部署
          将工程代码自动部署到线上生产环境
     此外，自动化监控
          对服务器进行心跳检测，并监控其各项性能指标和应用程序的关键数据指标。如果发现异常、超出预设的阈值，就进行自动化报警
     自动化报警
          向相关人员发送报警信息，警告故障可能会发生，在检测到故障发生后，系统会进行自动化失效转移
     自动化换效转移
          将失效的服务器从集群中隔离出去，不再处理系统中的应用请求。等故障消除后，系统进行自动化失效恢复
     自动化失效恢复
          重新启动服务，同步数据保证数据的一致性
     自动化降级
          在网站遇到访问高峰，超出网站最大处理能力时，为了保证整个网站的安全可用，还会进行自动化降级，通过拒绝部分请求及关闭部分不重要的服务将系统负载降至一个安全的水平，必要时，还需要自动化分配资源
     自动化分配资源
          将空闲资源分配给重要的服务，扩大其部署规模
(9)安全
     互联网的开放特性使得其从诞生起就面对巨大的安全挑战
     网站在安全架构方面也积累了许多模式：
          通过密码和手机校验码进行身份认证
          登录、交易等操作需要对网络通信进行加密
          网站服务器上存储的敏感数据如用户信息等也进行加密处理
          为防止机器人程序滥用网络资源攻击网站，使用验证码进行识别
          对于常见的用于攻击网站的XSS攻击、SQL注入、进行编码转换等相应处理
          对于垃圾信息、敏感信息进行过滤
          对交易转帐等重要操作根据交易模式和交易信息进行风险控制
架构模式在新浪微博的应用
     从小网站开始，LAMP(Linux+Apache+MySQL+PHP)架构，随着快速发展的业务需求及用户增加，几经重构，形成现在架构
     系统分为三个层次，基础服务层，平台服务和应用服务层，API和新浪微博的业务层
     这些被分层和分割后的业务模块与基础技术模块分布式部署，每个模块都部署在一组独立的服务器集群上，通过远程调用的方式进行依赖访问
     发微博改用异步推拉结合的模式，发微博写入消息队列后立即返回
     由于微博频繁刷新，使用多级缓存微略
     为提高系统的整体可用性和性能，启用多个数据中心，用户就近访问；同时也是数据冗余复制的灾备中心
     同时还开发了一每列自动化工具，包括自动化监控，自动化发布，自动化故障修复等，以改善运维水平提高系统可用性
     由于微博的开放特性，也遇到了一系列的安全挑战，垃圾内容、僵尺粉、微博功击从未停止，除了使用一般网站常见的安全策略，在开放平台上使用多级安全审核的策略以保护系统和用户
【3】大型网站核心架构要素
1.架构，一种比较通俗的说法是"最高层次的规划，难以改变的决定"，这些规划和决定奠定了事物未来发展的方向和最终的蓝图
2.软件架构，维基百科定义："有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计"
     一般说来，除了当前的系统功能需求外，软件架构还需要关注性能、可用性、伸缩性、扩展性和安全性这5个架构要素，平衡5个要素之间的关系以实现需求和架构目标
     性能
     优化网站性能的手段，从用户浏览器到数据，影响用户请求的所有环节都可以进行性能优化
     在浏览器端，可以通过浏览器缓存、使用页面压缩、合理布局而面、减少Cookie传输等手段改善性能
     还可以使用CDN，将网站静态内容分发至离用户最近的网络服务商机房，使用户通过最短访问路径获取数据。可以在网站机房部署反向代理服务器，缓存热点文件，加快请求响应速度，减轻应用服务器负载压力
     在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力
     也可以通过异步操作将用户请求发送至消息队列等待后续任务处理，而当前请求直接返回给用户
     在网站有很多用户高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能
     在代码层面，也可以通过使用多线程、改善内存管理等手段优化性能
     在数据库服器端，索引、缓存、SQL优化等性能优化手段都已经比较成熟。而方兴未艾的NoSQL数据库通过优化数据模型、存储结构、伸缩特性等手段在性能方面的优势也日趋明显
     衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，以确定系统设计是否达到目标
     可用性
     事实上任何网站都不可能达到完全的7x24可用
     网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多台服务器上互相备份，任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失
     对于应用服务器而言，多台应用服务器通过负载均衡设备组成一个集群共同对外提供服务，任何一台服务器宕机，只需把请求切换到其他服务器就可实现应用的高可用，但是一个前提条件是应用服务器不能保存请求的会话信息。否则服务器宕机，会话丢失，即使将用户请求转发到其他服务器上也无法完成业务处理
     衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用
     伸缩性
     所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的数据存储需求
     对于应用服务器集群，只要服务器上不保存数据，所有服务器都是对等的，通过使用合适的负载均衡设备就可以向集群中不断加入服务器
     对于缓存服务器集群，加入新的服务器可能会导致缓存路由失效
     关系数据库虽然支持数据复制，主从热备等机制，但很难做到大规模集群的可伸缩性，可通过路由分区等手段将部署有多个数据库的服务器组成一个集群
     至于大部分NoSQL数据库产品，由于其先天就是为海量数据而生，因此其对伸缩性的支持通常都非常好，可以做到在较少运维参与的情况下实现集群规模的线性伸缩
     扩展性
     网站快速发展，功能不断扩展，如何设计网站的架构使用能够快速响应需求变化，是网站可扩展架构主要的目的
     衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品，是否对现有产品透明无影响
     网站可伸缩架构的主要手段是事件驱动架构和分布式服务
     事件驱动架构在网站通常利用消息队列实现
     分布式服务则是将业务和可复用服务分离开来，通过分布式服务框架调用
     大型网站为了保持市场地位，还会吸引第三方开发者，调用网站服务，使用网站数据开发周边产品，扩展网站业务。第三方开发者使用网站服务的主要途径是大型网站提供的开放平台接口
     安全性
     互联网是开放的，任何人在任何地方都可以访问网站。网站的安全架构就是保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取
     衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段，是否有可靠的应对策略
第2篇 架构
【4】瞬时响应：网站的高性能架构
1.不同视角下的网站性能
     用户视角
          直观感受到的是响应速度
          在实践中，使用一些前端架构优化手段，通过优化页面HTML样式、利用浏览器端的并发和异步特性、调整浏览器缓存策略、使用CDN服务、反向代理等手段，使浏览器尽快地显示用户感 兴趣的内容、尽可能近地获取页面内容，即使不优化应用程序和架构，也可以很大程序地改善用户视角下的网站性能
     开发人员视角
          开发人员关注的主要是应用程序本身及其相关子系统的性能，包括响应延迟、系统吞吐量、并发处理能力、系统稳定性持技术指标。主要的优化手段有使用缓存加速数据读取，使用集群提高吞吐能力，使用异步消息加快请求响应及实现削峰，使用代码优化手段改善程序性能
     运维人员视角
          运维人员更关注基础设施性能和资源利用率，如网络运营商的带宽能力、服务器硬件的配置、数据中心网络架构、服务器和网络带宽的资源利用率等。主要优化手段有建设优化骨干网、使用高性价比定制服务器、利用虚拟化技术优化资源利用等
2.吞吐量：指单位时间内系统处理的请求数量，体现系统的整体处理能力
3.性能优化
     根据网站分层架构，可分为Web前端性能优化、应用服务器性能优化、存储服务器性能优化3大类
     3.1 Web前端性能优化
          一般说来Web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有优化浏览器访问、使用反向代理、CDN等
          3.1.1 浏览器访问优化
          (1) 减少http请求
                    HTTP协议是无状态的应用层协议，每次请求都需要建立通信链路、进行数据传输，而在服务端，每个HTTP都需要启动独立的线程去处理。这些通信和服务的开销都很昂贵，减少HTTP请求的数目可有效提高访问性能
                    主要手段是合并CSS、合并JavaScript、合并图片。合并成一个文件，这样只需一次请求。图片合并，如果各自有不同超链接，可通过CSS偏移响应鼠标点击操作，构造不同的URL
          (2)使用浏览器缓存
               CSS、JavaScript、Logo、图标这些静态资源文件缓存在浏览器中。通过设置HTTP头中Cache-Control和Expires的属性，设定缓存，时间可数天甚至几个月
          (3)启用压缩
          (4)CSS放在页面最上面、JavaScript放在页面最下面
               浏览器会在下载完全部CSS之后才对整个页面进行渲染
          (5)减少Cookie传输
               一方面，Cookie包含在每交请求和响应中，太大影响数据传输
               另一方面，对于静态资源的访问，如CSS、Script等，发送Cookie没意义，可考虑静态资源使用独立域名访问，避免发送Cookie，减少传输次数
          3.1.2 CDN加速
               CDN(Content Distribute Network，内容分发网络)本质是一个缓存，而且将数据缓存在离用户最近的地方，即所谓网络访问第一跳
               CDN部署在网络运营商的机房
               CDN能缓存的一般是静态资源，如图片、文件、CSS、Script脚本、静态网页等，访问频度很高，可极大改善网页的打开速度
               网站用户--静态资源访问-->网络服务提供商本地机房 CDN服务器
               网站用户--动态资源访问-->网站数据中心机房 网站应用服务器
               两服务器之间 数据更新
          3.1.3 反向代理
               传统代理服务器位于浏览器一侧，代理浏览器发HTTP请求到互联网
               反向代理服务器位于网站机房一侧，代理网站Web服务器接收HTTP请求，请求转发
          反向代理服务器也具有保护网站安全的作用
          可以通过配置缓存功能加速Web请求
          比如博客论坛网站，缓存热门词条、帖子、博客
          也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能
     3.2 应用服务器性能优化
          应用服务器处理网站业务，包括业务代码的部署，优化手段主要有缓存、集群、异步等
          3.2.1 分布式缓存
               网站性能优化第一定律：优先考虑使用缓存优化性能
               3.2.1.1 缓存的基本原理
                    指将数据存储在相对较高访问速度的存储介质中，速度快，无需重复计算
                    缓存本质是一个内存Hash表
                    软件开发中常用到的一种数据结构
                    最简单的是余数法，使用Hash表数组长度对Hashcode求余，HashCode%length
               网站数据访问通常遵循二八定律，即80%的访问落在20%的数据上，因此将20%数据缓存，可改善系统性能，提高读取速度，降低存储访问压力
               3.2.1.2 合理使用缓存
               缓存承担大部分数据访问的压力，所以当缓存服务崩溃时，数据库会因不能承受压力而宕机，这种情况被称作缓存雪崩
               通过分布式缓存服务器集群可改善缓存的可用性
               产品在设计之初就需要一个明确的定位：什么是产品要实现的功能，什么不是产品提供的特性。在产品漫长的生命周期中，会有形形色色的困难和诱惑来改变产品的发展方向，左右摇摆、什么都想做的产品，最后有可能成为一个失去生命力的四不像
               缓存穿透
               因不恰当的业务、或恶意攻击持续高并发地请求某个不存在的数据，请求直接到数据库
               一个简单的对策是将不存在的数据也缓存起来(其value值为null)
               3.2.1.3 分布式缓存架构
                    分布式缓存指缓存部署在多个服务器组成的集群中
                    架构方式两种
                         JBoss Cache为代表的需要更新同步的分布式缓存
                              应用程序和缓存部署在同一台服务器，可快速获取
                              问题是缓存数据的数量受限于单一服务器的内存空间
                         Memcached为代表的不互相通信的分布式缓存
                              缓存与应用分离部署
                              应用程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据
                              互不通信，集群规模易扩容，具有良好的可伸缩性
                              高效的内存管理，操作系统、虚拟机垃圾回收的压缩、复制等办法，Memcached使用固定空间分配，将内存空间分为一组slab，里面又包含一组chunk，存储时根据数据的Size大小，找一个大于Size的最小chunk写入。避免了内存碎片管理的问题
          3.2.2 异步操作
               使用消息队列将调用异步化，可改善网站的扩展性
               消息队列具有很好的削峰作用，即将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务
               任何可以晚点做的事情都应该晚点再做
          3.2.3 使用集群
               在网站高并发访问的场景下，使用负载均衡技术为一个应用构建一个由多台服务器组成的服务器集群，将并发访问请求分发到多台服务器上处理，避免单一服务器因负载压力过大而响应缓慢
          3.2.4 代码优化
               3.2.4.1 多线程
                    注意问题，线程安全问题，即多线程并发对某个资源进行修改，导致数据混乱
                    用户请求是并发提交的，也就是说，所有的资源-对象、内存、文件、数据库，乃至另一个线程都可能被多线程并发访问
                    解决线程安全的主要手段：
                         将对象设计为无状态对象
                              指对象本身不存储状态信息，Java Web开发中常用的Servlet对象就设计为无状态对象
                         使用局部对象
                              在方法内部创建对象
                         并发访问资源时使用锁
                              使多线程并发操作转化为顺序操作
               3.2.4.2 资源复用
                    系统运行时，尽量减少开销大的系统资源的创建和销毁，比如数据数库连接、网络通信连接、线程、复杂对象等
                    从编程角度，资源复用主要两种模式：
                         单例(Singleton)
                         对象池(Object Pool)
                    对于每个Web请求(HTTP Request)，Web应用服务器都需要创建一个独立的线程去处理，采用线程池和方式。这些所谓的连接池、线程池，本质上都是对象池
               3.2.4.3 数据结构
                    早期关于程序的一个定义：程序就是数据结构+算法
                    Hash表的基本原理，Hash表的读写性能很大程序上依赖HashCode的随机性，即HashCode越随机散列，Hash表的冲突就越少，读写性能也就越高
                    目前较好的字符串Hash散列算法Time33算法，即对字符串逐字符迭代乘以33求得Hash值，可能相似字符串HashCode接近
                    某些应用场景不能接受，可对字符串取信息指纹，再对信息指纹求HashCode，以获得较好的随机散列
               3.2.4.4 垃圾回收
                    理解垃圾回收机制有助于程序优化和参数调优，以及编写内存安全的代码
                    以JVM为例，内存主要划分堆(heap)和堆栈(stack)
                    堆栈用于存储线程上下文信息，如方法参数、局部变量等
                    堆存储对象的内存空间，进行对象的创建和释放、垃圾回收
                    在JVM分代垃圾回机制中，将应用程序可用的堆空间分为年轻代(Young Generation)和年老代(Old Generation)，又将年轻代分为Eden区(Eden Space)、From区和To区，新建对象总是在Eden区中被创建，当Eden区空间已满，就触发一次Young GC(Garbage Collection，垃圾回收)，将还被使用的对象复制到From区，这样整个Eden区都是未被使用的空间，可供继续创建对象，当Eden区再次用完，再触发一次Young GC，将Eden区和From区还在被使用的对象复制到From区。因此，经过多次Young GC，某些对象会在From区和To区多次复制，如果超过某个阈值对象还未被释放，则将该对象复制到Old Gerneration。如果Old Gerneration空间也已用完，那么就会触发Full GC，即所谓的全量回收，全量回收会对系统性能产生较大影响，因此应根据系统业务特点和对象生命周期合理设置Young Gerneration和Old Generation大小，尽量减少Full GC。事实上，某些Web应用在整个运行期间可以做到从不进行Full GC
     3.3 存储性能优化
          3.3.1 机械硬盘 vs 固态硬盘
               机械硬盘是目前最常用的一种硬盘
               通过马达驱动磁头臂，带动磁头到指定的磁盘位置访问数据
               由于每次访问数据都需要移动磁头臂，因此在数据连续访问和随机访问时，移动次数相差巨大，性能表现差别也非常大
               固态硬盘又称作SSD或Flash硬盘，没有机械装置，数据存储在可持久记忆的硅晶体上，因此可以像内存一样快速随机访问
               更小的功耗和更少的磁盘震动与噪声
          3.3.2 B+树 vs LSM树
               文件系统或关系数据库系统通常使用B+树
               B+树是一种专门针对磁盘存储而优化的N叉排序树
               目前据库多采用两索引的B+树，树的层次最多三层，需5次太盘访问更新一条记录(三次获得数据索下及行ID，一次数据文件读操作一次写操作)
               目前许多NoSQL产品采用LSM树作为主要数据结构
               LSM树可看作一个N阶合并树
               LSM树在内存可完成，速度远快于B+树
          3.3.3 RAID vs HDFS
               RAID(廉价磁盘冗余陈列)技术主要是为了改善磁盘的访问延迟，增强磁盘的可用性和容错能力
               服务器级别的计算机支持插入多块磁盘，实现数据在多块磁盘上的并发读写和数据备份
               RAID技术在传统关系数据库及文件系统中应用比较广泛
               NoSQL以及分布式文件系统中，RAID技术遭冷落
               HDFS(Hadoop分布式文件系统)，系统在整个存储集群的多台服务器上进行数据并发读写和备份，可看作在服务器集群规模上实现了类似RAID的功能，因此不需要磁盘RAID
               以块(Block)为单位管理文件内容，写完一个Block，HDFS自动复制到另外两台上，三个副本，相当实现了RAID1的数据复制功能
               对文件处理计算时，通过MapRduce并发计算任务框架，启多个计算子任务(MapReduce Task)同时读取文件的多个Block，并发处理，相当于实现了RAID0的并发访问功能
               HDFS中两种重要的服务器角色：
                    NameNode(名字服务节点)，整个HDFS中只部署一个实例，提供元数据服务，相当于操作系统中的文件分配表(FAT)，管理文件名Block的分配，维护整个文件系统的目录树结构
                    DataNode(数据存储节点)，部署在HDFS集群中其他所有服务器上，提供真正的数据存储服务
【5】万无一失：网站的高可用架构
1.网站可用性度量
     网站不可用也被称作网站故障，业界通常用多少个9来衡量网站的可用性，2个9是基本可用，年度不可用时间小于88小时；3个9是较高可用，不可用时间小于9小时；4个9是具有自动恢复能力的高可用，不可用时间小于53分钟；5个9是极高可用性，不可用时间小于5分钟
2.一个典型的网站设计通常遵循基本分层架构模型
     应用层、服务层、数据层
     应用层的一个显著特点是应用的无状态性
          对物应用服务器集群，实现这种服务器可用状态实时监测(心跳检测机制)、自动转移失败(失效转移)任务的机制是负载均衡
          使用负载均衡技术构建一个小型的集群
     应用服务器集群的Session管理，Web应用中将这些多次请求修改使用的上下文对象称作会话
          Session复制，集群规模较大时，大量Session占用服务器和网络资源
          Session绑定，利用负载均衡的源地址Hash算法实现，负载均衡服务器总是将来源于同一IP的请求分发到同一台服务器(也可以根据Cookie信息将同一个用户的请求总是分发到同一台服务器上)，又被称作会话黏滞。但不符合高可用的需求
          利用Cookie记录Session，但受大小限制，每次请求都传输Cookie影响性能，用户可关闭Cookie
          Session服务器，可用性高、伸缩性好、性能也不错，对信息大小又没有限制的服务器集群。将应用服务器的状态分离，分为无状态的应用服务器和有状态的Session服务器
3.具体实践中，还有以下几点高可用的服务策略：
     分级管理：运维上将服务器分级管理
     超时设置：一旦超时，抛出异常
     异步调用：消息队列
     服务降级：两种手段，拒绝服务及关闭服务。淘宝在每年的"双十一"促销中就使用这种方法，在系统最繁忙的时段关闭"评价"、"确认收货"等非核心服务，以保证核心交易服务的顺利完成
     幂等性设计：必须在服务层保证服务重复调用和调用一次产生的结果相同，即服务具有幂等性
4.保证数据存储高可用的手段主要是数据备份和失效转移机制
5.CAP原理
     为了保证数据的高可用，网站通常会牺牲另一个也很重要的指标：数据一致性
     CAP原理认为，一个提供数据服务的存储系统无法同时满足数据的一致性(Consistency)、数据可用性(Availibility)、分区耐受性(Patition Tolerance，系统具有跨网络分区的伸缩性)这三个条件
     数据一致性又可分为如下几点：
          数据强一致
          数据用户一致
          数据最终一致
6.数据备份
     早期的数据备份手段主要是数据冷备，即定期复制到某种存储介质
     冷备的优点是简单和廉价，成本和技术难度都较低，制点是不能保证数据最终一致，同时也不能保证数据可用性
     数据热备分为两种：异步热备方式和同步热备方式
7.失效转移
     失效转移操作由三部分组成：失效确认、访问转移、数据恢复
     失效确认
          系统确认一台服务器是否宕机的手段有两种：心跳检测和应用程序该问失败报告
8.高可用网站的软件质量保证
     网站为了保证线上系统的可用性而采取的一些与传统软件开发不同的质量保证手段
     网站发布
     自动化测试
     预发布验证
     代码控制
     自动化发布
     灰度发布
9.网站运行监控
     "不允许没有监控的系统上线"，是许多网站架构师在做项目上线评审时常说的一句话
     监控数据采集
          用户行为日志收集
               用户行为日志指用户在浏览器上所做的所有操作及其所在的操作环境
          服务器性能监控
               收集服务器性能指标，如系统Load、内存占用、磁盘IO、网络IO等对尽早做出故障预警，及时判断应用状况，防患于未然
               目前网站使用比较广泛的开源性能监控工具是Ganglia，它支持大规模服务器集群，并支持以图形的方式在浏览器展示实时性能曲线
          运行数据报告
10.监控管理
     系统报警
          各项监控指标基本稳定在一个特定水平，如果超过某个阈值，就意味着系统可能将要出现故障，报警方式除了邮件，即时通信工具，还可以配置手机短信，语音报警
     失效转移
     自动优雅降级
          为应付突然爆发的访问高峰，主动关闭部分功能，释放部分系统资源，保证网站核心功能正常访问
【6】永无止境：网站的伸缩性架构
1.所谓网站的伸缩性是指不需要改变网站的软硬件设计，仅仅通过改变部署的服务器数量就可以扩大或者综小网站的服务处理能力
2.大型网站的"大型"
     在用户层面可以理解为大量用户及大量访问，如Facebook有超过10亿用户
     在功能方面可以理解为功能庞杂、产品众多，如腾讯有超过1600种产品
     在技术层面可以理解为网站需要部署大量的服务器，如Google大约有近100万台服务器
3.渐进式的演化过程，最重要的技术手段就是使用服务器集群。只要技术上能做到向集群中加入服务器的数量和集群的处理能力成线性关系，那么网站就可以以此手段不断提升自己的规模，从一个服务几十人的小网站发展成服务几十亿人的大网站，从只能存储几个G图片的小网站发展成存储几百P图片的大网站
4.演化过程总体来说是渐进式的，而且总是在"伸"，也就是网站的规模和服务器的规模总是在不断扩大(通常，一个需要"缩"的网站可能已经无法经营下去了)
     但是这个过程也可能因为运营上的需要而出现脉冲，比强促销活动：在某个短时间内，网站的访问量和交易规模突然爆发式增长，然后又回归正常状态。这时就需要网站的技术架构具有极好的伸缩性--活动期间向服务器集群中加入更多服务器(及向网络服务商租借更多的网络带宽)以满足用户访问，活动结束后又将这些服务器下线以节约成本
5.国内有许多传统企业"触网"，将传伭业务搬上互联网，这是一件值得称道的事，传统行业与互联网结合将会创造出新的经济模式，改善人们的生活。但遗憾的是，有些传统企业将自己的管理模式和经营理念也照搬到互联网领域--在技术方面的表现就是一开始就企图打造一个大型网站
6.网站架构的伸缩性设计分成两类
     不同功能进行物理分离实现伸缩
          新增服务器总是从现有服务器中分离出部分功能和服务
          比如：单一服务器处理所有服务->数据库从应用服务器分离->缓存从应用服务器分离->静态资源从应用服务器分离
          具体又可分两种情况
               纵向分离(分层后分离)：将业务处理流程上的不同部分分离部署，实现系统伸缩性
               横向分离(业务分割后分离)：将不同的业务模块分离部署，实现系统伸缩性
     单一功能通过集群规模实现伸缩
          将不同功能分离部署可以实现一定程度的伸缩性，但单一的服务器也不能满足业务规模的要求
          困此必须使用服务器集群，即将相同服务部署在多台服务器上构成一个集群整体对外提供服务
7.具体来说，集群伸缩性又可分两种
     (1 应用服务器集群伸缩性
          HTTP请求分发装置被称作负载均衡服务器
          实现负载均衡的基础技术不外以下几种
               (1)HTTP重定向负载均衡
                    简单，但浏览器需两次请求才能完成一次访问，性能较差，重定向服务器自身的处理能力有可能成为瓶颈
               (2)DNS域名解析负载均衡
                    DNS服务器中配置多个A记录，将负载均衡的工作转交给DNS，但目前的DNS是多级解析，每一级DNS都可能缓存A记录，即使修改了DNS的A记录，要使其生效也需要较长时间，而且DNS负载均衡的控制权在域名服务商那里
                    事实上，大型网站总是部分使用DNS域名解析，作为第一级负载均衡手段，即域名解析得到的一组服务器并不是实际提供Web服务的物理服务器，而是同样的提供负载均衡服务的内部服务器
               (3)反向代理负载均衡
                    在部署位置上，反向代理服务器处于Web服务器前面，也正好是负载均衡服务器的位置
                    由于Web服务器不直接对外提供访问，因此Web服务器不需要使用外部IP地址，而反向代理服务器则需要配置双网卡和内部外部两套IP地址
                    由于反向代理服务器转发请求在HTTP协议层面，因此也叫应用层负载均衡。优点是和反向代理服务器功能集成在一起，部署简单，缺点是反向代理服务器是所有请求和响应的中转站，其性能可能会成为瓶颈
               (4)IP负载均衡
                    在网络层通过修改请求目标地址进行负载均衡
               (5)数据链路层负载均衡
                    指在通信协议的数据链路层修改mac地址进行负载均衡
                    这种数据传输方式又称作三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址，通过配置真实物理服务器集群所有机器虚拟IP和负载均衡服务器IP地址一致，从而达到不修改数据包的源地址和目的地址就可以进行数据分发的目的，避免负载均衡服务器网卡带宽成为瓶颈，又称作直接路由方式(DR)
                    目前大型网站使用最广的一种负载均衡手段。在Linux平台上最好的链路层负载均衡开源产品是LVS(Linux Virtual Server)
               (6)负载均衡算法
                    轮询(Round Robin,RR)
                         所有请求被依次分发到每台应用服务器上，适合应用服务器硬件都相同的场景
                    加权轮询(Weighted Round Robin,WRR)
                         在轮询基础上，按照  配置的权重将请求分发，适合应用服务器硬件性能不同的场景
                    随机(Random)
                         随机分配，简单实用，即使硬件配置不同，也可用加权随机算法
                    最少连接(Least Connections)
                         记录每个应用服务器正在处理的连接数(请求数)，将新的请求分发到最少连接的服务器上，是最符合负载均衡定义的算法，也可实现加权最少连接
                    源地址散列(Source Hashing)
                         根据请求来源的IP地址Hash计算，得到应用服务器
     (2 分布式缓存集群的伸缩性设计
          分布式缓存的一致性Hash算法
          一致性Hash算法通过一个叫作一致性Hash环的数据结构实现KEY到缓存服务器的Hash映射
          一致性Hash算法原理：具体算法过程为，先构造一个长度为0~2^32的整数环，根据节点名称的Hash值(其分布范围同样为0~2^32)将缓存服务器节点放置在之个Hash环上。然后根据需要缓存的数据的KEY值计算得到其Hash值(其分布范围也同样为0~2^32)，然后在Hash环上顺时针查找距离这个KEY的Hash值最近的缓存服务器节点，完成KEY到服务器的Hash映射查找
          随着集群规模越大，继续命中原有缓存数据的概率也逐渐增大，但仍然有小部分数据缓存在服务器中不能被读到，但是这个比例足够小，通过访问数据库获取也不会对数据库造成致命的负载压力
          一致性Hash环通常使用二叉查找树实现
          存在一个小小的问题，原来不受影响节点缓存数据量和负载压力是受影响的两倍，如果机器性能一样，这种结果显然不是我们需要的
          计算机领域有句话：计算机的任何问题都可以通过增加一个虚拟层来解决。计算机网络的7层协议，每一层都可以看作是下一层的虚拟层；计算机操作系统可以看作是计算机硬件的虚拟层；Java虚拟机可以看作是操作系统的虚拟层
          解决一致性Hash算法带来的负载不均衡问题，可通过使用虚拟层的手段
          最终的结果是：新加入一台缓存服务器，将会较为均匀地影响原来集群中已经存在的所有服务器，也就是说分摊原有缓存服务器集群中所有服务器的一小部分负载
          显然每个物理节点对应的虚拟节点越多，各个物理节点之间的负载越均衡，新加入物理服务器对原有的物理服务器的影响越保持一致(这就是一致性Hash这个名称的由来)。虚拟服务器节点，太多影响性能，太少负载不均衡，一般说来，经验值是150，当然根据集群规模和负载均衡的精度需求，应根据具体情况具体对待
     (3 数据存储服务器集群伸缩性
          缓存的目的是加速数据读取的速度并减轻数据存储服务器的负载压力
          (1)关系型数据库集群的伸缩性设计
               凭借其简单强大的SQL和众多成熟的商业数据库产品，占据了从企业应用到网站系统的大部分业务数据存储服务
               不同业务数据表部署在不同的数据库集群上，即俗称的数据分库。这种方式的制约条件是跨库的表不能进行Join操作
               对一些单表数据仍然很大的表，比如Facebook的用户数据库，淘宝的商品数据库，还需要进行分片，将一张表拆开分别存储在多个数据库中
               目前网站在线业务应用中比较成熟的支持数据分片的分布式关系数据库产品主要有开源的Amoeba和Cobar
               应用程序通过JDBC驱动访问Cobar集群，Cobar服务器根据SQL和分库规则分解SQL，分发到MySQL集群不同的数据库实例上执行。数据库A和数据库B的执行结果返回至SQL执行模块，通过结果合并模块将两个返回结果集合并成一个结果集，最终返回给应用程序，完成在分布数据库中的一次访问请求
          (2)NoSQL数据库的伸缩性设计
               NoSQL，主要指非关系的、分布式的数据库设计模式
               一般而言，NoSQL数据库产品都放弃了关系数据库的两大重要基础：以关系代数为基础的结构化查询语言(SQL)和事务一致性保证(ACID)，而强化基他一些大型网站更关注的特性：高可用性和可伸缩性
               目前看业，应用最广泛的是Apache HBase
               HBase为可伸缩海量数据储存而设计，实现面向在线业务的实时数据访问延迟。HBase的伸缩性主要依赖其可分裂的HRegion及可伸缩的分布式文件系统HDFS实现
               HBase的整体架构：HBase中，数据以HRegion为单位进行管理，也就是说应用程序如果想要访问一个数据，必须先找到HRegion，然后将数据读写操作提交给HRegion，由HRegion完成存储层面的数据操作。每个HRegion中存储一段Key值区间[key1,key2)的数据，HRegionServer是物理服务器，每个HRegionServer上可以启动多个HRegion实例。当一个HRegin中写入的数据太多，达到配置的阈值时，HRegion会分裂成两个HRegion，并将HRegion在整个集群中进行迁移，以使HRegionServer的负载均衡

所有HRegion的信息(存储的Key值区间、所在HRegionServer地址、访问端口号等)都记录在HMaster服务器上，为了保证高可用，HBase启动多个HMaster，并通过Zookeeper(一个支持分布式一致性的数据管理服务)选举出一个主服务器，应用程序通过Zookeeper获得主HMaster的地址，输入Key值获得这个Key所在的HRegionServer地址，然后请求HRegionServer上的HRegino，获得需要的数据。调用时序如图所示。
数据写入过程也是一样，需要先得到HRegion才能继续操作，HRegion会把数据存储在若干个叫作HFile格式的文件中，这些文件使用HDFS分布式文件系统存储，在整个集群内分布并高可用。当一个HRegion中数据量太多时，HRegion(连同HFile)会分裂成两个HRegion，并根据集群中服务器负载进行迁移，如果集群中有新加入的服务器，也就是说有了新的HRegionServer，由于其负载较低，也会把HRegion迁移过去并记录到HMaster，从而实现HBase的线性伸缩
8.高手定律：
     这个世界只有遇不到的问题，没有解决不了的问题，高手之所以成为高手，是因为他们遇到了常人很难遇到的问题，并解决了。所以百度有很多广告搜索的高手，淘宝有很多海量数据的高手，QQ有很多高并发业务的高手，原因大抵如此。一个100万用户的网站，不会遇到1亿用户同时在线的问题；一个拥有100万件商品网站的工程师，可能无法理解一个拥有10亿件商品网站的架构
【7】随需应变：网站的可扩展架构
1.扩展性(Extensibility)
     指对现在系统影响最小的情况下，系统功能可持续扩展或提升的能力
2.伸缩性(Scalability)
     指系统能够通过增加(减少)自身资源规模的方式增强(减少)自己计算处理事务的能力。如果这种增减是成比例的，就被称作线性伸缩性
3.笔者认为，软件架构师最大的价值不在于掌握多少先进的技术，而在于具有将一个大系统切分成N个低耦合的子模块的能力，这些子模块包含横向的业务模块，也包含纵向的基础技术模块。这种能力一部分源自专业的技术和经验，还有一部分源自架构师对业务场景的理解、对人生的把握、甚至对世界的认知
4.模块分布部署以后具体聚合方式主要有分布式消息队列和分布式服务
5.利用分布式消息队列降低系统耦合性
     事件驱动架构(Event Driven Architecture)：通过在低耦合的模块之间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作，典型的EDA架构就是操作系统中常见的生产者消费者模式。最常用的是分布式消息队列
     消息队列利用发布-订阅模式工作，消息发送者发布消息，一个或者多个消息接收者订阅消息。程序之间没有直接耦合，对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展设计
6.分布式消息队列
     队列是一种先进先出的数据结构
7.利用分布式服务打造可复用的业务平台
     是降低系统耦合性的另一个重要手段
     分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一个消息
     分布式服务通过接口分解系统耦合性，不同子系统通过相同的接口描述进行服务调用
     巨无霸应用系统带来问题：
          编译、部署困难
          代码分支管理困难
          数据库连接耗尽
          新增业务困难
          解决方案就是拆分，将模块独立部署，降低系统耦合性。分给向横向
          纵向拆分：将一个大应用拆分为多个小应用，如果新增业务较为独立，那么就直接将其设计部署为一个独立的Web应用系统
          横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务，不需要依赖具体的模块代码，即可快速搭建一个应用系统，而模块内业务逻辑变化的时候，只要接口保持一致就不会影响业务程序和其他模块
          纵向拆分相对较为简单，通过梳理业务，将较少相关的业务剥离，使其成为独立的Web应用。而对于横向拆分，不但需要识别可复用的业务，设计服务接口，规范服务依赖关系，还需要一个完善的分布式服务管理框架
8.Web Service与企业级分布式服务
     用以整合异构系统及构建分布式系统。Web Service原理架构如图
          Service Provider<-WSDL->Service Broker(UDDI)
          Service Requester<-WSDL->Service Broker(UDDI)
          Service Provider<=SOAP=>Service Requester
     服务提供者通过WSDL(Web Services Description Language,Web服务描述语言)向注册中心(Service Broker)描述自身提供的服务接口属性，注册中心使用UDDI(Universal Description,Discovery,and Integration，统一描述、发现和集成)发布服务提供者提供的服务，服务请求者从注册中心检索到服务信息后，通过SOAP(Simple Object Access Protocol，简单对象访问协议)和服务提供者通信，使用相关服务
     缺点：
          臃肿的注册与发现机制
          低效的XML序列化手段
          开销相对较高的HTTP远程通信
          复杂的部署与维护手段
     这些问题导致Web Service难以满足大型网站对系统高性能、高可用、易部署、易维护的要求
9.大型网站分布式服务的需求与特点
     除了以上，还需要支持如下特性
     负载均衡
     失效转移
     高效的远程通信
     整合异构系统
     对应用最少侵入
     版本管理
     实时监控：对于网站应用而言，没有监控的服务是不可能实现高可用的
10.分布式服务框架设计
     Facebook利用Thrift(一个开源的远程服务调用框架)管理其分布式服务，服务的注册、发现及调用，遗憾的是，Facebook没有开源其基于Thrift的分布式服务框架。目前国内有较多成功实施案例的开源分布式服务框架，阿里巴巴的Dubbo(http://code.alibabatech.com/wiki/display/dubbo/Home/)
11.可扩展的数据结构
     许多NoSQL数据库使用的ColumnFamily(列族)设计就是一个解决方案
     最早在Google的Bigtable中使用，是一种面向列族的稀疏矩阵存储格式
     数据表可以包含数百万的字段，使得应用程序的数据结构可以随意扩展
12.利用开放平台建设网站生态圈
     网站的价值在于他的用户创造价值，淘宝的价值在于为人们创造交易的平台；QQ的价值在于为人们创造交流的平台；新浪微博的价值在于为人们创造表达自我的平台。只有用户得到了他们想要的价值，他们才愿意使用网站的服务，网站的存在才有意义
     网站必须提供更多的增值服务才能赚钱。比如，QQ可以卖各种钻石会员服务，淘宝可以出卖商品排名赚钱，新浪微博靠植入广告也能赚点钱。根据长尾效应，这些增值服务的数量越是庞大，种类越是繁多，盈利也就越多。同样，一个网站自己能够开发出的增值服务也是有限的
     大型网站为了更好地服务自己的用户，开发更多的增值服务，会把网站内部的服务封装成一些调用接口开放出去，供外部的第三方开发者使用，这个提供开放接口的平台被称作开放平台
     网站、用户、第三方开发者互相依赖，形成一个网站的生态圈
13.开放平台的架构设计
     API接口：是开放平台暴露给开发者使用的一组API，其形式可以是RESTful、WebService、RPC等各种形式
     协议转换：将各种API输入转换成内部服务可以识别的形式，并将内部服务的返回封装成API的格式
     安全：除了一般应用需要的身份识别、权限控制等安全手段，开放平台还需要分级的访问带宽限制，保证平台资源被第三方应用公平俣理使用，也保护网站服务不会被外部应用拖垮
     审记：记录第三方应用的访问情况，并进行监控、计费等
     路由：将开放平台的各种访问路由映射到具体的内部服务
     流程：将一组离散的服务组织成一个上下文相关的新服务，隐藏服务细节，提供统一接口供开发者调用
【8】固若金汤：网站的安全架构
1.2011年中国互联网领域爆出两桩比较大的安全事故，一桩是2011年6月28日新浪微博遭XSS攻击，另一桩是2011年12月以CSDN为代表的多个网站泄露用户密码和个人信息
2.道高一尺魔高一丈的网站应用攻击与防御
     XSS和SQL注入攻击构成网站应用攻击最主要的两种手段，全球大约70%的Web应用攻击都来自于此，常见的还包括CSRF、Session劫持等手段
3.XSS攻击
     XSS攻击即跨站点脚本攻击(Cross Site Script)，指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，探制用户浏览器进行恶意操作的一种攻击方式
     常见的XSS攻击类型有两种：
          一种是反射，攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的
               攻击者可以采用XSS攻击，偷取用户Cookie、密码等，进而伪造交易、盗窃用户财产、窃取情报
               反射型XSS攻击：用户登录，用户点击该URL，恶意脚本被浏览器解析，攻击者推送含有恶意脚本的URL给用户，向服务器提交非用户意愿的请求
          另外一种持久型XSS攻击，黑客提交含有恶意脚本的请求，保存在被攻击的Web站点的数据库中，用户浏览网页时，恶意脚本被包含在正常页面中，达到攻击的目的
               攻击者发送含有恶意脚本的请求，服务器将恶意脚本保存到数据库，用户浏览服务器页面，将恶意脚本构造到用户响异地页面，浏览器解析页面，恶意脚本被执行
     主要防攻击手段两种：
          消毒：对某些html危险字符转义，可以防止大部分攻击
          HttpOnly：最早由微软提出，即浏览器禁止页面JavaScript访问带有HttpOnly属性的Cookie，不是直接对抗XSS攻击，而是防止XSS攻击者窃取Cookie
4.注入攻击
     两种形式：SQL注入攻击和OS注入攻击
          攻击者发送含有恶意SQL命令的http请求如：http://www.a.com?username=Frank';drop table users:--'，在数据库中执行SQL
     攻击者获取数据库表结构信息的手段有如下几种：
          开源
          错误回显：开启错误回显，500错误会显示到浏览器
          盲注：根据页面变化情况判断SQL语句的执行情况，猜测数据库表结构
     防攻击手段：
          消毒：简单粗暴又有效的手段。通过正则匹配，过滤请求数据中可能注入的SQL
          参数绑定：使用预编译手段
5.CSRF攻击
     Cross Site Request Forgery，跨站点请求伪造，其核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份
     防御手段主要是识别请求者身份，主要有下面几种方法：
          表单Token：在页面表单中增加一个随机数作为Token，服务器检查该值是否存在以确定是否合法
          验证码：是一个糟糕的用户体验，请在必要时使用
          Referer check：HTTP请求头的Referer域中记录着请求来源。很多网站用来实现图片防盗链(图片访问来源不是来自自己网站就拒绝)
6.其他攻击和漏洞
     Error Code：也称作错误回显，Web服务器默认打开，即服务器端未处理的异常堆栈信息会直接输出到客户端浏览器，对程序调试和错误报告有好处，但黑客可故意制造非法输入使系统运行时出错，获得异常信息
     HTML注释：会显示在客户端浏览器。程序最终发布前需要进行代码review或自动扫描，避免HTML注释漏洞
     文件上传：如上传可执行程序，并通过该程序获得服务器端命令执行能力，那么可以在服务器上为所欲为，以此为跳板攻击集群环境的其他机器。最有效的防御手段是设置上传文件白名单，文件类型
     路径遍历：在URL中使用相对路径，遍历系统未开放的目录和文件。防御方法主要是将JS、CSS等资源文件部署在独立服务器、使用独立域名，其他文件不使用静态URL访问，动态参数不包含文件路径信息
7.Web应用防火墙
     ModSecurity是一个开源的Web应用防火墙
     最早只是Apache的一个模块，现已有Java、.NET多个版本，并支持Nginx
8.网站安全漏洞扫描
9.信息加密技术及密钥安全管理
     信息加密技术可分为三类：
     单项散列加密
          指通过对不同输入长度的信息进行散列计算，得到固定长度的输出，计算过程是单向的，即不能对固定长度的输出进行计算从而获得输入信息
          虽然单向散列算法不可逆，但由于人们设置密码具有一定的模式，通过彩虹表(人们常用密码和对应的密文关系表)等手段可以进行猜测式破解
          为加强单向散列计算安全性，还会给散列算法加点盐(salt)，相当于加密的密钥，增加破解的难度
          常用的单向散列算法有MD5、SHA等
          单向散列算法还有一个特点就是输入的任何微小变化都会导致输出的完全不同，被用来生成信息摘要、计算具有高离散程度的随机数等用途
     对称加密
          指加密和解密使用的密钥是同一个密钥
          通常用在信息需要安全交换或存储的场合，如Cookie加密、通信加密等
          优点：算法简单，加解密效率高，系统开销小，适合对大量数据加密
          缺点：加解密使用用一个密钥，远程通信如何安全交换密钥是个难题，如果密钥丢失，所有加密信息也就没有秘密可言了
          常用的对称加密算法有DES算法、RC算法等
     非对称加密
          加解密使用不同密钥，其中一个对外界公开，被称作公钥，另一个只有所有者知道，被称作私钥。用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开
          理论上说，不可能通过公钥计算获得私钥
          数字签名的过程相反，签名者用自己的私钥加密，发送，接收方用签名者的公钥对信息进行解密，获得原始明文信息，由于私钥只有签名者拥有，因此该信息是不可抵赖的，具有签名的性质
          常用的非对称加密的算法有RSA算法等。HTTPS传输中浏览器使用的数字证书实质上是经过权威机构认证的非对称加密的公钥
10.密钥安全管理
     把密钥和算法放在一个独立的服务器上，但成本较高，有可能会成为应用的瓶颈，每次加密、解密都需要进行一次远程服务调用，系统性能开销较大
     将加解密算法放在应用系统中，密钥则放在独立服务器中，实际存储时，密钥被切分成数片，加密后分别保存在不同存储介质中，兼顾定全性又改善了性能
11.信息过滤与反垃圾
     常用的信息过滤与反垃圾手段有以下几种：
     文本匹配：主要解决敏感词过滤的问题，网站维护一份敏感词列表
     分类算法：
          比较简单实用的分类算法有贝斯分类算法，这是一种利用概率统计方法进行分类的算法
          贝叶斯算法得到的分类判断是一个概率值，因此会存在误判(非垃圾邮件判为垃圾邮件)和漏判(垃圾邮件判为非垃圾邮件)
          算法简单，处理速度快，仍是许多实时在线系统反垃圾的首选
第3篇 案例
【9】淘宝网的架构演化案例分析
1.淘宝作为阿里巴巴集团旗下网站
     2003年诞生，2004年，重构，PHP换成了Java，MySQL换成了Oracle，从典型的Linux+Apache+MySQL+PHP(LAMP)架构，MVC框架和ORM框架，分别解决视图与业务逻辑分离的问题和对象与关系数据库解耦的问题，没有使用Struts和Hibernate，而是选择了自己开发MVC框架Webx，而ORM框架选择了IBatis，还开发了另一个重要产品Antx，针对Java平台，应用服务器使用Weblogic，数据库使用Oracle，这些产品都需要昂贵的授权使用费
     成庚子的付费产品和售后支持令业务和市场没有后顾之忧，可以全力以赴地拓展市场
     此后三四年，放弃EJB，引入Spring，用免费的JBoss替代收费的Weblogic，因为其并非物有所值，太过笨重，后来用更轻量级的Jetty替代了JBoss，这时，淘宝架构和技术依然是中庸水平
     淘宝主要开源系统
          Tair：分布式Key/Valule存储引擎，分为持久化和非持久化两种使用方式
          TFS：一个分布式文件系统，适用于海量小文件存储
          OceanBase：分布式数据库系统，支持千亿级别的读写事务
          TDDL：对应用透明的分库分表层和具有众多特性的动态数据源
     随着技术不断发展壮大，逐步放弃使用昂贵的设备和软件，回归到开源的MySQL及NoSQL系统，正如淘宝2003年建站之初的选择。这也再一次验证了辩证法关于事物发展的否定之否定及螺施式上升的普遍规律，仿佛回到原点，但一切已经完全不同了
【10】维基百科的高性能架构设计分析
1.www.wikipedia.org，2001年创建，使用Perl CGI脚本编写的只有一台服务器的网站，到2012年流量排名全球第6的大型网站
2.Wikipedia架构的主要组成部分如下：
     GeoDNS：基于开源域名服务器软件BIND的增强版本，可将域名解析到离用户最近的服务器
     LVS：基于Linux的开源负载均衡服务器
     Squid：基于Linux的开源反向代理服务器
     Lighttpd：开源的应用服务器，较主流的Apache服务器更轻量、更快速
     PHP：免费的Web应用程序开发语言，最流行的网站建站语言
     Memcached：无中心高性能的开源分布式缓存系统，稳定、可靠、历久弥新，是网站分布式缓存服务必备的
     Lucene：由Apache出品，Java开发的开源全文搜索引擎
     MySQL：开源的关系数据库管理系统，虽被Oracle收购，但开源社区将其继续开源发展的决心不动摇
3.Wikipedia性能优化策略
     前端性能优化
          指应用服务器(也就是PHP服务器)之前的部分，包括DNS服务、CDN服务、反向代理服务、静态资源服务等。以上的用户请求可以通过前端服务返回，请求根本不会到达应用服务器
     服务端性能优化
          服务端主要是PHP服务器，是网站业务逻辑的核心部分，将最好的服务器部署在这里，从硬件上改善性能
          使用APC，一个PHP字节缓存模块，可加速代码执行减少资源消耗
          使用Imagemagick进行图片处理和转化
          使用Text进行文本格式化，特别是将科学公式内容转换成图片格式
          替换PHP的字符串查找函数strtr()，使用更优化的算法重构
     后端性能优化
          包括缓存、存储、数据库等被应用服务器依赖的服务都可归类为后端服务
          主要手段是使用缓存
【11】海量分布式存储系统Doris的高可用架构设计分析
1.Doris(https://github.com/itisaid/Doris)是一个海量分布式的KV存储系统。跟主流的NoSQL系统HBase相比(Doris0.1 vs. HBase0.90)，Doris具有相似的性能和线性伸缩能力，并具有更好的可用性及更友好的图形用户管理界面
2.对于一个数据存储系统而言，高可用意味着两个意思
     高可用的服务：任何时候，宕机、硬盘损坏、系统升级、停机维护、集群扩容等各种情况，都可以对系统进行读写访问操作
     高可靠的数据：任何情况下，数据可靠存储，不丢失
【12】网购秒杀系统架构设计案例分析
1.秒杀是电子商务网站常见的一种营销手段：将少量商品(通常只有一件)以极低的价格，在特定的时间点开始出售
2.秒杀活动的技术挑战
     对现有网站业务造成冲击
     高并发下的应用、数据库负载
     突然增加的网张及服务器带宽
     直接下单：下单面面也是一个普通URL
3.秒杀系统的应对策略
     秒杀系统独立部署：还可以使用独立的域名，使其完全隔离，不对网站造成任何影响
     秒杀商品页面静态化
     租供秒杀活动网络带宽
     动态生成随机下单页面URL：避免用户直接访问下单页面URL，需要动态化
【13】大型网站典型故障案例分析
1.如果没有经历过，就永远不会想到的问题，而这些问题只要在大型网站技术一线呆上两三年，就一定会碰到
2.一位网站资深架构师曾经说过：在互联网公司呆一年，相当于在传统软件公司呆三年。意思大概是在互联网公司一年遇到的问题比传统软件公司三年遇到的问题还多
3.大型网站的架构师最有价值的地方不在于他们掌握了多少技术，而在于他们经历过多少故障
4.写日志也会引发故障
     开发人员将log输出的level全局配置为Debug，这样一次简单的Web请求就会产生大量的log文件输出，在高并发的用户请求下，很快就消耗完不多的磁盘空间
     经验教训：日志输出级别至少为Warn
5.高并发访问数据库引发的故障
     某条SQL执行频率非常高，发现被首页应用调用
     经验教训：首页不应该访问数据库，首页需要的数据可以从缓存服务器或者搜索引擎服务器获取；首页最好是静态的
6.高并发情况下锁引发的故障
     程序中某个单例对象中多处使用了synchronized(this)，由于this对象只有一个，所有的并发请滶都要排队获得这唯一的一把锁
     经验教训：使用锁操作要谨慎
7.缓存引发的故障
     缓存服务器在网站服务器集群中的地位一直比较低
     经验教训：当缓存已经不仅仅是改善性能，而是成为网站架构不可或缺的一部分时，对缓存的管理就需要提高到和其他服务器一样的级别
8.应用启动不同步引发的故障
     应用程序Web环境使用Apache+JBoss的模式，用户请求通过Apache转发JBoss。发布时，同时启动，JBoss启动时需加载很多应用并初始化，时间长，还没完全启动，Apache已启动完毕并开始接收请求，大量请求阻塞在JBoss进程中，最终导致JBoss崩溃
     经验教训：在应用程序中加入一个特定的动态页面(比如只返回OK两个字母)，启动脚本先启动JBoss，然后在脚本中不断用curl命令访问这个特定页面，直到收到OK，才启动Apache
9.大文件读写独占磁盘引发的故障
     图片需要使用存储，最有可能出错的地方是存储服务器。检查时发现大部分文件几百KB，而有几个文件非常大，数百兆，读写这些大文件一次需要几十秒，这段时间，磁盘基本被这个文件操作独占，导致其他用户的文件操作缓慢
     经验教训：存储的使用需要根据不同文件类型和用途进行管理，图片小文件不能和大文件共用存储。批处理用的大文件可以使用其他类型的分布式文件系统
10.滥用生产环境引发的故障
     工程师在线上生产环境进行性能压力测试，占用大部分交换机带宽
     经验教训：访问线上生产环境要规范，不小心就会导致大事故
11.不规范的流程引发的故障
     应用发布后出现大量数据库读操作，经检查，数据已经被缓存了。检查代码，发现访问缓存的代码被注释掉了。工程师为测试方便，注释掉后未去掉，直接提交到代码库被发布到线上环境
     经验教训：代码提交前使用diff命令进行代码比较
     加强code review
12.不好的编程习惯引发的故障
     经验教训：程序在处理一个输入的对象时，如果不能明确该对象是否为空，必须做空指针判断
     程序在调用其他方法时，输入的对象尽量保证不是null，必要时构造空对象(使用空对象模式)
第4篇 架构师
【14】 架构师领导艺术
1.笔者以架构师的角色参与软件产品的开发，产品经过一年多的发展，已在一些企业用户中成功实施。项目后期，由于产品整体架构设计比较合理，各佃功能模块的扩展性良好，架构师基本没有什么事情可做，加上一些其他因素，笔者打算辞职
2.在软件开发过程中，架构师除了实现技术架构，完成产品技术实现外，还需要和项目组内外各种角色沟通协调，可以说架构师相当多的时间用在和人打交道上。处理好人的关系对架构和项目的成功至关重要
3.架构师是项目组最资深的专业技术人员，是开发测试工程师的前辈。从架构师身上，工程师可以看到自己的未来，因此架构师在做人做事方面需要严格要求自己，做好表率
4.最好的软件项目管理不是制订计划，组织资源，跟踪修正项目进展，对成员激励和惩罚，而是发掘项目组每个成员的优秀潜能
5.每个人都是为实现自我价值而努力，不是为了领工资而工作
【15】网站架构师职场攻略
1.给上司提封闭式问题，给下属提开放式问题
     不要问上司"你觉得该怎么办？"这种没有建设性的开放式问题
     公司付你薪水不是让你睁着迷茫的眼睛卖萌
     给上司提问应该是"你觉得A和B两个方案哪个更好？"这种封闭式问题
     给下属提问题则相反，用开放式的问题启发他去思考，寻找创新的解决方案
     所以，只有"元方，你怎么看？"，而没有"大人，你怎么看？"
【16】漫话网站架构师
【附录A 大型网站架构技术一览】
1.前端架构
     前端指用户请求到达网站应用服务器之前经历的环境，通常不包含网站业务逻辑，不处理动态内容
     浏览器优化技术
          并不是优化浏览器，而是通过优化响应页面，加快浏览器页面的加载和显示，常用的有页面缓存、合并HTTP减少请求次数、使用页面压缩等
     CDN
          内容分发网络，部署在网络运营商机房，通过将静态页面内容分发到离用户最近的CDN服务器，使用户可以通过最短路径获取内容
     动静分离，静态资源独立部署
     图片服务
     反向代理
     DNS
          域名服务，将域名解析成IP地址，利用DNS可以实现DNS负载均衡，配置CDN也需要修改DNS，使域名解析后指向CDN服务器
2.应用层架构
     应用层是处理网站主要业务逻辑的地方
     开发框架
     页面渲染
     负载均衡
     Session管理
     动态页面静态化
     业务拆分
     虚拟化服务器
3.服务层架构
     提供基础服务，供应用层调用，完成网站业务
     分布式消息
     分布式服务
     分布式缓存
     分布式配置
4.存储层架构
     提供数据、文件的持久化存储访问与管理服务
     分布式文件
     关系数据库
          关系数据库对集群伸缩性的支持比较差。通过在应用程序的数据访问层增加数据库访问路由功能，根据业务配置将数据库访问路由到不同的物理数据库上，可实现关系数据库的分布式访问
     NoSQL数据库
          目前各种NoSQL数据库层出不穷，在内存管理、数据模型、集群分布式管理等方面各有优势，不过从社区活跃性解度看，HBae无疑是目前最好的
     数据同步
5.后台架构
     网站应用中，除了要处理用户的实时访问请求外，还有一些后台非实时数据分析要处理
     搜索引擎
     数据仓库
     推荐系统
6.数据采集与监控
     监控网站访问情况与系统运行情况，为网站运营决策和运维管理提供支持保障
     浏览器数据采集
         通过在网站页面中嵌入JS脚本采集用户浏览器环境与操作记录，分析用户行为
     服务器业务数据采集
     服务器性能数据采集
     系统监控
          将前述采集的数据以图表的方式展示，以便运营和运维人员监控网站运行状况，做到这一步仅仅是系统监视。更先进的做法是根据采集的数据进行自动化运维，自动处理系统异常状态，实现自动化控制
     系统报警
7.安全架构
     保护网站免遭攻击及敏感信息汇露
     Web攻击
          以HTTP请求的方式发起的攻击，危害最大的就是XSS和SQL注入攻击。但是只要措施得当，这两种攻击都是比较容易防范的
     数据保护
          敏感信息加密传输与存储，保护网站和用户资产
8.数据中心机房架构
     大型网站需要的服务器规模数以十万计，机房物理架构也需要关注
     机房架构
     机框架构
     服务器架构

</pre>
						</label>
					</label>
				</label>
			</label>
			<label>结束语</label>
			<label>
				<label>
<pre>   
  以上就是个人两个爱好之一电脑里面的编程这两年学到的几乎全部东西，准确的说是2016年6月11号到咋天这半年的读书笔记，因为大部分内容都是在此期间所学。</br></br>
  哪怕早一两天，我也会成为高级软件工程师，至于为什么的话，"不想当将军的士兵不是好士兵"，虽然不太懂这句话的意思，但大概就这意思，但什么是高级软件工程师呢？233。这份总结是我目前的知识框架，还不完善，也许到完善的那一天，目标就能实现了吧。</br></br>
  也曾认真想过，这里有优秀的人和良好的环境，不过可能是自己比较固执吧，不论对错，已定下的决定就要执行，至于想法的根源的话，可能是这座城市没有自己想要找的东西吧。新的城市，会认识新的人，也许自己还是什么都无法改变，但至少向外踏了一步。</br></br>
  突然想到了薪资，薪资和能力成正比，不管别人怎么样，我是这样要求自己的，自己什么水平自己心里清楚。高薪是努力过的证明，努力不是为了高薪，高薪只是一个证明。</br></br>
  到了一人一句话时间，写了但是又删了，就说两句吧：</br></br>
    张灿，魔方虽然舍弃了原来40s+的方法，曾一度回到了一分钟，现在最好成绩100次平均34.95s，没来得及让你看到20s+的水平，抱歉啊。</br></br>
    东平，虽然比你小半岁，233，但做为你的前辈，请让我走在你的前面吧。</br></br>
  因为眼睛近视度数有些深，即便戴眼镜走路也没有看人的习惯，没能好好跟大家打招呼，对不起；因经验不足，一直以来也给大家添了不少麻烦，对不起。最后，也谢谢大家一直以来的关照。</br></br>
  有时总感觉，从一开始什么都不会的自己能来到这里真是太好了。
</pre>
				</label>
			</label>
		</label>
		<label id="to_back_page">返回</label>
		<label>
			<label></label>
		</label>
		<label id="to_first_page">首页</label>
		<label>
			<label></label>
		</label>
	</div>
</body>
<script type="text/javascript">
//原生JS，压缩版，可忽视
(function(e,t){var n,r,i=typeof t,o=e.location,a=e.document,s=a.documentElement,l=e.jQuery,u=e.$,c={},p=[],f="1.10.2",d=p.concat,h=p.push,g=p.slice,m=p.indexOf,y=c.toString,v=c.hasOwnProperty,b=f.trim,x=function(e,t){return new x.fn.init(e,t,r)},w=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,T=/\S+/g,C=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,k=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,E=/^[\],:{}\s]*$/,S=/(?:^|:|,)(?:\s*\[)+/g,A=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,j=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,D=/^-ms-/,L=/-([\da-z])/gi,H=function(e,t){return t.toUpperCase()},q=function(e){(a.addEventListener||"load"===e.type||"complete"===a.readyState)&&(_(),x.ready())},_=function(){a.addEventListener?(a.removeEventListener("DOMContentLoaded",q,!1),e.removeEventListener("load",q,!1)):(a.detachEvent("onreadystatechange",q),e.detachEvent("onload",q))};x.fn=x.prototype={jquery:f,constructor:x,init:function(e,n,r){var i,o;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof x?n[0]:n,x.merge(this,x.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:a,!0)),k.test(i[1])&&x.isPlainObject(n))for(i in n)x.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(o=a.getElementById(i[2]),o&&o.parentNode){if(o.id!==i[2])return r.find(e);this.length=1,this[0]=o}return this.context=a,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):x.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),x.makeArray(e,this))},selector:"",length:0,toArray:function(){return g.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=x.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return x.each(this,e,t)},ready:function(e){return x.ready.promise().done(e),this},slice:function(){return this.pushStack(g.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(x.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:h,sort:[].sort,splice:[].splice},x.fn.init.prototype=x.fn,x.extend=x.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},l=1,u=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},l=2),"object"==typeof s||x.isFunction(s)||(s={}),u===l&&(s=this,--l);u>l;l++)if(null!=(o=arguments[l]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(x.isPlainObject(r)||(n=x.isArray(r)))?(n?(n=!1,a=e&&x.isArray(e)?e:[]):a=e&&x.isPlainObject(e)?e:{},s[i]=x.extend(c,a,r)):r!==t&&(s[i]=r));return s},x.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),noConflict:function(t){return e.$===x&&(e.$=u),t&&e.jQuery===x&&(e.jQuery=l),x},isReady:!1,readyWait:1,holdReady:function(e){e?x.readyWait++:x.ready(!0)},ready:function(e){if(e===!0?!--x.readyWait:!x.isReady){if(!a.body)return setTimeout(x.ready);x.isReady=!0,e!==!0&&--x.readyWait>0||(n.resolveWith(a,[x]),x.fn.trigger&&x(a).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===x.type(e)},isArray:Array.isArray||function(e){return"array"===x.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?c[y.call(e)]||"object":typeof e},isPlainObject:function(e){var n;if(!e||"object"!==x.type(e)||e.nodeType||x.isWindow(e))return!1;try{if(e.constructor&&!v.call(e,"constructor")&&!v.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}if(x.support.ownLast)for(n in e)return v.call(e,n);for(n in e);return n===t||v.call(e,n)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||a;var r=k.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=x.buildFragment([e],t,i),i&&x(i).remove(),x.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=x.trim(n),n&&E.test(n.replace(A,"@").replace(j,"]").replace(S,"")))?Function("return "+n)():(x.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||x.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&x.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(D,"ms-").replace(L,H)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:b&&!b.call("\ufeff\u00a0")?function(e){return null==e?"":b.call(e)}:function(e){return null==e?"":(e+"").replace(C,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?x.merge(n,"string"==typeof e?[e]:e):h.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(m)return m.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return d.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),x.isFunction(e)?(r=g.call(arguments,2),i=function(){return e.apply(n||this,r.concat(g.call(arguments)))},i.guid=e.guid=e.guid||x.guid++,i):t},access:function(e,n,r,i,o,a,s){var l=0,u=e.length,c=null==r;if("object"===x.type(r)){o=!0;for(l in r)x.access(e,n,l,r[l],!0,a,s)}else if(i!==t&&(o=!0,x.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(x(e),n)})),n))for(;u>l;l++)n(e[l],r,s?i:i.call(e[l],l,n(e[l],r)));return o?e:c?n.call(e):u?n(e[0],r):a},now:function(){return(new Date).getTime()},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),x.ready.promise=function(t){if(!n)if(n=x.Deferred(),"complete"===a.readyState)setTimeout(x.ready);else if(a.addEventListener)a.addEventListener("DOMContentLoaded",q,!1),e.addEventListener("load",q,!1);else{a.attachEvent("onreadystatechange",q),e.attachEvent("onload",q);var r=!1;try{r=null==e.frameElement&&a.documentElement}catch(i){}r&&r.doScroll&&function o(){if(!x.isReady){try{r.doScroll("left")}catch(e){return setTimeout(o,50)}_(),x.ready()}}()}return n.promise(t)},x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){c["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=x.type(e);return x.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=x(a),function(e,t){var n,r,i,o,a,s,l,u,c,p,f,d,h,g,m,y,v,b="sizzle"+-new Date,w=e.document,T=0,C=0,N=st(),k=st(),E=st(),S=!1,A=function(e,t){return e===t?(S=!0,0):0},j=typeof t,D=1<<31,L={}.hasOwnProperty,H=[],q=H.pop,_=H.push,M=H.push,O=H.slice,F=H.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},B="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",P="[\\x20\\t\\r\\n\\f]",R="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",W=R.replace("w","w#"),$="\\["+P+"*("+R+")"+P+"*(?:([*^$|!~]?=)"+P+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+W+")|)|)"+P+"*\\]",I=":("+R+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+$.replace(3,8)+")*)|.*)\\)|)",z=RegExp("^"+P+"+|((?:^|[^\\\\])(?:\\\\.)*)"+P+"+$","g"),X=RegExp("^"+P+"*,"+P+"*"),U=RegExp("^"+P+"*([>+~]|"+P+")"+P+"*"),V=RegExp(P+"*[+~]"),Y=RegExp("="+P+"*([^\\]'\"]*)"+P+"*\\]","g"),J=RegExp(I),G=RegExp("^"+W+"$"),Q={ID:RegExp("^#("+R+")"),CLASS:RegExp("^\\.("+R+")"),TAG:RegExp("^("+R.replace("w","w*")+")"),ATTR:RegExp("^"+$),PSEUDO:RegExp("^"+I),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+P+"*(even|odd|(([+-]|)(\\d*)n|)"+P+"*(?:([+-]|)"+P+"*(\\d+)|))"+P+"*\\)|)","i"),bool:RegExp("^(?:"+B+")$","i"),needsContext:RegExp("^"+P+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+P+"*((?:-\\d)?\\d*)"+P+"*\\)|)(?=[^-]|$)","i")},K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,et=/^(?:input|select|textarea|button)$/i,tt=/^h\d$/i,nt=/'|\\/g,rt=RegExp("\\\\([\\da-f]{1,6}"+P+"?|("+P+")|.)","ig"),it=function(e,t,n){var r="0x"+t-65536;return r!==r||n?t:0>r?String.fromCharCode(r+65536):String.fromCharCode(55296|r>>10,56320|1023&r)};try{M.apply(H=O.call(w.childNodes),w.childNodes),H[w.childNodes.length].nodeType}catch(ot){M={apply:H.length?function(e,t){_.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function at(e,t,n,i){var o,a,s,l,u,c,d,m,y,x;if((t?t.ownerDocument||t:w)!==f&&p(t),t=t||f,n=n||[],!e||"string"!=typeof e)return n;if(1!==(l=t.nodeType)&&9!==l)return[];if(h&&!i){if(o=Z.exec(e))if(s=o[1]){if(9===l){if(a=t.getElementById(s),!a||!a.parentNode)return n;if(a.id===s)return n.push(a),n}else if(t.ownerDocument&&(a=t.ownerDocument.getElementById(s))&&v(t,a)&&a.id===s)return n.push(a),n}else{if(o[2])return M.apply(n,t.getElementsByTagName(e)),n;if((s=o[3])&&r.getElementsByClassName&&t.getElementsByClassName)return M.apply(n,t.getElementsByClassName(s)),n}if(r.qsa&&(!g||!g.test(e))){if(m=d=b,y=t,x=9===l&&e,1===l&&"object"!==t.nodeName.toLowerCase()){c=mt(e),(d=t.getAttribute("id"))?m=d.replace(nt,"\\$&"):t.setAttribute("id",m),m="[id='"+m+"'] ",u=c.length;while(u--)c[u]=m+yt(c[u]);y=V.test(e)&&t.parentNode||t,x=c.join(",")}if(x)try{return M.apply(n,y.querySelectorAll(x)),n}catch(T){}finally{d||t.removeAttribute("id")}}}return kt(e.replace(z,"$1"),t,n,i)}function st(){var e=[];function t(n,r){return e.push(n+=" ")>o.cacheLength&&delete t[e.shift()],t[n]=r}return t}function lt(e){return e[b]=!0,e}function ut(e){var t=f.createElement("div");try{return!!e(t)}catch(n){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function ct(e,t){var n=e.split("|"),r=e.length;while(r--)o.attrHandle[n[r]]=t}function pt(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&(~t.sourceIndex||D)-(~e.sourceIndex||D);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function ft(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function dt(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function ht(e){return lt(function(t){return t=+t,lt(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}s=at.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},r=at.support={},p=at.setDocument=function(e){var n=e?e.ownerDocument||e:w,i=n.defaultView;return n!==f&&9===n.nodeType&&n.documentElement?(f=n,d=n.documentElement,h=!s(n),i&&i.attachEvent&&i!==i.top&&i.attachEvent("onbeforeunload",function(){p()}),r.attributes=ut(function(e){return e.className="i",!e.getAttribute("className")}),r.getElementsByTagName=ut(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),r.getElementsByClassName=ut(function(e){return e.innerHTML="<div class='a'></div><div class='a i'></div>",e.firstChild.className="i",2===e.getElementsByClassName("i").length}),r.getById=ut(function(e){return d.appendChild(e).id=b,!n.getElementsByName||!n.getElementsByName(b).length}),r.getById?(o.find.ID=function(e,t){if(typeof t.getElementById!==j&&h){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){return e.getAttribute("id")===t}}):(delete o.find.ID,o.filter.ID=function(e){var t=e.replace(rt,it);return function(e){var n=typeof e.getAttributeNode!==j&&e.getAttributeNode("id");return n&&n.value===t}}),o.find.TAG=r.getElementsByTagName?function(e,n){return typeof n.getElementsByTagName!==j?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},o.find.CLASS=r.getElementsByClassName&&function(e,n){return typeof n.getElementsByClassName!==j&&h?n.getElementsByClassName(e):t},m=[],g=[],(r.qsa=K.test(n.querySelectorAll))&&(ut(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||g.push("\\["+P+"*(?:value|"+B+")"),e.querySelectorAll(":checked").length||g.push(":checked")}),ut(function(e){var t=n.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("t",""),e.querySelectorAll("[t^='']").length&&g.push("[*^$]="+P+"*(?:''|\"\")"),e.querySelectorAll(":enabled").length||g.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),g.push(",.*:")})),(r.matchesSelector=K.test(y=d.webkitMatchesSelector||d.mozMatchesSelector||d.oMatchesSelector||d.msMatchesSelector))&&ut(function(e){r.disconnectedMatch=y.call(e,"div"),y.call(e,"[s!='']:x"),m.push("!=",I)}),g=g.length&&RegExp(g.join("|")),m=m.length&&RegExp(m.join("|")),v=K.test(d.contains)||d.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},A=d.compareDocumentPosition?function(e,t){if(e===t)return S=!0,0;var i=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t);return i?1&i||!r.sortDetached&&t.compareDocumentPosition(e)===i?e===n||v(w,e)?-1:t===n||v(w,t)?1:c?F.call(c,e)-F.call(c,t):0:4&i?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return S=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:c?F.call(c,e)-F.call(c,t):0;if(o===a)return pt(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?pt(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},n):f},at.matches=function(e,t){return at(e,null,null,t)},at.matchesSelector=function(e,t){if((e.ownerDocument||e)!==f&&p(e),t=t.replace(Y,"='$1']"),!(!r.matchesSelector||!h||m&&m.test(t)||g&&g.test(t)))try{var n=y.call(e,t);if(n||r.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(i){}return at(t,f,null,[e]).length>0},at.contains=function(e,t){return(e.ownerDocument||e)!==f&&p(e),v(e,t)},at.attr=function(e,n){(e.ownerDocument||e)!==f&&p(e);var i=o.attrHandle[n.toLowerCase()],a=i&&L.call(o.attrHandle,n.toLowerCase())?i(e,n,!h):t;return a===t?r.attributes||!h?e.getAttribute(n):(a=e.getAttributeNode(n))&&a.specified?a.value:null:a},at.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},at.uniqueSort=function(e){var t,n=[],i=0,o=0;if(S=!r.detectDuplicates,c=!r.sortStable&&e.slice(0),e.sort(A),S){while(t=e[o++])t===e[o]&&(i=n.push(o));while(i--)e.splice(n[i],1)}return e},a=at.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=a(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=a(t);return n},o=at.selectors={cacheLength:50,createPseudo:lt,match:Q,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(rt,it),e[3]=(e[4]||e[5]||"").replace(rt,it),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||at.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&at.error(e[0]),e},PSEUDO:function(e){var n,r=!e[5]&&e[2];return Q.CHILD.test(e[0])?null:(e[3]&&e[4]!==t?e[2]=e[4]:r&&J.test(r)&&(n=mt(r,!0))&&(n=r.indexOf(")",r.length-n)-r.length)&&(e[0]=e[0].slice(0,n),e[2]=r.slice(0,n)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(rt,it).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=N[e+" "];return t||(t=RegExp("(^|"+P+")"+e+"("+P+"|$)"))&&N(e,function(e){return t.test("string"==typeof e.className&&e.className||typeof e.getAttribute!==j&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=at.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,l){var u,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!l&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[b]||(m[b]={}),u=c[e]||[],d=u[0]===T&&u[1],f=u[0]===T&&u[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[T,d,f];break}}else if(v&&(u=(t[b]||(t[b]={}))[e])&&u[0]===T)f=u[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[b]||(p[b]={}))[e]=[T,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=o.pseudos[e]||o.setFilters[e.toLowerCase()]||at.error("unsupported pseudo: "+e);return r[b]?r(t):r.length>1?(n=[e,e,"",t],o.setFilters.hasOwnProperty(e.toLowerCase())?lt(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=F.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:lt(function(e){var t=[],n=[],r=l(e.replace(z,"$1"));return r[b]?lt(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:lt(function(e){return function(t){return at(e,t).length>0}}),contains:lt(function(e){return function(t){return(t.textContent||t.innerText||a(t)).indexOf(e)>-1}}),lang:lt(function(e){return G.test(e||"")||at.error("unsupported lang: "+e),e=e.replace(rt,it).toLowerCase(),function(t){var n;do if(n=h?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===d},focus:function(e){return e===f.activeElement&&(!f.hasFocus||f.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!o.pseudos.empty(e)},header:function(e){return tt.test(e.nodeName)},input:function(e){return et.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:ht(function(){return[0]}),last:ht(function(e,t){return[t-1]}),eq:ht(function(e,t,n){return[0>n?n+t:n]}),even:ht(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:ht(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:ht(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:ht(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}},o.pseudos.nth=o.pseudos.eq;for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})o.pseudos[n]=ft(n);for(n in{submit:!0,reset:!0})o.pseudos[n]=dt(n);function gt(){}gt.prototype=o.filters=o.pseudos,o.setFilters=new gt;function mt(e,t){var n,r,i,a,s,l,u,c=k[e+" "];if(c)return t?0:c.slice(0);s=e,l=[],u=o.preFilter;while(s){(!n||(r=X.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),l.push(i=[])),n=!1,(r=U.exec(s))&&(n=r.shift(),i.push({value:n,type:r[0].replace(z," ")}),s=s.slice(n.length));for(a in o.filter)!(r=Q[a].exec(s))||u[a]&&!(r=u[a](r))||(n=r.shift(),i.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?at.error(e):k(e,l).slice(0)}function yt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function vt(e,t,n){var r=t.dir,o=n&&"parentNode"===r,a=C++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||o)return e(t,n,i)}:function(t,n,s){var l,u,c,p=T+" "+a;if(s){while(t=t[r])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[r])if(1===t.nodeType||o)if(c=t[b]||(t[b]={}),(u=c[r])&&u[0]===p){if((l=u[1])===!0||l===i)return l===!0}else if(u=c[r]=[p],u[1]=e(t,n,s)||i,u[1]===!0)return!0}}function bt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function xt(e,t,n,r,i){var o,a=[],s=0,l=e.length,u=null!=t;for(;l>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),u&&t.push(s));return a}function wt(e,t,n,r,i,o){return r&&!r[b]&&(r=wt(r)),i&&!i[b]&&(i=wt(i,o)),lt(function(o,a,s,l){var u,c,p,f=[],d=[],h=a.length,g=o||Nt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:xt(g,f,e,s,l),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,l),r){u=xt(y,d),r(u,[],s,l),c=u.length;while(c--)(p=u[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){u=[],c=y.length;while(c--)(p=y[c])&&u.push(m[c]=p);i(null,y=[],u,l)}c=y.length;while(c--)(p=y[c])&&(u=i?F.call(o,p):f[c])>-1&&(o[u]=!(a[u]=p))}}else y=xt(y===a?y.splice(h,y.length):y),i?i(null,a,y,l):M.apply(a,y)})}function Tt(e){var t,n,r,i=e.length,a=o.relative[e[0].type],s=a||o.relative[" "],l=a?1:0,c=vt(function(e){return e===t},s,!0),p=vt(function(e){return F.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==u)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;i>l;l++)if(n=o.relative[e[l].type])f=[vt(bt(f),n)];else{if(n=o.filter[e[l].type].apply(null,e[l].matches),n[b]){for(r=++l;i>r;r++)if(o.relative[e[r].type])break;return wt(l>1&&bt(f),l>1&&yt(e.slice(0,l-1).concat({value:" "===e[l-2].type?"*":""})).replace(z,"$1"),n,r>l&&Tt(e.slice(l,r)),i>r&&Tt(e=e.slice(r)),i>r&&yt(e))}f.push(n)}return bt(f)}function Ct(e,t){var n=0,r=t.length>0,a=e.length>0,s=function(s,l,c,p,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,C=u,N=s||a&&o.find.TAG("*",d&&l.parentNode||l),k=T+=null==C?1:Math.random()||.1;for(w&&(u=l!==f&&l,i=n);null!=(h=N[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,l,c)){p.push(h);break}w&&(T=k,i=++n)}r&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,r&&b!==v){g=0;while(m=t[g++])m(x,y,l,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=q.call(p));y=xt(y)}M.apply(p,y),w&&!s&&y.length>0&&v+t.length>1&&at.uniqueSort(p)}return w&&(T=k,u=C),x};return r?lt(s):s}l=at.compile=function(e,t){var n,r=[],i=[],o=E[e+" "];if(!o){t||(t=mt(e)),n=t.length;while(n--)o=Tt(t[n]),o[b]?r.push(o):i.push(o);o=E(e,Ct(i,r))}return o};function Nt(e,t,n){var r=0,i=t.length;for(;i>r;r++)at(e,t[r],n);return n}function kt(e,t,n,i){var a,s,u,c,p,f=mt(e);if(!i&&1===f.length){if(s=f[0]=f[0].slice(0),s.length>2&&"ID"===(u=s[0]).type&&r.getById&&9===t.nodeType&&h&&o.relative[s[1].type]){if(t=(o.find.ID(u.matches[0].replace(rt,it),t)||[])[0],!t)return n;e=e.slice(s.shift().value.length)}a=Q.needsContext.test(e)?0:s.length;while(a--){if(u=s[a],o.relative[c=u.type])break;if((p=o.find[c])&&(i=p(u.matches[0].replace(rt,it),V.test(s[0].type)&&t.parentNode||t))){if(s.splice(a,1),e=i.length&&yt(s),!e)return M.apply(n,i),n;break}}}return l(e,f)(i,t,!h,n,V.test(e)),n}r.sortStable=b.split("").sort(A).join("")===b,r.detectDuplicates=S,p(),r.sortDetached=ut(function(e){return 1&e.compareDocumentPosition(f.createElement("div"))}),ut(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||ct("type|href|height|width",function(e,n,r){return r?t:e.getAttribute(n,"type"===n.toLowerCase()?1:2)}),r.attributes&&ut(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||ct("value",function(e,n,r){return r||"input"!==e.nodeName.toLowerCase()?t:e.defaultValue}),ut(function(e){return null==e.getAttribute("disabled")})||ct(B,function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&i.specified?i.value:e[n]===!0?n.toLowerCase():null}),x.find=at,x.expr=at.selectors,x.expr[":"]=x.expr.pseudos,x.unique=at.uniqueSort,x.text=at.getText,x.isXMLDoc=at.isXML,x.contains=at.contains}(e);var O={};function F(e){var t=O[e]={};return x.each(e.match(T)||[],function(e,n){t[n]=!0}),t}x.Callbacks=function(e){e="string"==typeof e?O[e]||F(e):x.extend({},e);var n,r,i,o,a,s,l=[],u=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=l.length,n=!0;l&&o>a;a++)if(l[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,l&&(u?u.length&&c(u.shift()):r?l=[]:p.disable())},p={add:function(){if(l){var t=l.length;(function i(t){x.each(t,function(t,n){var r=x.type(n);"function"===r?e.unique&&p.has(n)||l.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=l.length:r&&(s=t,c(r))}return this},remove:function(){return l&&x.each(arguments,function(e,t){var r;while((r=x.inArray(t,l,r))>-1)l.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?x.inArray(e,l)>-1:!(!l||!l.length)},empty:function(){return l=[],o=0,this},disable:function(){return l=u=r=t,this},disabled:function(){return!l},lock:function(){return u=t,r||p.disable(),this},locked:function(){return!u},fireWith:function(e,t){return!l||i&&!u||(t=t||[],t=[e,t.slice?t.slice():t],n?u.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},x.extend({Deferred:function(e){var t=[["resolve","done",x.Callbacks("once memory"),"resolved"],["reject","fail",x.Callbacks("once memory"),"rejected"],["notify","progress",x.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return x.Deferred(function(n){x.each(t,function(t,o){var a=o[0],s=x.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&x.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?x.extend(e,r):r}},i={};return r.pipe=r.then,x.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=g.call(arguments),r=n.length,i=1!==r||e&&x.isFunction(e.promise)?r:0,o=1===i?e:x.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?g.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,l,u;if(r>1)for(s=Array(r),l=Array(r),u=Array(r);r>t;t++)n[t]&&x.isFunction(n[t].promise)?n[t].promise().done(a(t,u,n)).fail(o.reject).progress(a(t,l,s)):--i;return i||o.resolveWith(u,n),o.promise()}}),x.support=function(t){var n,r,o,s,l,u,c,p,f,d=a.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*")||[],r=d.getElementsByTagName("a")[0],!r||!r.style||!n.length)return t;s=a.createElement("select"),u=s.appendChild(a.createElement("option")),o=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t.getSetAttribute="t"!==d.className,t.leadingWhitespace=3===d.firstChild.nodeType,t.tbody=!d.getElementsByTagName("tbody").length,t.htmlSerialize=!!d.getElementsByTagName("link").length,t.style=/top/.test(r.getAttribute("style")),t.hrefNormalized="/a"===r.getAttribute("href"),t.opacity=/^0.5/.test(r.style.opacity),t.cssFloat=!!r.style.cssFloat,t.checkOn=!!o.value,t.optSelected=u.selected,t.enctype=!!a.createElement("form").enctype,t.html5Clone="<:nav></:nav>"!==a.createElement("nav").cloneNode(!0).outerHTML,t.inlineBlockNeedsLayout=!1,t.shrinkWrapBlocks=!1,t.pixelPosition=!1,t.deleteExpando=!0,t.noCloneEvent=!0,t.reliableMarginRight=!0,t.boxSizingReliable=!0,o.checked=!0,t.noCloneChecked=o.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!u.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}o=a.createElement("input"),o.setAttribute("value",""),t.input=""===o.getAttribute("value"),o.value="t",o.setAttribute("type","radio"),t.radioValue="t"===o.value,o.setAttribute("checked","t"),o.setAttribute("name","t"),l=a.createDocumentFragment(),l.appendChild(o),t.appendChecked=o.checked,t.checkClone=l.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip;for(f in x(t))break;return t.ownLast="0"!==f,x(function(){var n,r,o,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",l=a.getElementsByTagName("body")[0];l&&(n=a.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",l.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",o=d.getElementsByTagName("td"),o[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===o[0].offsetHeight,o[0].style.display="",o[1].style.display="none",t.reliableHiddenOffsets=p&&0===o[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",x.swap(l,null!=l.style.zoom?{zoom:1}:{},function(){t.boxSizing=4===d.offsetWidth}),e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(a.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(l.style.zoom=1)),l.removeChild(n),n=d=o=r=null)}),n=s=l=u=r=o=null,t
}({});var B=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;function R(e,n,r,i){if(x.acceptData(e)){var o,a,s=x.expando,l=e.nodeType,u=l?x.cache:e,c=l?e[s]:e[s]&&s;if(c&&u[c]&&(i||u[c].data)||r!==t||"string"!=typeof n)return c||(c=l?e[s]=p.pop()||x.guid++:s),u[c]||(u[c]=l?{}:{toJSON:x.noop}),("object"==typeof n||"function"==typeof n)&&(i?u[c]=x.extend(u[c],n):u[c].data=x.extend(u[c].data,n)),a=u[c],i||(a.data||(a.data={}),a=a.data),r!==t&&(a[x.camelCase(n)]=r),"string"==typeof n?(o=a[n],null==o&&(o=a[x.camelCase(n)])):o=a,o}}function W(e,t,n){if(x.acceptData(e)){var r,i,o=e.nodeType,a=o?x.cache:e,s=o?e[x.expando]:x.expando;if(a[s]){if(t&&(r=n?a[s]:a[s].data)){x.isArray(t)?t=t.concat(x.map(t,x.camelCase)):t in r?t=[t]:(t=x.camelCase(t),t=t in r?[t]:t.split(" ")),i=t.length;while(i--)delete r[t[i]];if(n?!I(r):!x.isEmptyObject(r))return}(n||(delete a[s].data,I(a[s])))&&(o?x.cleanData([e],!0):x.support.deleteExpando||a!=a.window?delete a[s]:a[s]=null)}}}x.extend({cache:{},noData:{applet:!0,embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(e){return e=e.nodeType?x.cache[e[x.expando]]:e[x.expando],!!e&&!I(e)},data:function(e,t,n){return R(e,t,n)},removeData:function(e,t){return W(e,t)},_data:function(e,t,n){return R(e,t,n,!0)},_removeData:function(e,t){return W(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&x.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),x.fn.extend({data:function(e,n){var r,i,o=null,a=0,s=this[0];if(e===t){if(this.length&&(o=x.data(s),1===s.nodeType&&!x._data(s,"parsedAttrs"))){for(r=s.attributes;r.length>a;a++)i=r[a].name,0===i.indexOf("data-")&&(i=x.camelCase(i.slice(5)),$(s,i,o[i]));x._data(s,"parsedAttrs",!0)}return o}return"object"==typeof e?this.each(function(){x.data(this,e)}):arguments.length>1?this.each(function(){x.data(this,e,n)}):s?$(s,e,x.data(s,e)):null},removeData:function(e){return this.each(function(){x.removeData(this,e)})}});function $(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(P,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:B.test(r)?x.parseJSON(r):r}catch(o){}x.data(e,n,r)}else r=t}return r}function I(e){var t;for(t in e)if(("data"!==t||!x.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}x.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=x._data(e,n),r&&(!i||x.isArray(r)?i=x._data(e,n,x.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=x.queue(e,t),r=n.length,i=n.shift(),o=x._queueHooks(e,t),a=function(){x.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return x._data(e,n)||x._data(e,n,{empty:x.Callbacks("once memory").add(function(){x._removeData(e,t+"queue"),x._removeData(e,n)})})}}),x.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?x.queue(this[0],e):n===t?this:this.each(function(){var t=x.queue(this,e,n);x._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&x.dequeue(this,e)})},dequeue:function(e){return this.each(function(){x.dequeue(this,e)})},delay:function(e,t){return e=x.fx?x.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=x.Deferred(),a=this,s=this.length,l=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=x._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(l));return l(),o.promise(n)}});var z,X,U=/[\t\r\n\f]/g,V=/\r/g,Y=/^(?:input|select|textarea|button|object)$/i,J=/^(?:a|area)$/i,G=/^(?:checked|selected)$/i,Q=x.support.getSetAttribute,K=x.support.input;x.fn.extend({attr:function(e,t){return x.access(this,x.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){x.removeAttr(this,e)})},prop:function(e,t){return x.access(this,x.prop,e,t,arguments.length>1)},removeProp:function(e){return e=x.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,l="string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).addClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=x.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,l=0===arguments.length||"string"==typeof e&&e;if(x.isFunction(e))return this.each(function(t){x(this).removeClass(e.call(this,t,this.className))});if(l)for(t=(e||"").match(T)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(U," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?x.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e;return"boolean"==typeof t&&"string"===n?t?this.addClass(e):this.removeClass(e):x.isFunction(e)?this.each(function(n){x(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var t,r=0,o=x(this),a=e.match(T)||[];while(t=a[r++])o.hasClass(t)?o.removeClass(t):o.addClass(t)}else(n===i||"boolean"===n)&&(this.className&&x._data(this,"__className__",this.className),this.className=this.className||e===!1?"":x._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(U," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=x.isFunction(e),this.each(function(n){var o;1===this.nodeType&&(o=i?e.call(this,n,x(this).val()):e,null==o?o="":"number"==typeof o?o+="":x.isArray(o)&&(o=x.map(o,function(e){return null==e?"":e+""})),r=x.valHooks[this.type]||x.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=x.valHooks[o.type]||x.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(V,""):null==n?"":n)}}}),x.extend({valHooks:{option:{get:function(e){var t=x.find.attr(e,"value");return null!=t?t:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,l=0>i?s:o?i:0;for(;s>l;l++)if(n=r[l],!(!n.selected&&l!==i||(x.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&x.nodeName(n.parentNode,"optgroup"))){if(t=x(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n,r,i=e.options,o=x.makeArray(t),a=i.length;while(a--)r=i[a],(r.selected=x.inArray(x(r).val(),o)>=0)&&(n=!0);return n||(e.selectedIndex=-1),o}}},attr:function(e,n,r){var o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return typeof e.getAttribute===i?x.prop(e,n,r):(1===s&&x.isXMLDoc(e)||(n=n.toLowerCase(),o=x.attrHooks[n]||(x.expr.match.bool.test(n)?X:z)),r===t?o&&"get"in o&&null!==(a=o.get(e,n))?a:(a=x.find.attr(e,n),null==a?t:a):null!==r?o&&"set"in o&&(a=o.set(e,r,n))!==t?a:(e.setAttribute(n,r+""),r):(x.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(T);if(o&&1===e.nodeType)while(n=o[i++])r=x.propFix[n]||n,x.expr.match.bool.test(n)?K&&Q||!G.test(n)?e[r]=!1:e[x.camelCase("default-"+n)]=e[r]=!1:x.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!x.support.radioValue&&"radio"===t&&x.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{"for":"htmlFor","class":"className"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!x.isXMLDoc(e),a&&(n=x.propFix[n]||n,o=x.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var t=x.find.attr(e,"tabindex");return t?parseInt(t,10):Y.test(e.nodeName)||J.test(e.nodeName)&&e.href?0:-1}}}}),X={set:function(e,t,n){return t===!1?x.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&x.propFix[n]||n,n):e[x.camelCase("default-"+n)]=e[n]=!0,n}},x.each(x.expr.match.bool.source.match(/\w+/g),function(e,n){var r=x.expr.attrHandle[n]||x.find.attr;x.expr.attrHandle[n]=K&&Q||!G.test(n)?function(e,n,i){var o=x.expr.attrHandle[n],a=i?t:(x.expr.attrHandle[n]=t)!=r(e,n,i)?n.toLowerCase():null;return x.expr.attrHandle[n]=o,a}:function(e,n,r){return r?t:e[x.camelCase("default-"+n)]?n.toLowerCase():null}}),K&&Q||(x.attrHooks.value={set:function(e,n,r){return x.nodeName(e,"input")?(e.defaultValue=n,t):z&&z.set(e,n,r)}}),Q||(z={set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},x.expr.attrHandle.id=x.expr.attrHandle.name=x.expr.attrHandle.coords=function(e,n,r){var i;return r?t:(i=e.getAttributeNode(n))&&""!==i.value?i.value:null},x.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&r.specified?r.value:t},set:z.set},x.attrHooks.contenteditable={set:function(e,t,n){z.set(e,""===t?!1:t,n)}},x.each(["width","height"],function(e,n){x.attrHooks[n]={set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}}})),x.support.hrefNormalized||x.each(["href","src"],function(e,t){x.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}}),x.support.style||(x.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),x.support.optSelected||(x.propHooks.selected={get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}}),x.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){x.propFix[this.toLowerCase()]=this}),x.support.enctype||(x.propFix.enctype="encoding"),x.each(["radio","checkbox"],function(){x.valHooks[this]={set:function(e,n){return x.isArray(n)?e.checked=x.inArray(x(e).val(),n)>=0:t}},x.support.checkOn||(x.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}function at(){try{return a.activeElement}catch(e){}}x.event={global:{},add:function(e,n,r,o,a){var s,l,u,c,p,f,d,h,g,m,y,v=x._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=x.guid++),(l=v.events)||(l=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof x===i||e&&x.event.triggered===e.type?t:x.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(T)||[""],u=n.length;while(u--)s=rt.exec(n[u])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),g&&(p=x.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=x.event.special[g]||{},d=x.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&x.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=l[g])||(h=l[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),x.event.global[g]=!0);e=null}},remove:function(e,t,n,r,i){var o,a,s,l,u,c,p,f,d,h,g,m=x.hasData(e)&&x._data(e);if(m&&(c=m.events)){t=(t||"").match(T)||[""],u=t.length;while(u--)if(s=rt.exec(t[u])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=x.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),l=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));l&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||x.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)x.event.remove(e,d+t[u],n,r,!0);x.isEmptyObject(c)&&(delete m.handle,x._removeData(e,"events"))}},trigger:function(n,r,i,o){var s,l,u,c,p,f,d,h=[i||a],g=v.call(n,"type")?n.type:n,m=v.call(n,"namespace")?n.namespace.split("."):[];if(u=f=i=i||a,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+x.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),l=0>g.indexOf(":")&&"on"+g,n=n[x.expando]?n:new x.Event(g,"object"==typeof n&&n),n.isTrigger=o?2:3,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:x.makeArray(r,[n]),p=x.event.special[g]||{},o||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!o&&!p.noBubble&&!x.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(u=u.parentNode);u;u=u.parentNode)h.push(u),f=u;f===(i.ownerDocument||a)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((u=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(x._data(u,"events")||{})[n.type]&&x._data(u,"handle"),s&&s.apply(u,r),s=l&&u[l],s&&x.acceptData(u)&&s.apply&&s.apply(u,r)===!1&&n.preventDefault();if(n.type=g,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(h.pop(),r)===!1)&&x.acceptData(i)&&l&&i[g]&&!x.isWindow(i)){f=i[l],f&&(i[l]=null),x.event.triggered=g;try{i[g]()}catch(y){}x.event.triggered=t,f&&(i[l]=f)}return n.result}},dispatch:function(e){e=x.event.fix(e);var n,r,i,o,a,s=[],l=g.call(arguments),u=(x._data(this,"events")||{})[e.type]||[],c=x.event.special[e.type]||{};if(l[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=x.event.handlers.call(this,e,u),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((x.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,l),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],l=n.delegateCount,u=e.target;if(l&&u.nodeType&&(!e.button||"click"!==e.type))for(;u!=this;u=u.parentNode||this)if(1===u.nodeType&&(u.disabled!==!0||"click"!==e.type)){for(o=[],a=0;l>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?x(r,this).index(u)>=0:x.find(r,this,null,[u]).length),o[r]&&o.push(i);o.length&&s.push({elem:u,handlers:o})}return n.length>l&&s.push({elem:this,handlers:n.slice(l)}),s},fix:function(e){if(e[x.expando])return e;var t,n,r,i=e.type,o=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new x.Event(o),t=r.length;while(t--)n=r[t],e[n]=o[n];return e.target||(e.target=o.srcElement||a),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,o):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,o,s=n.button,l=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||a,o=i.documentElement,r=i.body,e.pageX=n.clientX+(o&&o.scrollLeft||r&&r.scrollLeft||0)-(o&&o.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(o&&o.scrollTop||r&&r.scrollTop||0)-(o&&o.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&l&&(e.relatedTarget=l===e.target?n.toElement:l),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==at()&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===at()&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},click:{trigger:function(){return x.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t},_default:function(e){return x.nodeName(e.target,"a")}},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=x.extend(new x.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?x.event.trigger(i,null,t):x.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},x.removeEvent=a.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},x.Event=function(e,n){return this instanceof x.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&x.extend(this,n),this.timeStamp=e&&e.timeStamp||x.now(),this[x.expando]=!0,t):new x.Event(e,n)},x.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},x.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){x.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;return(!i||i!==r&&!x.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),x.support.submitBubbles||(x.event.special.submit={setup:function(){return x.nodeName(this,"form")?!1:(x.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=x.nodeName(n,"input")||x.nodeName(n,"button")?n.form:t;r&&!x._data(r,"submitBubbles")&&(x.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),x._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&x.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return x.nodeName(this,"form")?!1:(x.event.remove(this,"._submit"),t)}}),x.support.changeBubbles||(x.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(x.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),x.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),x.event.simulate("change",this,e,!0)})),!1):(x.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!x._data(t,"changeBubbles")&&(x.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||x.event.simulate("change",this.parentNode,e,!0)}),x._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return x.event.remove(this,"._change"),!Z.test(this.nodeName)}}),x.support.focusinBubbles||x.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){x.event.simulate(t,e.target,x.event.fix(e),!0)};x.event.special[t]={setup:function(){0===n++&&a.addEventListener(e,r,!0)},teardown:function(){0===--n&&a.removeEventListener(e,r,!0)}}}),x.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return x().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=x.guid++)),this.each(function(){x.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,x(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){x.event.remove(this,e,r,n)})},trigger:function(e,t){return this.each(function(){x.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?x.event.trigger(e,n,r,!0):t}});var st=/^.[^:#\[\.,]*$/,lt=/^(?:parents|prev(?:Until|All))/,ut=x.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};x.fn.extend({find:function(e){var t,n=[],r=this,i=r.length;if("string"!=typeof e)return this.pushStack(x(e).filter(function(){for(t=0;i>t;t++)if(x.contains(r[t],this))return!0}));for(t=0;i>t;t++)x.find(e,r[t],n);return n=this.pushStack(i>1?x.unique(n):n),n.selector=this.selector?this.selector+" "+e:e,n},has:function(e){var t,n=x(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(x.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e||[],!0))},filter:function(e){return this.pushStack(ft(this,e||[],!1))},is:function(e){return!!ft(this,"string"==typeof e&&ut.test(e)?x(e):e||[],!1).length},closest:function(e,t){var n,r=0,i=this.length,o=[],a=ut.test(e)||"string"!=typeof e?x(e,t||this.context):0;for(;i>r;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(11>n.nodeType&&(a?a.index(n)>-1:1===n.nodeType&&x.find.matchesSelector(n,e))){n=o.push(n);break}return this.pushStack(o.length>1?x.unique(o):o)},index:function(e){return e?"string"==typeof e?x.inArray(this[0],x(e)):x.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?x(e,t):x.makeArray(e&&e.nodeType?[e]:e),r=x.merge(this.get(),n);return this.pushStack(x.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}});function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}x.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return x.dir(e,"parentNode")},parentsUntil:function(e,t,n){return x.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return x.dir(e,"nextSibling")},prevAll:function(e){return x.dir(e,"previousSibling")},nextUntil:function(e,t,n){return x.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return x.dir(e,"previousSibling",n)},siblings:function(e){return x.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return x.sibling(e.firstChild)},contents:function(e){return x.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:x.merge([],e.childNodes)}},function(e,t){x.fn[e]=function(n,r){var i=x.map(this,t,n);return"Until"!==e.slice(-5)&&(r=n),r&&"string"==typeof r&&(i=x.filter(r,i)),this.length>1&&(ct[e]||(i=x.unique(i)),lt.test(e)&&(i=i.reverse())),this.pushStack(i)}}),x.extend({filter:function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?x.find.matchesSelector(r,e)?[r]:[]:x.find.matches(e,x.grep(t,function(e){return 1===e.nodeType}))},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!x(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(x.isFunction(t))return x.grep(e,function(e,r){return!!t.call(e,r,e)!==n});if(t.nodeType)return x.grep(e,function(e){return e===t!==n});if("string"==typeof t){if(st.test(t))return x.filter(t,e,n);t=x.filter(t,e)}return x.grep(e,function(e){return x.inArray(e,t)>=0!==n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Ct=/^(?:checkbox|radio)$/i,Nt=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:x.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(a),Dt=jt.appendChild(a.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,x.fn.extend({text:function(e){return x.access(this,function(e){return e===t?x.text(this):this.empty().append((this[0]&&this[0].ownerDocument||a).createTextNode(e))},null,e,arguments.length)},append:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.appendChild(e)}})},prepend:function(){return this.domManip(arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Lt(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=e?x.filter(e,this):this,i=0;for(;null!=(n=r[i]);i++)t||1!==n.nodeType||x.cleanData(Ft(n)),n.parentNode&&(t&&x.contains(n.ownerDocument,n)&&_t(Ft(n,"script")),n.parentNode.removeChild(n));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&x.cleanData(Ft(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&x.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return x.clone(this,e,t)})},html:function(e){return x.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!x.support.htmlSerialize&&mt.test(e)||!x.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(x.cleanData(Ft(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var e=x.map(this,function(e){return[e.nextSibling,e.parentNode]}),t=0;return this.domManip(arguments,function(n){var r=e[t++],i=e[t++];i&&(r&&r.parentNode!==i&&(r=this.nextSibling),x(this).remove(),i.insertBefore(n,r))},!0),t?this:this.remove()},detach:function(e){return this.remove(e,!0)},domManip:function(e,t,n){e=d.apply([],e);var r,i,o,a,s,l,u=0,c=this.length,p=this,f=c-1,h=e[0],g=x.isFunction(h);if(g||!(1>=c||"string"!=typeof h||x.support.checkClone)&&Nt.test(h))return this.each(function(r){var i=p.eq(r);g&&(e[0]=h.call(this,r,i.html())),i.domManip(e,t,n)});if(c&&(l=x.buildFragment(e,this[0].ownerDocument,!1,!n&&this),r=l.firstChild,1===l.childNodes.length&&(l=r),r)){for(a=x.map(Ft(l,"script"),Ht),o=a.length;c>u;u++)i=l,u!==f&&(i=x.clone(i,!0,!0),o&&x.merge(a,Ft(i,"script"))),t.call(this[u],i,u);if(o)for(s=a[a.length-1].ownerDocument,x.map(a,qt),u=0;o>u;u++)i=a[u],kt.test(i.type||"")&&!x._data(i,"globalEval")&&x.contains(s,i)&&(i.src?x._evalUrl(i.src):x.globalEval((i.text||i.textContent||i.innerHTML||"").replace(St,"")));l=r=null}return this}});function Lt(e,t){return x.nodeName(e,"table")&&x.nodeName(1===t.nodeType?t:t.firstChild,"tr")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}function Ht(e){return e.type=(null!==x.find.attr(e,"type"))+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function _t(e,t){var n,r=0;for(;null!=(n=e[r]);r++)x._data(n,"globalEval",!t||x._data(t[r],"globalEval"))}function Mt(e,t){if(1===t.nodeType&&x.hasData(e)){var n,r,i,o=x._data(e),a=x._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)x.event.add(t,n,s[n][r])}a.data&&(a.data=x.extend({},a.data))}}function Ot(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!x.support.noCloneEvent&&t[x.expando]){i=x._data(t);for(r in i.events)x.removeEvent(t,r,i.handle);t.removeAttribute(x.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),x.support.html5Clone&&e.innerHTML&&!x.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Ct.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}x.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){x.fn[e]=function(e){var n,r=0,i=[],o=x(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),x(o[r])[t](n),h.apply(i,n.get());return this.pushStack(i)}});function Ft(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||x.nodeName(o,n)?s.push(o):x.merge(s,Ft(o,n));return n===t||n&&x.nodeName(e,n)?x.merge([e],s):s}function Bt(e){Ct.test(e.type)&&(e.defaultChecked=e.checked)}x.extend({clone:function(e,t,n){var r,i,o,a,s,l=x.contains(e.ownerDocument,e);if(x.support.html5Clone||x.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(x.support.noCloneEvent&&x.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||x.isXMLDoc(e)))for(r=Ft(o),s=Ft(e),a=0;null!=(i=s[a]);++a)r[a]&&Ot(i,r[a]);if(t)if(n)for(s=s||Ft(e),r=r||Ft(o),a=0;null!=(i=s[a]);a++)Mt(i,r[a]);else Mt(e,o);return r=Ft(o,"script"),r.length>0&&_t(r,!l&&Ft(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,l,u,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===x.type(o))x.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),l=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[l]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!x.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!x.support.tbody){o="table"!==l||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)x.nodeName(u=o.childNodes[i],"tbody")&&!u.childNodes.length&&o.removeChild(u)}x.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),x.support.appendChecked||x.grep(Ft(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===x.inArray(o,r))&&(a=x.contains(o.ownerDocument,o),s=Ft(f.appendChild(o),"script"),a&&_t(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,l=x.expando,u=x.cache,c=x.support.deleteExpando,f=x.event.special;for(;null!=(n=e[s]);s++)if((t||x.acceptData(n))&&(o=n[l],a=o&&u[o])){if(a.events)for(r in a.events)f[r]?x.event.remove(n,r):x.removeEvent(n,r,a.handle);
u[o]&&(delete u[o],c?delete n[l]:typeof n.removeAttribute!==i?n.removeAttribute(l):n[l]=null,p.push(o))}},_evalUrl:function(e){return x.ajax({url:e,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})}}),x.fn.extend({wrapAll:function(e){if(x.isFunction(e))return this.each(function(t){x(this).wrapAll(e.call(this,t))});if(this[0]){var t=x(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return x.isFunction(e)?this.each(function(t){x(this).wrapInner(e.call(this,t))}):this.each(function(){var t=x(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=x.isFunction(e);return this.each(function(n){x(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){x.nodeName(this,"body")||x(this).replaceWith(this.childNodes)}).end()}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+w+")(.*)$","i"),Yt=RegExp("^("+w+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+w+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===x.css(e,"display")||!x.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=x._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=x._data(r,"olddisplay",ln(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&x._data(r,"olddisplay",i?n:x.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}x.fn.extend({css:function(e,n){return x.access(this,function(e,n,r){var i,o,a={},s=0;if(x.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=x.css(e,n[s],!1,o);return a}return r!==t?x.style(e,n,r):x.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){nn(this)?x(this).show():x(this).hide()})}}),x.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":x.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,l=x.camelCase(n),u=e.style;if(n=x.cssProps[l]||(x.cssProps[l]=tn(u,l)),s=x.cssHooks[n]||x.cssHooks[l],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:u[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(x.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||x.cssNumber[l]||(r+="px"),x.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(u[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{u[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,l=x.camelCase(n);return n=x.cssProps[l]||(x.cssProps[l]=tn(e.style,l)),s=x.cssHooks[n]||x.cssHooks[l],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||x.isNumeric(o)?o||0:a):a}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s.getPropertyValue(n)||s[n]:t,u=e.style;return s&&(""!==l||x.contains(e.ownerDocument,e)||(l=x.style(e,n)),Yt.test(l)&&Ut.test(n)&&(i=u.width,o=u.minWidth,a=u.maxWidth,u.minWidth=u.maxWidth=u.width=l,l=s.width,u.width=i,u.minWidth=o,u.maxWidth=a)),l}):a.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),l=s?s[n]:t,u=e.style;return null==l&&u&&u[n]&&(l=u[n]),Yt.test(l)&&!zt.test(n)&&(i=u.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),u.left="fontSize"===n?"1em":l,l=u.pixelLeft+"px",u.left=i,a&&(o.left=a)),""===l?"auto":l});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=x.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=x.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=x.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=x.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=x.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(x.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function ln(e){var t=a,n=Gt[e];return n||(n=un(e,t),"none"!==n&&n||(Pt=(Pt||x("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=un(e,t),Pt.detach()),Gt[e]=n),n}function un(e,t){var n=x(t.createElement(e)).appendTo(t.body),r=x.css(n[0],"display");return n.remove(),r}x.each(["height","width"],function(e,n){x.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(x.css(e,"display"))?x.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,x.support.boxSizing&&"border-box"===x.css(e,"boxSizing",!1,i),i):0)}}}),x.support.opacity||(x.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=x.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===x.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),x(function(){x.support.reliableMarginRight||(x.cssHooks.marginRight={get:function(e,n){return n?x.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!x.support.pixelPosition&&x.fn.position&&x.each(["top","left"],function(e,n){x.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?x(e).position()[n]+"px":r):t}}})}),x.expr&&x.expr.filters&&(x.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!x.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||x.css(e,"display"))},x.expr.filters.visible=function(e){return!x.expr.filters.hidden(e)}),x.each({margin:"",padding:"",border:"Width"},function(e,t){x.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(x.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;x.fn.extend({serialize:function(){return x.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=x.prop(this,"elements");return e?x.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!x(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Ct.test(e))}).map(function(e,t){var n=x(this).val();return null==n?null:x.isArray(n)?x.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),x.param=function(e,n){var r,i=[],o=function(e,t){t=x.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=x.ajaxSettings&&x.ajaxSettings.traditional),x.isArray(e)||e.jquery&&!x.isPlainObject(e))x.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(x.isArray(t))x.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==x.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){x.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),x.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}});var mn,yn,vn=x.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Cn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Nn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=x.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=o.href}catch(Ln){yn=a.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(T)||[];if(x.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(l){var u;return o[l]=!0,x.each(e[l]||[],function(e,l){var c=l(n,r,i);return"string"!=typeof c||a||o[c]?a?!(u=c):t:(n.dataTypes.unshift(c),s(c),!1)}),u}return s(n.dataTypes[0])||!o["*"]&&s("*")}function _n(e,n){var r,i,o=x.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&x.extend(!0,e,r),e}x.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,l=e.indexOf(" ");return l>=0&&(i=e.slice(l,e.length),e=e.slice(0,l)),x.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&x.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?x("<div>").append(x.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},x.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){x.fn[t]=function(e){return this.on(t,e)}}),x.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Cn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":x.parseJSON,"text xml":x.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?_n(_n(e,x.ajaxSettings),t):_n(x.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,l,u,c,p=x.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?x(f):x.event,h=x.Deferred(),g=x.Callbacks("once memory"),m=p.statusCode||{},y={},v={},b=0,w="canceled",C={readyState:0,getResponseHeader:function(e){var t;if(2===b){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===b?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return b||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return b||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>b)for(t in e)m[t]=[m[t],e[t]];else C.always(e[C.status]);return this},abort:function(e){var t=e||w;return u&&u.abort(t),k(0,t),this}};if(h.promise(C).complete=g.add,C.success=C.done,C.error=C.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=x.trim(p.dataType||"*").toLowerCase().match(T)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?"80":"443"))===(mn[3]||("http:"===mn[1]?"80":"443")))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=x.param(p.data,p.traditional)),qn(An,p,n,C),2===b)return C;l=p.global,l&&0===x.active++&&x.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Nn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(x.lastModified[o]&&C.setRequestHeader("If-Modified-Since",x.lastModified[o]),x.etag[o]&&C.setRequestHeader("If-None-Match",x.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&C.setRequestHeader("Content-Type",p.contentType),C.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)C.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,C,p)===!1||2===b))return C.abort();w="abort";for(i in{success:1,error:1,complete:1})C[i](p[i]);if(u=qn(jn,p,n,C)){C.readyState=1,l&&d.trigger("ajaxSend",[C,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){C.abort("timeout")},p.timeout));try{b=1,u.send(y,k)}catch(N){if(!(2>b))throw N;k(-1,N)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,N=n;2!==b&&(b=2,s&&clearTimeout(s),u=t,a=i||"",C.readyState=e>0?4:0,c=e>=200&&300>e||304===e,r&&(w=Mn(p,C,r)),w=On(p,w,C,c),c?(p.ifModified&&(T=C.getResponseHeader("Last-Modified"),T&&(x.lastModified[o]=T),T=C.getResponseHeader("etag"),T&&(x.etag[o]=T)),204===e||"HEAD"===p.type?N="nocontent":304===e?N="notmodified":(N=w.state,y=w.data,v=w.error,c=!v)):(v=N,(e||!N)&&(N="error",0>e&&(e=0))),C.status=e,C.statusText=(n||N)+"",c?h.resolveWith(f,[y,N,C]):h.rejectWith(f,[C,N,v]),C.statusCode(m),m=t,l&&d.trigger(c?"ajaxSuccess":"ajaxError",[C,p,c?y:v]),g.fireWith(f,[C,N]),l&&(d.trigger("ajaxComplete",[C,p]),--x.active||x.event.trigger("ajaxStop")))}return C},getJSON:function(e,t,n){return x.get(e,t,n,"json")},getScript:function(e,n){return x.get(e,t,n,"script")}}),x.each(["get","post"],function(e,n){x[n]=function(e,r,i,o){return x.isFunction(r)&&(o=o||i,i=r,r=t),x.ajax({url:e,type:n,dataType:o,data:r,success:i})}});function Mn(e,n,r){var i,o,a,s,l=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in l)if(l[s]&&l[s].test(o)){u.unshift(s);break}if(u[0]in r)a=u[0];else{for(s in r){if(!u[0]||e.converters[s+" "+u[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==u[0]&&u.unshift(a),r[a]):t}function On(e,t,n,r){var i,o,a,s,l,u={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)u[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!l&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),l=o,o=c.shift())if("*"===o)o=l;else if("*"!==l&&l!==o){if(a=u[l+" "+o]||u["* "+o],!a)for(i in u)if(s=i.split(" "),s[1]===o&&(a=u[l+" "+s[0]]||u["* "+s[0]])){a===!0?a=u[i]:u[i]!==!0&&(o=s[0],c.unshift(s[1]));break}if(a!==!0)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(p){return{state:"parsererror",error:a?p:"No conversion from "+l+" to "+o}}}return{state:"success",data:t}}x.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return x.globalEval(e),e}}}),x.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),x.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=a.head||x("head")[0]||a.documentElement;return{send:function(t,i){n=a.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var Fn=[],Bn=/(=)\?(?=&|$)|\?\?/;x.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Fn.pop()||x.expando+"_"+vn++;return this[e]=!0,e}}),x.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,l=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return l||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=x.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,l?n[l]=n[l].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||x.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,Fn.push(o)),s&&x.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}x.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=x.ajaxSettings.xhr(),x.support.cors=!!Rn&&"withCredentials"in Rn,Rn=x.support.ajax=!!Rn,Rn&&x.ajaxTransport(function(n){if(!n.crossDomain||x.support.cors){var r;return{send:function(i,o){var a,s,l=n.xhr();if(n.username?l.open(n.type,n.url,n.async,n.username,n.password):l.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)l[s]=n.xhrFields[s];n.mimeType&&l.overrideMimeType&&l.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)l.setRequestHeader(s,i[s])}catch(u){}l.send(n.hasContent&&n.data||null),r=function(e,i){var s,u,c,p;try{if(r&&(i||4===l.readyState))if(r=t,a&&(l.onreadystatechange=x.noop,$n&&delete Pn[a]),i)4!==l.readyState&&l.abort();else{p={},s=l.status,u=l.getAllResponseHeaders(),"string"==typeof l.responseText&&(p.text=l.responseText);try{c=l.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,u)},n.async?4===l.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},x(e).unload($n)),Pn[a]=r),l.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+w+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n=this.createTween(e,t),r=n.cur(),i=Yn.exec(t),o=i&&i[3]||(x.cssNumber[e]?"":"px"),a=(x.cssNumber[e]||"px"!==o&&+r)&&Yn.exec(x.css(n.elem,e)),s=1,l=20;if(a&&a[3]!==o){o=o||a[3],i=i||[],a=+r||1;do s=s||".5",a/=s,x.style(n.elem,e,a+o);while(s!==(s=n.cur()/r)&&1!==s&&--l)}return i&&(a=n.start=+a||+r||0,n.unit=o,n.end=i[1]?a+(i[1]+1)*i[2]:+i[2]),n}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=x.now()}function Zn(e,t,n){var r,i=(Qn[t]||[]).concat(Qn["*"]),o=0,a=i.length;for(;a>o;o++)if(r=i[o].call(n,t,e))return r}function er(e,t,n){var r,i,o=0,a=Gn.length,s=x.Deferred().always(function(){delete l.elem}),l=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,u.startTime+u.duration-t),r=n/u.duration||0,o=1-r,a=0,l=u.tweens.length;for(;l>a;a++)u.tweens[a].run(o);return s.notifyWith(e,[u,o,n]),1>o&&l?n:(s.resolveWith(e,[u]),!1)},u=s.promise({elem:e,props:x.extend({},t),opts:x.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=x.Tween(e,u.opts,t,n,u.opts.specialEasing[t]||u.opts.easing);return u.tweens.push(r),r},stop:function(t){var n=0,r=t?u.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)u.tweens[n].run(1);return t?s.resolveWith(e,[u,t]):s.rejectWith(e,[u,t]),this}}),c=u.props;for(tr(c,u.opts.specialEasing);a>o;o++)if(r=Gn[o].call(u,e,c,u.opts))return r;return x.map(c,Zn,u),x.isFunction(u.opts.start)&&u.opts.start.call(e,u),x.fx.timer(x.extend(l,{elem:e,anim:u,queue:u.opts.queue})),u.progress(u.opts.progress).done(u.opts.done,u.opts.complete).fail(u.opts.fail).always(u.opts.always)}function tr(e,t){var n,r,i,o,a;for(n in e)if(r=x.camelCase(n),i=t[r],o=e[n],x.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),a=x.cssHooks[r],a&&"expand"in a){o=a.expand(o),delete e[r];for(n in o)n in e||(e[n]=o[n],t[n]=i)}else t[r]=i}x.Animation=x.extend(er,{tweener:function(e,t){x.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,l,u=this,c={},p=e.style,f=e.nodeType&&nn(e),d=x._data(e,"fxshow");n.queue||(s=x._queueHooks(e,"fx"),null==s.unqueued&&(s.unqueued=0,l=s.empty.fire,s.empty.fire=function(){s.unqueued||l()}),s.unqueued++,u.always(function(){u.always(function(){s.unqueued--,x.queue(e,"fx").length||s.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],"inline"===x.css(e,"display")&&"none"===x.css(e,"float")&&(x.support.inlineBlockNeedsLayout&&"inline"!==ln(e.nodeName)?p.zoom=1:p.display="inline-block")),n.overflow&&(p.overflow="hidden",x.support.shrinkWrapBlocks||u.always(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t)if(i=t[r],Vn.exec(i)){if(delete t[r],o=o||"toggle"===i,i===(f?"hide":"show"))continue;c[r]=d&&d[r]||x.style(e,r)}if(!x.isEmptyObject(c)){d?"hidden"in d&&(f=d.hidden):d=x._data(e,"fxshow",{}),o&&(d.hidden=!f),f?x(e).show():u.done(function(){x(e).hide()}),u.done(function(){var t;x._removeData(e,"fxshow");for(t in c)x.style(e,t,c[t])});for(r in c)a=Zn(f?d[r]:0,r,u),r in d||(d[r]=a.start,f&&(a.end=a.start,a.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}x.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(x.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?x.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=x.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){x.fx.step[e.prop]?x.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[x.cssProps[e.prop]]||x.cssHooks[e.prop])?x.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},x.each(["toggle","show","hide"],function(e,t){var n=x.fn[t];x.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),x.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=x.isEmptyObject(e),o=x.speed(t,n,r),a=function(){var t=er(this,x.extend({},e),o);(i||x._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=x.timers,a=x._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&x.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=x._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=x.timers,a=r?r.length:0;for(n.finish=!0,x.queue(this,e,[]),i&&i.stop&&i.stop.call(this,!0),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}x.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){x.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),x.speed=function(e,t,n){var r=e&&"object"==typeof e?x.extend({},e):{complete:n||!n&&t||x.isFunction(e)&&e,duration:e,easing:n&&t||t&&!x.isFunction(t)&&t};return r.duration=x.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in x.fx.speeds?x.fx.speeds[r.duration]:x.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){x.isFunction(r.old)&&r.old.call(this),r.queue&&x.dequeue(this,r.queue)},r},x.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},x.timers=[],x.fx=rr.prototype.init,x.fx.tick=function(){var e,n=x.timers,r=0;for(Xn=x.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||x.fx.stop(),Xn=t},x.fx.timer=function(e){e()&&x.timers.push(e)&&x.fx.start()},x.fx.interval=13,x.fx.start=function(){Un||(Un=setInterval(x.fx.tick,x.fx.interval))},x.fx.stop=function(){clearInterval(Un),Un=null},x.fx.speeds={slow:600,fast:200,_default:400},x.fx.step={},x.expr&&x.expr.filters&&(x.expr.filters.animated=function(e){return x.grep(x.timers,function(t){return e===t.elem}).length}),x.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){x.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,x.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},x.offset={setOffset:function(e,t,n){var r=x.css(e,"position");"static"===r&&(e.style.position="relative");var i=x(e),o=i.offset(),a=x.css(e,"top"),s=x.css(e,"left"),l=("absolute"===r||"fixed"===r)&&x.inArray("auto",[a,s])>-1,u={},c={},p,f;l?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),x.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(u.top=t.top-o.top+p),null!=t.left&&(u.left=t.left-o.left+f),"using"in t?t.using.call(e,u):i.css(u)}},x.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===x.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),x.nodeName(e[0],"html")||(n=e.offset()),n.top+=x.css(e[0],"borderTopWidth",!0),n.left+=x.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-x.css(r,"marginTop",!0),left:t.left-n.left-x.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||s;while(e&&!x.nodeName(e,"html")&&"static"===x.css(e,"position"))e=e.offsetParent;return e||s})}}),x.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);x.fn[e]=function(i){return x.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?x(a).scrollLeft():o,r?o:x(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return x.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}x.each({Height:"height",Width:"width"},function(e,n){x.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){x.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return x.access(this,function(n,r,i){var o;return x.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?x.css(n,r,s):x.style(n,r,i,s)},n,a?i:t,a,null)}})}),x.fn.size=function(){return this.length},x.fn.andSelf=x.fn.addBack,"object"==typeof module&&module&&"object"==typeof module.exports?module.exports=x:(e.jQuery=e.$=x,"function"==typeof define&&define.amd&&define("jquery",[],function(){return x}))})(window);
/**
	JS正文开始
*/
//全局变量
var img;
var _java_text=false;
$(function(){
	//边框显示、样式
	$("#first_page,#first_page > label:first").css("display","block");
	$("#first_page > label:first").css({
		"margin-top":"25%",
		"text-align":"center"
	});
	/*要求：有子节点变样式，无则不变；点击隐藏自己同级节点，显示子节点(不含后代节点)
			禁用冒泡、绑定事件、样式、上一页、首页跳转*/
	$("label")
		//鼠标悬停、离开
		.hover(
			function(e){
				e.stopPropagation();
				if($(this).next("label:first").children("label").length==0)return;
				$(this).css("color","white").css({"cursor":"pointer"});
			},function(e){
				e.stopPropagation();
				$(this).css({"color":"black"});
			})
		//鼠标点击
		.click(
			function(e){
				e.stopPropagation();
				//没有子元素，就不可点
				if($(this).next("label:first").children("label").length==0)return;
				//隐藏全部label
				$("label").css("display","none");
				//上一页样式
				$("#to_back_page").css("display","block").css({
					"position":"absolute",
					"bottom":"2%",
					"left":"35%"
				});
				//首页样式
				$("#to_first_page").css("display","block").css({
					"position":"absolute",
					"bottom":"2%",
					"left":"55%"
				});
				//首页、上一页跳转事件绑定
				if(this.id=='to_first_page'){
					$("label").css("display","none");
					$("#first_page,#first_page > label:first").css("display","block");
					$("#first_page > label:first").css({
						"margin-top":"25%",
						"text-align":"center"
					});
					return;
				}else if(this.id=='to_back_page'){
					//清除标记对象的最后一个
					var _this_obj=$(".cur").get($(".cur").length-1);
					$(_this_obj).parent().children("label:even").css("display","block").parents().css("display","block");
					$(_this_obj).parent().children("label:odd").css("display","none");
					if($(_this_obj).parent().attr("id")=="first_page"){
						$("#to_back_page").css("display","none");
						$("#to_first_page").css("display","none");
					}
					//清除标记对象
					$(_this_obj).removeAttr("class");
					//目录滚动
					_this_obj=$(".cur").get($(".cur").length-1);
					if($(_this_obj).next("label:first").children("label:even").length>8){
						$(_this_obj).next("label:first").css({
							"margin-top":"-5%","overflow":"auto","height":($("#first_page").height()*0.68)
						});
						_java_text=true;
					}else{
						_java_text=false;
					}
					return;
				}
				//最后一级
				if($(this).next("label:first").children("label").length==1 && !$(this).context.id.match("^(to_back_page|to_first_page)$")){
					if(_java_text){
						$(this).next("label:first").css("display","block").children("label:even").css({
								"display":"block","text-align":"left","overflow":"auto"
								,"margin-top":"0%","margin-left":"2%","margin-right":"2%"
								,"height":"98%","width":"96%"
							}).parents().css("display","block");
					}else{
						$(this).next("label:first").css("display","block").children("label:even").css({
								"display":"block","text-align":"left","overflow":"auto"
								,"margin-top":"-15%","margin-left":"2%","margin-right":"2%"
								,"height":"83%","width":"96%"
							}).parents().css("display","block");
					}
					//标记本次点击对象
					$(this).attr("class","cur");
					_java_text=false;
					return;
				}
				//点击label进入下一页
				$(this).next("label:first").css({
						"display":"block",
						"margin-top":"25%",
						"text-align":"center"
					})
					.children("label:even").css({
						"display":"block",
						"margin-top":"5%"
					}).parents().css({"display":"block"});
				$(this).next("label:first").css("display","block")
					.children("label:odd").css("display","none");
				//目录滚动
				if($(this).next("label:first").children("label:even").length>8){
					$(this).next("label:first").css({
						"margin-top":"-5%","overflow":"auto","height":($("#first_page").height()*0.68)
					});
					_java_text=true;
				}
				//标记本次点击对象
				$(this).attr("class","cur");
		});
		drawkoch();
});
//Canvas画图-雪花
function drawkoch(){
	var drawing=document.getElementById("snow");//获取canvas对象
	$("#snow").css("display","none");
	if(drawing.getContext){//可以通过这种方式检测浏览器是否支持canvas标签
		drawing.height = drawing.height; //重设canvas的宽或高可以清空标签中的图案，相当于clear()
		var ctx=drawing.getContext("2d");//获取画布上的绘图环境
		ctx.strokeStyle = "#ffffff"; //设置画笔的颜色，支持css样式的颜色表现方式，可以用rgba(r, g, b, a)这样的方式
		ctx.beginPath(); //丢弃任何当前定义的路径并且开始一条新的路径。它把当前的点设置为 (0,0)。
		//ctx.moveTo(5, 5); //移动“画笔”到点（5， 5），就像把笔拿起来，然后放到(5, 5)的位置上
		//ctx.lineTo(10, 10); //画线到点(10, 10)，从现在的画笔落点，画直线一直到点(10, 10)
		//ctx.stroke(); //开始绘制，把刚才所划定的区域“勾勒”轮廓。fill方法用来填充。
		var x1 = 40.00;
		var y1 = 15.00;
		var x2 = 10.00;
		var y2 = 15.00;
		var x11 = x2 + (x1 - x2) / 2;
		var y11 = y1 + Math.sin(Math.PI / 3) * (x1 - x2);
		//取得一个文本框的值，可以调整维度，这里没有进行输入判断。
		var depth = 2;//parseInt(10); 
		koch(ctx, x1, y1, x2, y2, 0, depth);
		koch(ctx, x11, y11, x1, y1, 0, depth);
		koch(ctx, x2, y2, x11, y11, 0, depth);
		
		img=new Image();
		img.src=drawing.toDataURL("snow.png");
		img.onload=function(){ctx.drawImage(img,0,0);}
	 }else{
		alert("不支持Canvas");
	 }
}
function koch(ctx, x1, y1, x2, y2, n, m){     
	if(m == 0){
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
		return false;
	}
	var x3 = (x2 - x1) / 3 + x1;
	var y3 = (y2 - y1) /3 + y1;
	var x4 = (x2 - x1) / 3 * 2 + x1;
	var y4 = (y2 - y1) / 3 * 2 + y1;
	var x5 = x3 + ((x2 - x1) - (y2 - y1) * Math.sqrt(3)) / 6;
	var y5 = y3 + ((x2 - x1) * Math.sqrt(3) + (y2 - y1)) / 6;
	n = n + 1;
	if(n == m){
		ctx.moveTo(x1, y1);
		ctx.lineTo(x3, y3);
		ctx.lineTo(x5, y5);
		ctx.lineTo(x4, y4);
		ctx.lineTo(x2, y2);
		ctx.stroke();
		return false;
	}
	koch(ctx, x1, y1, x3, y3, n, m)
	koch(ctx, x3, y3, x5, y5, n, m)
	koch(ctx, x5, y5, x4, y4, n, m)
	koch(ctx, x4, y4, x2, y2, n, m)
}
//动画效果-降落(引用Canvas画出的图片)
const NUMBER_OF_LEAVES = 61.8;
function init(){
    var container = $("#leafContainer").get(0);//document.getElementById('leafContainer');
    for (var i = 0; i < NUMBER_OF_LEAVES; i++) {
        container.appendChild(createALeaf());
    }
}
function randomInteger(low, high){
    return low + Math.floor(Math.random() * (high - low));
}
function randomFloat(low, high){
    return low + Math.random() * (high - low);
}
function pixelValue(value){
    return value + 'px';
}
function durationValue(value){
    return value + 's';
}
function createALeaf(){
    var leafDiv = document.createElement('div');
    var image = document.createElement('img');
    image.src = img.src;
    leafDiv.style.top = "-100px";
    leafDiv.style.left = pixelValue(randomInteger(0, 500));
    var spinAnimationName = (Math.random() < 0.5) ? 'clockwiseSpin' : 'counterclockwiseSpinAndFlip';
    leafDiv.style.webkitAnimationName = 'fade, drop';
    image.style.webkitAnimationName = spinAnimationName;
    var fadeAndDropDuration = durationValue(randomFloat(5, 11));
    var spinDuration = durationValue(randomFloat(4, 8));
    leafDiv.style.webkitAnimationDuration = fadeAndDropDuration + ', ' + fadeAndDropDuration;
    var leafDelay = durationValue(randomFloat(0, 5));
    leafDiv.style.webkitAnimationDelay = leafDelay + ', ' + leafDelay;
    image.style.webkitAnimationDuration = spinDuration;
    leafDiv.appendChild(image);
    return leafDiv;
}
window.addEventListener('load', init, false);
/**
//用这个<pre>标签能原样输入插入时的格式，但是要对<pre>加一些CSS样式才行啦
// css-3
// Mozilla, since 1999 
// Opera 4-6
// Opera 7
// Internet Explorer 5.5+
pre{
	white-space: pre-wrap;       
	white-space: -moz-pre-wrap;  
	white-space: -pre-wrap;      
	white-space: -o-pre-wrap;    
	word-wrap: break-word;       
	word-break:break-all;  
	overflow:hidden;
}
*/
</script>
</html>